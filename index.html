<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mead Tracker</title>
  <style>
:root {
  /* ==== Theme Variables ==== */
  /* Background color for the app (main page background) */
  --bg: #0f1216;
  /* Panel background color (cards, sidebars, etc.) */
  --panel: #161a20;
  /* Muted text color for secondary information */
  --muted: #aab2c0;
  /* Main text color for normal content */
  --text: #e8edf5;
  /* Primary accent color (used for highlights, buttons, and lines) */
  --accent: #82cfff;
  /* Secondary accent color (used for hover or complementary effects) */
  --accent-2: #b5e08a;
  /* Error or warning color (used for delete buttons, alerts, etc.) */
  --danger: #ff6b6b;
  /* Border color for panels, inputs, and dividers */
  --border: #2a2f39;
  /* Box shadow for raised UI elements (cards, modals, etc.) */
  --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  /* Default border radius for rounded corners */
  --radius: 14px;
}
	
/* Apply universal box-sizing to make layout calculations consistent */
* {
  box-sizing: border-box;
}

/* Ensure the document and body take up the full viewport height */
html, body {
  height: 100%;
}

/* Base body styles */
body {
  margin: 0; /* Remove default browser margin */
  
  /* Use a modern, system-based sans-serif font stack for readability */
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
    Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";

  /* Subtle radial gradient background, darker at center edges */
  background: radial-gradient(
    1200px 800px at 100% -10%,  /* Gradient size and position */
    #16202e 0,                 /* Lighter blue-gray center tone */
    #0f1216 50%                /* Dark background base tone */
  );

  /* Default text color for the entire page (from theme variable) */
  color: var(--text);
}

/* Style for all numeric input fields */
input[type="number"] {
  font-size: 16px; /* Slightly larger text for readability */
}

/* Wide variant of numeric inputs (used in forms where full width is desired) */
input[type="number"].wide {
  width: 100%;       /* Expand to fill available container width */
  min-width: 150px;  /* Prevent input from becoming too narrow */
}


/* Main application layout container */
/* Uses a two-column grid: sidebar (fixed width) + main content (flexible) */
.app {
  display: grid;                         /* establish grid layout */
  grid-template-columns: 320px 1fr;      /* sidebar = 320px, main content = remaining space */
  gap: 16px;                             /* space between columns */
  height: 100%;                          /* fill full viewport height */
  padding: 16px;                         /* outer spacing around the app */
}

/* === Layout & Card Structure === */

/* Shared card style used for panels and sections */
.card {
  background: var(--panel);                 /* panel background color */
  border: 1px solid var(--border);          /* subtle border outline */
  border-radius: var(--radius);             /* consistent rounded corners */
  box-shadow: var(--shadow);                /* soft depth shadow */
}

/* Sidebar container — vertical layout for batch list and controls */
.sidebar {
  display: flex;
  flex-direction: column;
  overflow: hidden; /* prevent scrollbars on inner overflow */
}

/* Sidebar header — title bar + New button */
.sidebar header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px; /* small gap between title and button */
}

/* Sidebar title text */
.sidebar header h1 {
  font-size: 18px;
  margin: 0;
}

/* Search bar container fills sidebar width */
.search {
  width: 100%;
}

/* Search input field styling */
.search input {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;     /* darker input background */
  color: var(--text);
}

/* Batch list container — scrollable grid */
.list {
  overflow: auto;
  padding: 8px;
  display: grid;
  gap: 8px;
}

/* === Batch List Items === */

/* Individual batch entry card */
.batch {
  padding: 12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  cursor: pointer;
  transition: border-color .2s, background .2s; /* smooth hover feedback */
}

/* Hover highlight for batches */
.batch:hover {
  border-color: #3a4150;
  background: #111821;
}

/* Active batch (currently selected) */
.batch.active {
  outline: 2px solid var(--accent);
  background: #101722;
}

/* Batch name — bolded */
.batch .name {
  font-weight: 600;
}

/* Batch metadata (date, OG/FG, etc.) */
.batch .meta {
  color: var(--muted);
  font-size: 12px;
  margin-top: 4px;
}

/* === Main Content Area === */

/* Main section layout: detail panel + footer */
.content {
  display: grid;
  grid-template-rows: 1fr auto; /* main area + footer */
  gap: 16px;
}

/* Detail panel that shows batch info */
.detail {
  padding: 16px;
  overflow: auto; /* allow scroll inside */
}

/* Detail title spacing */
.detail h2 {
  margin: 0 0 8px 0;
}

/* Generic grid utility for forms (12-column) */
.grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 12px;
}
.grid .col-6 { grid-column: span 6; }
.grid .col-12 { grid-column: span 12; }

/* === Fieldsets (section boxes) === */

.fieldset {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
}
.fieldset legend {
  padding: 0 6px;
  color: var(--muted);
}

/* === Form Controls === */

/* Label text for inputs */
label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}

/* Shared input / select / textarea appearance */
input[type="text"],
input[type="date"],
input[type="number"],
textarea,
select {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
}

/* Textareas can resize vertically but not horizontally */
textarea {
  resize: vertical;
  min-height: 80px;
}

/* === Buttons === */

button {
  appearance: none;
  border: 1px solid var(--border);
  background: #121923;
  color: var(--text);
  padding: 10px 14px;
  border-radius: 12px;
  cursor: pointer;
  transition: transform .04s ease, background .2s, border-color .2s;
  font-weight: 600;
}

/* Hover and active feedback */
button:hover {
  background: #182233;
  border-color: #304055;
}
button:active {
  transform: translateY(1px);
}

/* Accent (primary action) button */
.btn-accent {
  background: #0f2133;
  border-color: #21425d;
}

/* Danger (delete) button */
.btn-danger {
  background: #2a1416;
  border-color: #4e2326;
  color: #ffd6d6;
}

/* === Small UI Elements === */

/* Tag badges used in footer info */
.tag {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 9999px;
  border: 1px solid var(--border);
  color: var(--muted);
}

/* Footer layout — info left, buttons right */
.footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 8px;
  justify-content: space-between;
}

/* === Tables === */

.table {
  width: 100%;
  border-collapse: collapse;
}
.table th,
.table td {
  border-bottom: 1px solid var(--border);
  padding: 8px 6px;
  text-align: left;
  font-size: 14px;
}

/* Empty message placeholder */
.empty {
  color: var(--muted);
  font-style: italic;
  padding: 12px 0;
}

/* === Chart Canvas === */

canvas {
  width: 100%;
  height: 220px;
  background: #0c1218;
  border: 1px solid var(--border);
  border-radius: 12px;
}

/* === Responsive Adjustments === */

@media (max-width: 980px) {
  .app { grid-template-columns: 1fr; }     /* stack sidebar & content */
  .content { grid-template-rows: auto auto; }
}

/* === Compact delete button inside batch items === */
.batch .btn-danger {
  padding: 2px 6px;
  font-size: 12px;
  line-height: 1;
  border-radius: 8px;
}
.batch .btn-danger:hover {
  background: #2a1616;
  color: #ffb5b5;
}

/* === Meta info formatting === */
.meta {
  white-space: pre-line; /* preserve newlines from JS formatting */
}
.meta::first-line {
  font-weight: 500; /* emphasize the first line (often date or title) */
}
.meta:has(> span) {
  display: flex;
  flex-direction: column;
}

/* === Batch Name Hover === */
.batch .name:hover {
  text-decoration: underline;
  cursor: pointer;
}

/* === Collapsible fieldsets and row legends === */
.fieldset .row legend {
  font-weight: 600;
  color: var(--accent);
}
.fieldset .row:hover legend {
  color: var(--accent-2);
}
.fieldset .row span {
  transition: transform .2s ease;
}

/* Reusable row layout helper */
.row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 6px;
}

/* === Chart Tooltip === */
.chart-tooltip {
  position: absolute;
  pointer-events: none; /* allow hover to pass through */
  background: #0f141b;
  color: #e8edf5;
  border: 1px solid #2a2f39;
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  backdrop-filter: blur(4px);
  z-index: 10;
}

/* === Event Row Coloring === */
.table tr[data-type="bottled"] td { background: rgba(255,255,255,0.02); color: #b5e08a; }
.table tr[data-type="feeding"] td { background: rgba(255,200,0,0.04); color: #ffe680; }
.table tr[data-type="racked"] td { color: #b0c0ff; }
.table tr[data-type="note"] td textarea { background: #111822; color: #d8dee9; }

/* === Alternating Fieldset Backgrounds === */
.fieldset:nth-of-type(1) { background: rgba(255,255,255,0.02); }
.fieldset:nth-of-type(2) { background: rgba(255,255,255,0.01); }

/* === Scrollbar Styling === */
.list::-webkit-scrollbar,
.detail::-webkit-scrollbar {
  width: 8px;
}
.list::-webkit-scrollbar-thumb,
.detail::-webkit-scrollbar-thumb {
  background: #202833;
  border-radius: 6px;
}
.list::-webkit-scrollbar-thumb:hover,
.detail::-webkit-scrollbar-thumb:hover {
  background: #2e3a4b;
}

/* === Collapsible fieldset indicator icons === */
.fieldset.collapsible legend::after { content: " ▼"; }
.fieldset.collapsible.collapsed legend::after { content: " ▶"; }

/* === Ingredient Section Visual Tweaks === */
.fieldset legend {
  font-weight: 600;
  color: var(--accent);
}
.fieldset legend:hover {
  color: var(--accent-2);
}
.fieldset + .fieldset {
  margin-top: 14px;
  border-color: #252b34;
  background: rgba(255, 255, 255, 0.02);
  padding-top: 10px;
  padding-bottom: 10px;
}
.fieldset .grid .col-4 input,
.fieldset .grid .col-12 input {
  background: #0f141b;
  border: 1px solid var(--border);
  color: var(--text);
}
.fieldset label {
  margin-top: 4px;
  margin-bottom: 4px;
  display: block;
  color: var(--muted);
  font-size: 13px;
}
.fieldset:nth-of-type(n+2) {
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
  border-radius: 10px;
}

/* === Buttons (accent variant refined) === */
.btn-accent {
  background: var(--accent);
  border: none;
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s ease;
}
.btn-accent:hover {
  background: var(--accent-2);
}

/* === Print-only styling for Label Maker === */
@media print {
  /* Hide everything on the page by default when printing */
  body * { visibility: hidden; }

  /* Make only the label box (and its contents) visible */
  #labelBox, #labelBox * { visibility: visible; }

  /* Position the label box in the top-left corner of the printed page */
  #labelBox {
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
  }
}

/* Utility class used to hide elements in normal (screen) mode */
.hidden {
  display: none !important;
}
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar card">
      <header>
        <h1>Mead Tracker</h1>
        <button id="newBatchBtn" class="btn btn-accent">+ New</button>
      </header>
      <div class="search" style="padding: 12px;">
        <input id="searchInput" type="text" placeholder="Search batches… (name or notes)" />
      </div>
<div id="batchList" class="list">
  <!-- 🧪 Active & Archived batches render here dynamically -->

  <!-- === Cloud Sync Card === -->
  <div id="syncCard" class="fieldset collapsible collapsed" style="margin-top:16px;">
    <legend style="cursor:pointer;">☁️ Cloud Sync</legend>
    <div id="syncContent" style="margin-top:8px;">
      <p style="font-size:13px;color:var(--muted);">
        <b>ExtendsClass JSON Storage</b> (optional cloud backup)<br>
        • Make a free account at
        <a href="https://extendsclass.com/json-storage.html" target="_blank">
          extendsclass.com/json-storage
        </a><br>
        • Copy your <b>API key</b> from your account.<br>
        • Paste it below to enable cloud sync.
      </p>

      <input id="apiKeyInput" type="text"
             placeholder="Paste your ExtendsClass API key here"
             style="width:100%;margin:6px 0;padding:6px;
                    border-radius:8px;border:1px solid var(--border);
                    background:#0f141b;color:var(--text);">

      <button id="saveApiKeyBtn" class="btn-accent" style="width:100%;">
        Save API Key
      </button>
      <br><br>
      <button id="viewBinBtn" class="btn-accent" style="display:none;width:100%;">
        🔗 View Bin
      </button>

      <div id="syncStatus"
           style="margin-top:6px;color:var(--muted);font-size:13px;">
        💾 Local-only mode
      </div>

      <hr style="margin:10px 0;border:none;border-top:1px solid var(--border);">
      <div id="syncInfo" class="tag"
           style="display:block;word-break:break-all;">
        <b>Bin:</b> <span id="syncUrl">Local only</span>
      </div>
      <div class="tag" style="margin-top:4px;">
        <b>Key:</b> <span id="syncKey">meadtracker</span>
      </div>
    </div>
  </div>
</div>
</aside>
    </aside>

    <section class="content">
      <div id="detail" class="detail card"></div>
      <div class="footer card">
        <div class="row">
          <span class="tag">Local-only (saved to your browser)</span>
          <span class="tag">ABV uses (OG − FG) × 131.25</span>
        </div>
        <div class="row">
          <button id="exportBtn">Export</button>
          <input id="importFile" type="file" accept="application/json" style="display:none" />
          <button id="importBtn">Import</button>
          <button id="clearBtn" class="btn-danger">Clear All</button>
        </div>
      </div>
    </section>
  </div>

  <template id="batchItemTmpl">
    <div class="batch">
      <div class="name"></div>
      <div class="meta"></div>
    </div>
  </template>

  <script>
/* === Constants and Utility Functions === */

/* LocalStorage key used to persist app data */
const LS_KEY = 'mead-tracker:v2';

/* List of all standard event types available in the app */
const EVENTS = [
  'primary fermentation',
  'secondary fermentation',
  'racked',
  'feeding',
  'degassing',
  'conditioning',
  'cold crashing',
  'backsweetened',
  'bottled'
];

/* Shortcut helper for document.querySelector */
const $ = sel => document.querySelector(sel);

/**
 * Element creation utility
 * Simplifies DOM creation by allowing attributes and children in one call.
 *
 * Example:
 *   el('button', { class: 'btn', text: 'Save', onclick: handleSave })
 */
const el = (tag, attrs = {}, children = []) => {
  const n = document.createElement(tag);

  /* Apply all provided attributes */
  Object.entries(attrs).forEach(([k, v]) => {
    if (k === 'class') n.className = v;                            // set CSS class
    else if (k === 'text') n.textContent = v;                      // set text content
    else if (k.startsWith('on') && typeof v === 'function')        // add event listener (e.g., onclick)
      n.addEventListener(k.slice(2), v);
    else n.setAttribute(k, v);                                     // set generic attribute
  });

  /* Append any child elements or text nodes */
  children.forEach(c => n.append(c));

  return n;
};

/**
 * Format date values for display
 * @param {string|Date} d - A date string or Date object
 * @returns {string} - Localized date string (or empty if invalid)
 */
const fmt = (d) => d ? new Date(d).toLocaleDateString() : '';


/* === Application State Variables === */

// Current saved data (list of mead batches)
let state = { batches: [] }; // placeholder until loaded

// ID of the currently selected batch (or null if none selected)
let selectedId = state.batches[0]?.id || null;

// Current chart display mode: 'sg' = Specific Gravity, 'abv' = Alcohol by Volume
let chartMode = 'sg'; // default chart mode

// Collapsed state tracking for sidebar sections
let sidebarCollapse = { active: false, archived: false };

// === Core Persistence Helpers (local only) ===
function load() {
  try {
    const data = localStorage.getItem(LS_KEY);
    return data ? JSON.parse(data) : { batches: [] };
  } catch (err) {
    console.error('Failed to load local data', err);
    return { batches: [] };
  }
}

function save(state) {
  try {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  } catch (err) {
    console.error('Failed to save local data', err);
  }
}

/**
 * Render the entire UI
 * Calls both the sidebar (batch list) and the detail panel
 */
function render() {
  renderBatchList();
  renderDetail();
}

/**
 * Render the sidebar batch list
 * Divides batches into Active and Archived sections,
 * supports search filtering, inline renaming, and deletion.
 */
function renderBatchList() {
  const list = $('#batchList');
  if (!list) return;

  // 🧩 Save Cloud Sync card before clearing
  const syncCard = document.getElementById('syncCard');
  const hadSync = syncCard && list.contains(syncCard) ? syncCard : null;

  list.innerHTML = ''; // Clear previous list content (but keep reference above)

  /* --- Filter and sort batches --- */
  const q = $('#searchInput').value.trim().toLowerCase(); // search query (lowercase)

  // Sort newest → oldest, then filter by name or description
  const sorted = [...state.batches]
    .sort((a, b) => new Date(b.startDate) - new Date(a.startDate))
    .filter(
      b =>
        !q ||
        b.name.toLowerCase().includes(q) ||
        (b.description || '').toLowerCase().includes(q)
    );

  // Split batches into active vs archived (bottled)
  const active = sorted.filter(b => !b.events.some(e => e.type === 'bottled'));
  const archived = sorted.filter(b => b.events.some(e => e.type === 'bottled'));

  /**
   * Helper: create a collapsible section (Active / Archived)
   * @param {string} key - state key ('active' | 'archived')
   * @param {string} title - section title with emoji
   * @param {Array} batches - list of batch objects
   * @param {string} emptyText - placeholder if no entries
   */
  const makeSection = (key, title, batches, emptyText) => {
    const isCollapsed = sidebarCollapse[key];
    const section = el('div', { class: 'fieldset', style: 'margin-bottom:12px;' });

    /* --- Section header with collapse toggle --- */
    const header = el(
      'div',
      {
        class: 'row',
        style: `
          justify-content: space-between;
          align-items: center;
          cursor: pointer;
          user-select: none;
        `,
        onclick: () => {
          sidebarCollapse[key] = !sidebarCollapse[key]; // toggle state
          renderBatchList(); // re-render sidebar only
        }
      },
      [
        el('legend', { text: title }),
        el('span', {
          text: isCollapsed ? '▶' : '▼',
          style: 'font-size:14px; margin-left:4px;'
        })
      ]
    );
    section.append(header);

    // If collapsed, return header only
    if (isCollapsed) return section;

    // If no batches in this section, show placeholder
    if (!batches.length) {
      section.append(el('div', { class: 'empty', text: emptyText }));
      return section;
    }

    /* --- Render each batch item --- */
    batches.forEach(b => {
      const item = el('div', { class: 'batch' });

      /* --- Inline rename feature --- */
      const nameEl = (() => {
        const nameDiv = el('div', {
          class: 'name',
          text: b.name,
          title: 'Click to rename batch'
        });
        nameDiv.style.cursor = 'pointer';
        nameDiv.addEventListener('click', e => {
          e.stopPropagation();
          const input = el('input', {
            type: 'text',
            value: b.name,
            class: 'wide',
            style: `
              font-size:13px;
              font-weight:600;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              border-radius:6px;
              padding:4px 6px;
            `
          });

          const commit = () => {
            const newName = input.value.trim();
            if (newName) b.name = newName;
             saveAll(state, b, ["name"]);
            render();
          };
          input.addEventListener('blur', commit);
          input.addEventListener('keydown', ev => {
            if (ev.key === 'Enter') input.blur();
            if (ev.key === 'Escape') render(); // cancel rename
          });

          nameDiv.replaceWith(input);
          input.focus();
          input.select();
        });
        return nameDiv;
      })();

      /* --- Delete button --- */
      const delBtn = el('button', {
        text: '✕',
        class: 'btn-danger',
        title: 'Delete batch',
        onclick: e => {
          e.stopPropagation();
          if (!confirm(`Delete batch “${b.name}”? This cannot be undone.`)) return;
          const i = state.batches.indexOf(b);
          if (i >= 0) {
            state.batches.splice(i, 1);
            if (selectedId === b.id) selectedId = state.batches[0]?.id || null;
             saveAll(state);
            render();
          }
        }
      });

      const headerRow = el(
        'div',
        {
          class: 'row',
          style: 'justify-content: space-between; align-items: center;'
        },
        [nameEl, delBtn]
      );

      /* --- Metadata --- */
      const latestSG = b.sgReadings?.length
        ? b.sgReadings[b.sgReadings.length - 1].sg
        : null;
      const abv = calcABV(b.og, latestSG);

      const bottledEvent = b.events.find(e => e.type === 'bottled');
      const maturityText = bottledEvent
        ? `🧭 Mature: ${formatMaturityDays(bottledEvent.date)}`
        : '';

      const fermentText =
        !bottledEvent && b.startDate
          ? `🧪 ${formatFermentationDays(b.startDate)}`
          : '';

      // 1/3 Sugar Break
      let sugarBreakText = '';
      if (!bottledEvent && b.og) {
        const target = calcSugarBreak(b.og);
        if (target) sugarBreakText = `🍯 1/3 Sugar Break: ${target}`;
      }

      const metaText =
        `${fmt(b.startDate)} · OG ${b.og}` +
        (latestSG ? ` · FG ${latestSG}` : '') +
        (abv ? ` · ~${abv.toFixed(1)}% ABV` : '') +
        (fermentText ? `\n${fermentText}` : '') +
        (sugarBreakText ? `\n${sugarBreakText}` : '') +
        (maturityText ? `\n${maturityText}` : '');

      item.append(headerRow, el('div', { class: 'meta', text: metaText }));
      item.classList.toggle('active', b.id === selectedId);

      item.addEventListener('click', () => {
        selectedId = b.id;
        render();
      });

      section.append(item);
    });

    return section;
  };

  /* --- Render both main sections --- */
  list.append(makeSection('active', '🧪 Active Batches', active, 'No active batches.'));
  list.append(makeSection('archived', '🍾 Archived (Bottled)', archived, 'No bottled batches.'));

  // 🟢 Re-attach Cloud Sync card under Archived
  if (hadSync) {
    list.append(hadSync);
    hadSync.style.display = 'block';
  }
}


/**
 * Render the main batch detail view.
 * Displays selected batch info, metadata, chart, and related forms.
 * If no batch is selected, shows the "New Batch" creation form instead.
 */
function renderDetail() {
  const root = $('#detail'); // main detail panel container
  const batch = state.batches.find(b => b.id === selectedId); // currently selected batch

  /* --- Handle empty state (no batch selected) --- */
  if (!batch) {
    root.innerHTML = '';             // clear any previous content
    root.append(newBatchForm());     // show "Create New Batch" form
    return;
  }

  /* --- Batch detail view --- */
  root.innerHTML = ''; // clear existing content before re-render

  root.append(
    el('div', {}, [
      (() => {
        /* === TITLE ROW === */
        // Contains the editable batch name and the duplicate button
        const titleRow = el('div', {
          class: 'row',
          style: 'justify-content: space-between; align-items: center;'
        });

        /* --- Click-to-rename batch title --- */
        const title = el('h2', {
          text: batch.name,
          title: 'Click to rename batch'
        });
        title.style.cursor = 'pointer';
        title.addEventListener('click', () => {
          // Replace <h2> with an input for inline editing
          const input = el('input', {
            type: 'text',
            value: batch.name,
            class: 'wide',
            style: `
              font-size:20px;
              font-weight:700;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              border-radius:8px;
              padding:6px 10px;
            `
          });

          // Commit rename when leaving field or pressing Enter
          const commit = () => {
            const newName = input.value.trim();
            if (newName) batch.name = newName;
             saveAll(state, batch, ["name"]);
            render();
          };

          // Handle Enter (save) and Escape (cancel)
          input.addEventListener('blur', commit);
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') input.blur();  // save on Enter
            if (e.key === 'Escape') render();     // cancel on Escape
          });

          // Replace title element and focus input
          title.replaceWith(input);
          input.focus();
          input.select();
        });

        /* --- Duplicate batch button --- */
        const dupBtn = el('button', {
          text: '🔁 Duplicate',
          class: 'btn-accent',
          title: 'Duplicate this batch',
          style: 'padding:4px 10px; font-size:13px;',
          onclick: () => {
            // Confirm duplication
            if (!confirm(`Duplicate batch “${batch.name}”?`)) return;

            const today = new Date().toISOString().slice(0, 10);
            const id = crypto.randomUUID();

            // Create deep copy of the batch with reset progress
            const clone = {
              id,
              name: batch.name + ' (Copy)',              // suffix to indicate duplication
              startDate: today,                          // new start date
              og: batch.og,
              honey: batch.honey,
              yeast: batch.yeast,
              volume: batch.volume,
              description: batch.description,
              sgReadings: [],                            // clear gravity history
              events: [{ date: today, type: 'primary fermentation' }], // reset event timeline
              ingredients: JSON.parse(JSON.stringify(batch.ingredients || [])) // deep clone ingredients
            };

            // Add new batch to state and select it
            state.batches.push(clone);
            selectedId = id;
             saveAll(state);
            render();

            alert(`Batch “${batch.name}” duplicated as “${clone.name}”.`);
          }
        });

        // Append both elements to the header row
        titleRow.append(title, dupBtn);
		
				// --- Label Maker button ---
		const labelBtn = el('button', {
		  text: '🖨️ Label Maker',
		  class: 'btn-accent',
		  title: 'Generate a printable bottle label',
		  style: 'padding:4px 10px; font-size:13px;',
		  onclick: () => openLabelMaker(batch)
		});

		// Append both elements to the header row
		titleRow.append(title, dupBtn, labelBtn);
		return titleRow;
      })(),

      /* === METADATA AND SUMMARY === */
      // Basic start date and original gravity
(()=>{
  const sugarBreak = calcSugarBreak(batch.og);
  
    // ✅ Safely extract the most recent SG
  let currentSG = null;
  if (Array.isArray(batch.sgReadings) && batch.sgReadings.length > 0) {
    const last = batch.sgReadings[batch.sgReadings.length - 1];
    currentSG = typeof last === 'object' ? last.sg : last;
  }
  
  const abv = calcABV(batch.og, currentSG);
  
  // ✅ Debug: see what data we actually have
  console.log('Current SG reading for', batch.name, ':', currentSG, batch.sgReadings);
  
  const text = `Started ${fmt(batch.startDate)} · OG ${batch.og}` +
               (currentSG ? ` · SG ${currentSG}` : '') +
               (abv ? ` · ABV ${abv.toFixed(1)}%` : '') +
               (sugarBreak ? ` · 1/3 Break: ${sugarBreak}` : '');
  return el('div',{text});
})(),
      // Quick metadata summary line (honey, yeast, volume)
      el('div', {
        class: 'meta',
        text:
          `${batch.honey ? 'Honey: ' + batch.honey + ' · ' : ''}` +
          `${batch.yeast ? 'Yeast: ' + batch.yeast + ' · ' : ''}` +
          `${batch.volume ? 'Volume: ' + batch.volume + 'L' : ''}`
      }),

      /* === INTERACTIVE COMPONENTS === */
      // Order of components: Chart → SG Form → Event Form → Ingredients → Events Table
      chartCard(batch),        // Canvas for gravity/ABV chart
      sgFormCard(batch),       // Form to add new specific gravity reading
      eventFormCard(batch),    // Form to add general events or notes
      ingredientsTable(batch), // Ingredient list for the batch
      eventsTable(batch)       // Historical event log with edit/delete
    ])
  );

  /* === CHART RENDER === */
  // Draw the Specific Gravity / ABV chart for this batch
  drawChart(batch);
}

/**
 * Create the chart fieldset for displaying fermentation data.
 * Shows a graph of Specific Gravity (SG) or ABV (%) over time,
 * with a toggle button to switch between the two views.
 *
 * @param {Object} batch - The current batch object being displayed
 * @returns {HTMLElement} - A <fieldset> element containing the chart UI
 */
function chartCard(batch) {
  // Outer fieldset container for the chart section
  const card = el('fieldset', { class: 'fieldset' }, [

    // Section title (legend)
    el('legend', { text: 'Gravity & ABV over time' }),

    /* --- Header row with mode indicator and switch button --- */
    el('div', {
      class: 'row',
      style: 'justify-content: space-between; align-items: center; margin-bottom:8px;'
    }, [
      // Text label indicating current chart mode
      el('span', {
        text: chartMode === 'sg'
          ? 'Showing Specific Gravity'
          : 'Showing ABV (%)'
      }),

      // Button to toggle between SG and ABV chart views
      el('button', {
        text: chartMode === 'sg' ? 'Switch to ABV' : 'Switch to SG',
        class: 'btn-accent',
        style: 'padding:3px 10px; font-size:12px;',
        onclick: () => {
          // Flip mode and re-render full detail view to refresh chart
          chartMode = chartMode === 'sg' ? 'abv' : 'sg';
          render();
        }
      })
    ]),

    /* --- Chart canvas --- */
    // A fixed-size canvas where drawChart() will render the data line and points
    el('canvas', {
      id: 'sgChart',
      width: 800,   // logical drawing width
      height: 260,  // logical drawing height
      style: 'width:100%; max-width:800px; border-radius:8px;' // responsive fit
    })
  ]);

  // Return the completed fieldset element to be added to the DOM
  return card;
}

/**
 * Create a fieldset form for adding new Specific Gravity (SG) readings.
 * Each reading updates both the batch’s sgReadings array and event log.
 *
 * @param {Object} batch - The batch object to which the reading belongs
 * @returns {HTMLElement} - A <fieldset> element containing the SG input form
 */
function sgFormCard(batch) {
  // Outer container fieldset for this section
  const wrap = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Add Specific Gravity Reading' }),
  ]);

  /* --- Form inputs (two columns: date and SG value) --- */
  const form = el('div', { class: 'grid' }, [
    // Left column: Date picker
    el('div', { class: 'col-6' }, [
      el('label', { text: 'Date' }),
      el('input', {
        id: 'sgDate',
        type: 'date',
        value: new Date().toISOString().slice(0, 10), // prefill with today’s date
      }),
    ]),

    // Right column: SG numeric input
    el('div', { class: 'col-6' }, [
      el('label', { text: 'Specific Gravity (SG)' }),
      el('input', {
        id: 'sgValue',
        type: 'number',
        step: '0.001',
        min: '0.800',
        max: '1.500',
        placeholder: 'e.g., 1.045', // visual hint for typical range
      }),
    ]),
  ]);

  /* --- Add Reading Button --- */
  const btn = el('button', {
    class: 'btn-accent',
    text: 'Add Reading',
    style: 'margin-top:8px;',
    onclick: () => {
      // Read input values
      const date = form.querySelector('#sgDate').value;
      const sgNum = parseFloat(form.querySelector('#sgValue').value);

      // Basic input validation
      if (!date || !isFinite(sgNum))
        return alert('Please enter a valid date and SG value.');

      const sgStr = sgNum.toFixed(3); // normalize precision to 3 decimals
      const sgId = crypto.randomUUID(); // unique ID to link event & reading

      /* --- Update batch data --- */

      // ✅ Add new SG reading to batch
      batch.sgReadings.push({ id: sgId, date, sg: sgStr });

      // Ensure readings are in chronological order
      batch.sgReadings.sort((a, b) => new Date(a.date) - new Date(b.date));

      // ✅ Log this as a corresponding event (visible in Events table)
      batch.events.push({
        date,
        type: 'added sg reading',
        sg: sgStr,
        sgId, // keep link to reading entry for deletion syncing
        note: `SG: ${sgStr}`,
      });

      // Save updated state and re-render the app
       saveAll(state, batch, ["sgReadings", "events"]);
      render();
    },
  });

  // Combine form and button into the wrapper
  wrap.append(form, btn);
  return wrap;
}

/**
 * Create a fieldset form for adding general events or notes to a batch.
 * Supports predefined event types (fermentation stages, racking, etc.)
 * and a custom "note" type with free-text input.
 *
 * @param {Object} batch - The current batch to which the event will be added
 * @returns {HTMLElement} - A <fieldset> element containing the event form
 */
function eventFormCard(batch) {
  // Default date set to today (ISO format)
  const today = new Date().toISOString().slice(0, 10);

  // Create the fieldset wrapper for the event form
  const d = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Add Event' }),

    // --- Main grid container for inputs ---
    el('div', { class: 'grid' }, [

      /* === Date input === */
      el('div', { class: 'col-6' }, [
        el('label', { for: 'evDate', text: 'Date' }),
        el('input', { id: 'evDate', type: 'date', value: today })
      ]),

      /* === Event type selector === */
      el('div', { class: 'col-6' }, [
        el('label', { for: 'evType', text: 'Event' }),

        // Dropdown populated with all defined EVENTS + "note" type
        (() => {
          const sel = el('select', { id: 'evType' });
          [...EVENTS, 'note'].forEach(e =>
            sel.append(el('option', { value: e, text: e }))
          );
          return sel;
        })()
      ]),

      /* === Optional note field (hidden unless "note" is selected) === */
      el('div', { class: 'col-12', id: 'noteWrap', style: 'display:none;' }, [
        el('label', { for: 'evNote', text: 'Note text' }),
        el('textarea', {
          id: 'evNote',
          placeholder: 'Write a note about this batch...'
        })
      ]),

      /* === Add Event button === */
      el('div', { class: 'col-12' }, [
        el('button', {
          text: 'Add Event',
		  class:'btn-accent',
          onclick: () => {
            // Retrieve input values
            const date = d.querySelector('#evDate').value;
            const type = d.querySelector('#evType').value;
            const note = d.querySelector('#evNote')?.value.trim() || '';

            // Validation check
            if (!date || !type)
              return alert('Please choose a date and event.');

            // Build new event object
            const ev = { date, type };
            if (type === 'note' && note) ev.note = note;

            // Add event to current batch
            batch.events.push(ev);

            // Save changes and re-render detail view
             saveAll(state, batch, ["events"]);
            render();

            // Placeholder for potential "bottled" notification logic
            if (ev.type === 'bottled') {
              // alert(`Batch “${batch.name}” marked as bottled and moved to Archived.`);
            }
          }
        })
      ])
    ])
  ]);

  /* === Dynamic field visibility === */
  // Show or hide the "Note text" field based on selected event type
  const sel = d.querySelector('#evType');
  sel.addEventListener('change', () => {
    d.querySelector('#noteWrap').style.display =
      sel.value === 'note' ? 'block' : 'none';
  });

  // Return completed fieldset
  return d;
}

/**
 * Create a table displaying all events and notes for a batch.
 * Includes editable note fields, event deletion, and logic to
 * remove linked SG readings when their associated event is deleted.
 *
 * @param {Object} batch - The batch whose events should be displayed
 * @returns {HTMLElement} - A <fieldset> element containing the events table
 */
function eventsTable(batch) {
  // --- Outer container ---
  const wrap = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Events & Notes' }),
  ]);

  // --- Build table structure ---
  const table = el('table', { class: 'table' });

  // Header row
  const thead = el('thead', {}, [
    el('tr', {}, [
      el('th', { text: 'Date' }),
      el('th', { text: 'Event Type' }),
      el('th', { text: 'Note' }),
      el('th', { text: '' }), // column for delete button
    ]),
  ]);

  // Table body
  const tbody = el('tbody');

  /* === Populate rows === */
  batch.events
    .slice() // clone array so original isn’t modified
    .sort((a, b) => new Date(a.date) - new Date(b.date)) // sort chronologically
    .forEach((ev) => {
      const tr = el('tr');
      tr.dataset.type = ev.type; // used for CSS row coloring

      tr.append(
        // --- Date cell ---
        el('td', { text: fmt(ev.date) }),

        // --- Event Type cell ---
        el('td', { text: ev.type }),

        // --- Note or SG display cell ---
        (() => {
          const td = el('td');

          if (ev.type === 'note') {
            // Editable textarea for note-type events
            const input = el('textarea', {
              style: 'width:100%; min-height:30px;',
              value: ev.note || '',
              oninput: (e) => {
                ev.note = e.target.value; // live-update note in memory
                saveAll(state, batch, ["events"]); // patch only notes/events
              },
            });
            td.append(input);
          } else if (ev.type === 'added sg reading') {
            // --- Editable SG value on double-click ---
            const sgSpan = el('span', {
              text: `SG: ${ev.sg}`,
              title: 'Double-click to edit SG reading',
              style: 'cursor:pointer;'
            });

            sgSpan.addEventListener('dblclick', () => {
              const input = el('input', {
                type: 'number',
                step: '0.001',
                min: '0.800',
                max: '1.500',
                value: ev.sg,
                style: 'width:80px;'
              });

              // Commit edited value
              const commit = () => {
                const newVal = parseFloat(input.value);
                if (!isFinite(newVal)) return render();
                const sgStr = newVal.toFixed(3);
                ev.sg = sgStr;
                ev.note = `SG: ${sgStr}`;

                // --- Update linked sgReading entry (if exists) ---
                if (ev.sgId) {
                  const reading = batch.sgReadings.find(r => r.id === ev.sgId);
                  if (reading) reading.sg = sgStr;
                } else {
                  // fallback: match by date if no sgId
                  const reading = batch.sgReadings.find(r => r.date === ev.date);
                  if (reading) reading.sg = sgStr;
                }

                saveAll(state, batch, ["sgReadings", "events"]);
                render(); // refresh chart + summary
              };

              input.addEventListener('blur', commit);
              input.addEventListener('keydown', e => {
                if (e.key === 'Enter') input.blur();
                if (e.key === 'Escape') render();
              });

              sgSpan.replaceWith(input);
              input.focus();
              input.select();
            });

            td.append(sgSpan);
          } else {
            // Non-editable text for other event types
            td.textContent =
              ev.note ||
              (ev.sg ? `SG: ${ev.sg}` : '') ||
              ev.type;
          }

          return td;
        })(),

        // --- Delete button cell ---
        el('td', {}, [
          el('button', {
            text: '✕',
            class: 'btn-danger',
            title: 'Delete event',
            onclick: () => {
              // Remove event from batch
              const i = batch.events.indexOf(ev);
              if (i >= 0) {
                batch.events.splice(i, 1);

                /* === Linked SG Cleanup === */
                // If this event represented an SG reading, remove the matching entry
                if (ev.type === 'added sg reading') {
                  if (ev.sgId) {
                    // Case 1: event has direct sgId reference (preferred)
                    const ri = batch.sgReadings.findIndex(
                      (r) => r.id === ev.sgId
                    );
                    if (ri >= 0) batch.sgReadings.splice(ri, 1);
                  } else {
                    // Case 2: fallback heuristic (match by date + SG number)
                    const evSg =
                      ev.sg ||
                      (ev.note &&
                        ev.note.match(/([\d.]+)/)?.[1]); // extract SG from note text
                    const ri = batch.sgReadings.findIndex(
                      (r) =>
                        r.date === ev.date &&
                        Math.abs(
                          parseFloat(r.sg) - parseFloat(evSg)
                        ) < 0.00051 // tolerance for float rounding
                    );
                    if (ri >= 0) batch.sgReadings.splice(ri, 1);
                  }
                }

                // Save updated state and re-render UI
                saveAll(state, batch, ["sgReadings", "events"]);
                render();
              }
            },
          }),
        ])
      );

      // Append completed row to body
      tbody.append(tr);
    });

  // Assemble final table
  table.append(thead, tbody);
  wrap.append(table);

  return wrap;
}

/**
 * Create an editable table for managing the batch's ingredient list.
 * Allows live editing of honey, sugar, water, and additives,
 * as well as adding or removing ingredient rows dynamically.
 *
 * @param {Object} batch - The batch object whose ingredients are displayed
 * @returns {HTMLElement} - A <fieldset> element containing the editable table
 */
function ingredientsTable(batch) {
  // --- Outer wrapper fieldset with section title ---
  const wrap = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Ingredients' })
  ]);

  // Ensure ingredients array exists (backward compatibility)
  if (!batch.ingredients) batch.ingredients = [];

  // --- Build table structure ---
  const table = el('table', { class: 'table' });

  // Table header
  const thead = el('thead', {}, [
    el('tr', {}, [
      el('th', { text: 'Honey (kg)' }),
      el('th', { text: 'Sugar (kg)' }),
      el('th', { text: 'Water (L)' }),
      el('th', { text: 'Additives' }),
      el('th', { text: '' }) // column for delete button
    ])
  ]);

  // Table body
  const tbody = el('tbody');

  /* === Render each ingredient row === */
  batch.ingredients.forEach((ing) => {
    const tr = el('tr');

    // Each ingredient row has editable inputs for all four fields
    ['honey', 'sugar', 'water', 'additives'].forEach((key) => {
      const td = el('td');

      const input = el('input', {
        // Text field for "additives", numeric for others
        type: key === 'additives' ? 'text' : 'number',
        step: '0.1',                 // small increment for fine tuning
        value: ing[key] ?? '',       // populate from current ingredient data
        style: 'width:100%;',
        oninput: (e) => {
          // Live update the corresponding property in the ingredient object
          ing[key] = key === 'additives'
            ? e.target.value
            : parseFloat(e.target.value) || '';

          // Save immediately to localStorage
           saveAll(state, batch, ["ingredients"]);
        }
      });

      td.append(input);
      tr.append(td);
    });

    /* --- Delete button for ingredient row --- */
    tr.append(el('td', {}, [
      el('button', {
        text: '✕',
        class: 'btn-danger',
        title: 'Delete row',
        onclick: () => {
          // Remove this ingredient from the batch
          const i = batch.ingredients.indexOf(ing);
          if (i >= 0) batch.ingredients.splice(i, 1);
           saveAll(state, batch, ["ingredients"]);
          render(); // refresh display
        }
      })
    ]));

    // Add completed row to table body
    tbody.append(tr);
  });

  // Assemble table
  table.append(thead, tbody);

  /* --- "Add Ingredient" button --- */
  const addRowBtn = el('button', {
    text: '+ Add Ingredient',
    class: 'btn-accent',
    style: 'margin-top:8px;',
    onclick: () => {
      // Add a new blank row to the ingredients list
      batch.ingredients.push({
        honey: '',
        sugar: '',
        water: '',
        additives: ''
      });
       saveAll(state, batch, ["ingredients"]);
      render(); // refresh UI
    }
  });

  // Add both the table and add button to the fieldset
  wrap.append(table, addRowBtn);

  return wrap;
}

/**
 * Create a form for adding a new mead batch.
 * Captures basic batch info (name, OG, yeast, volume, etc.),
 * optional ingredients, and creates an initialized batch record
 * with a default "primary fermentation" event.
 *
 * @returns {HTMLElement} - A <fieldset> element containing the new batch form
 */
function newBatchForm() {
  // Default date is today (in yyyy-mm-dd format)
  const today = new Date().toISOString().slice(0, 10);

  // --- Main form wrapper ---
  const f = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Create New Batch' }),

    /* === Basic Info Section === */

    el('label', { text: 'Name' }),
    el('input', {
      id: 'bName',
      type: 'text',
      placeholder: 'e.g., Bochet #3' // Example batch name
    }),

    el('label', { text: 'Start Date' }),
    el('input', {
      id: 'bDate',
      type: 'date',
      value: today // Auto-fill with today’s date
    }),

    el('label', { text: 'Original Gravity (OG)' }),
    el('input', {
      id: 'bOG',
      type: 'number',
      step: '0.001',
      min: '0.900',
      max: '1.500',
      placeholder: '1.100',
      class: 'wide'
    }),

    /* === Metadata Section === */
    el('label', { text: 'Honey Type' }),
    el('input', {
      id: 'bHoney',
      type: 'text',
      placeholder: 'e.g., Wildflower, Clover, Orange Blossom'
    }),

    el('label', { text: 'Yeast Strain' }),
    el('input', {
      id: 'bYeast',
      type: 'text',
      placeholder: 'e.g., Lalvin D47, EC-1118'
    }),

    el('label', { text: 'Volume (L)' }),
    el('input', {
      id: 'bVolume',
      type: 'number',
      step: '0.1',
      min: '0.1',
      placeholder: 'e.g., 5.0',
      class: 'wide'
    }),

    /* === Optional Ingredients Section === */
    (() => {
      // Nested fieldset for ingredient details
      const ingSet = el('fieldset', {
        class: 'fieldset',
        style: 'margin-top:10px;'
      }, [
        el('legend', { text: 'Ingredients (optional)' }),
        el('div', { class: 'grid' }, [
          el('div', { class: 'col-4' }, [
            el('label', { text: 'Honey (kg)' }),
            el('input', {
              id: 'bHoneyWeight',
              type: 'number',
              step: '0.1',
              placeholder: 'e.g., 2.5'
            })
          ]),
          el('div', { class: 'col-4' }, [
            el('label', { text: 'Sugar (kg)' }),
            el('input', {
              id: 'bSugar',
              type: 'number',
              step: '0.1',
              placeholder: 'optional'
            })
          ]),
          el('div', { class: 'col-4' }, [
            el('label', { text: 'Water (L)' }),
            el('input', {
              id: 'bWater',
              type: 'number',
              step: '0.1',
              placeholder: 'e.g., 4.5'
            })
          ]),
          el('div', { class: 'col-12' }, [
            el('label', { text: 'Additives (fruit, spices)' }),
            el('input', {
              id: 'bAdditives',
              type: 'text',
              placeholder: 'e.g., orange peel, cinnamon, vanilla bean'
            })
          ])
        ])
      ]);
      return ingSet;
    })(),

    /* === Description Section === */
    el('label', { text: 'Description / Notes' }),
    el('textarea', { id: 'bDesc' }),

    /* === Create Batch Button === */
    el('button', {
      class: 'btn-accent',
      text: 'Create Batch',
      onclick: () => {
        // Retrieve user input values
        const name = f.querySelector('#bName').value.trim();
        const startDate = f.querySelector('#bDate').value;
        const og = parseFloat(f.querySelector('#bOG').value);
        const honey = f.querySelector('#bHoney').value.trim();
        const yeast = f.querySelector('#bYeast').value.trim();
        const volume = parseFloat(f.querySelector('#bVolume').value);
        const description = f.querySelector('#bDesc').value.trim();

        // Optional ingredients
        const honeyWeight = parseFloat(f.querySelector('#bHoneyWeight').value);
        const sugar = parseFloat(f.querySelector('#bSugar').value);
        const water = parseFloat(f.querySelector('#bWater').value);
        const additives = f.querySelector('#bAdditives').value.trim();

        // Basic validation
        if (!name || !startDate || !isFinite(og))
          return alert('Please fill name, date, and OG.');

        // Create unique ID for this batch
        const id = crypto.randomUUID();

        /* --- Construct batch object --- */
        const batch = {
          id,
          name,
          startDate,
          og: og.toFixed(3),
          honey,
          yeast,
          volume: isFinite(volume) ? volume.toFixed(1) : null,
          description,
          sgReadings: [],
          events: [{ date: startDate, type: 'primary fermentation' }],
          ingredients: []
        };

        /* --- Optional ingredients inclusion --- */
        // Only add if any ingredient field has data
        if (
          isFinite(honeyWeight) ||
          isFinite(sugar) ||
          isFinite(water) ||
          additives
        ) {
          batch.ingredients.push({
            honey: isFinite(honeyWeight) ? honeyWeight.toFixed(1) : '',
            sugar: isFinite(sugar) ? sugar.toFixed(1) : '',
            water: isFinite(water) ? water.toFixed(1) : '',
            additives
          });
        }

        /* --- Save and render --- */
        state.batches.push(batch);   // Add to state
        selectedId = id;             // Auto-select new batch
         saveAll(state);              // Persist to localStorage
        render();                    // Re-render UI
      }
    })
  ]);

  return f;
}

/* === Utility Functions === */

/**
 * Calculate the 1/3 sugar break gravity.
 * Formula: 1 + (OG - 1) / 3
 * Returns a 3-decimal formatted string.
 */
function calcSugarBreak(og) {
  const ogNum = parseFloat(og);
  if (!isFinite(ogNum) || ogNum < 0.9 || ogNum > 1.5) return null;
  const sgBreak = 1 + (ogNum - 1) / 3;
  return sgBreak.toFixed(3);
}

/**
 * Calculate Alcohol by Volume (ABV) based on original and final gravity.
 * Formula: (OG − FG) × 131.25
 * Returns null if either value is missing or invalid.
 */
function calcABV(og, fg) {
  if (!og || !fg) return null;
  const OG = parseFloat(og), FG = parseFloat(fg);
  if (!isFinite(OG) || !isFinite(FG)) return null;
  return (OG - FG) * 131.25;
}

/**
 * Format how long ago a batch was bottled, expressed as
 * days, weeks, or months (e.g., “3 weeks old”, “2 months 1 wk old”).
 */
function formatMaturityDays(bottledDate) {
  const days = Math.floor((Date.now() - new Date(bottledDate)) / 86400000);
  if (days < 0) return 'Just bottled';
  if (days < 7) return `${days} day${days !== 1 ? 's' : ''} old`;
  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `${weeks} week${weeks !== 1 ? 's' : ''} old`;
  const months = Math.floor(days / 30.44);
  const remDays = Math.floor(days - months * 30.44);
  return `${months} month${months !== 1 ? 's' : ''}${
    remDays > 7 ? ` ${Math.floor(remDays / 7)} wk` : ''
  } old`;
}

/**
 * Format fermentation duration since start date,
 * returning readable strings like “Fermenting for 3 days”
 * or “Fermenting for 2 months 1 wk”.
 */
function formatFermentationDays(startDate) {
  const days = Math.floor((Date.now() - new Date(startDate)) / 86400000);
  if (days < 1) return 'Started today';
  if (days === 1) return 'Fermenting for 1 day';
  if (days < 7) return `Fermenting for ${days} days`;
  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `Fermenting for ${weeks} week${weeks !== 1 ? 's' : ''}`;
  const months = Math.floor(days / 30.44);
  const remDays = Math.floor(days - months * 30.44);
  return `Fermenting for ${months} month${months !== 1 ? 's' : ''}${
    remDays > 7 ? ` ${Math.floor(remDays / 7)} wk` : ''
  }`;
}

/* === Chart Rendering === */

/**
 * Draw a line chart showing either Specific Gravity (SG)
 * or ABV (%) progression over time for the selected batch.
 */

function drawChart(batch) {
  const c = document.getElementById('sgChart');
  if (!c) return;
  const ctx = c.getContext('2d');
  const pad = { l: 45, r: 10, t: 10, b: 28 };

  // sort readings and include OG
  const readings = batch.sgReadings
    ? batch.sgReadings.slice().sort((a, b) => new Date(a.date) - new Date(b.date))
    : [];
  if (!readings.length || readings[0].date !== batch.startDate)
    readings.unshift({ date: batch.startDate, sg: batch.og });
  if (!readings.length) return;

  const points = readings.map(r => ({
    x: new Date(r.date).getTime(),
    y: chartMode === 'sg' ? parseFloat(r.sg) : calcABV(batch.og, r.sg),
    date: r.date,
    sg: parseFloat(r.sg)
  }));

  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  let minY = Math.min(...ys);
  let maxY = Math.max(...ys);

  // --- include sugar break in Y-range so it always shows ---
  const sugarBreak = calcSugarBreak(batch.og);
  if (sugarBreak) {
    if (chartMode === 'sg') {
      const sb = parseFloat(sugarBreak);
      if (sb < minY) minY = sb - 0.002;
      if (sb > maxY) maxY = sb + 0.002;
    } else {
      const sbAbv = calcABV(batch.og, sugarBreak);
      if (sbAbv < minY) minY = sbAbv - 0.2;
      if (sbAbv > maxY) maxY = sbAbv + 0.2;
    }
  }

  // small breathing room
  if (chartMode === 'sg') {
    minY = Math.max(0.98, minY - 0.005);
    maxY = Math.min(1.15, maxY + 0.005);
  } else {
    minY = Math.max(0, minY - 0.5);
    maxY += 0.5;
  }

  const W = c.width - pad.l - pad.r;
  const H = c.height - pad.t - pad.b;
  const xScale = v => pad.l + (W * (v - minX)) / Math.max(1, maxX - minX);
  const yScale = v => pad.t + H - (H * (v - minY)) / Math.max(0.0001, maxY - minY);

  points.forEach(p => {
    p.xx = xScale(p.x);
    p.yy = yScale(p.y);
  });

  // --- Tooltip element setup ---
  let tooltip = document.getElementById('chart-tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'chart-tooltip';
    tooltip.className = 'chart-tooltip';
    tooltip.style.display = 'none';
    c.parentElement.style.position = 'relative';
    c.parentElement.appendChild(tooltip);
  }

  const renderBase = (highlight = null) => {
    ctx.clearRect(0, 0, c.width, c.height);

    // Axes
    ctx.strokeStyle = '#2a3340';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + H);
    ctx.lineTo(pad.l + W, pad.t + H);
    ctx.stroke();

    // --- Y grid ---
    ctx.fillStyle = '#8fa3bd';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'right';
    const step = chartMode === 'sg' ? 0.005 : Math.max(0.5, (maxY - minY) / 8);
    for (let y = minY; y <= maxY; y += step) {
      const yy = yScale(y);
      ctx.fillText(chartMode === 'sg' ? y.toFixed(3) : y.toFixed(1), pad.l - 6, yy + 3);
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.beginPath();
      ctx.moveTo(pad.l, yy);
      ctx.lineTo(pad.l + W, yy);
      ctx.stroke();
    }

    // --- X ticks ---
    ctx.textAlign = 'center';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const x = minX + (i * (maxX - minX)) / ticks;
      const xx = xScale(x);
      ctx.fillText(new Date(x).toLocaleDateString(), xx, pad.t + H + 20);
    }

    // --- Data line ---
    ctx.strokeStyle = chartMode === 'sg' ? '#82cfff' : '#b5e08a';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    points.forEach((p, i) => (i ? ctx.lineTo(p.xx, p.yy) : ctx.moveTo(p.xx, p.yy)));
    ctx.stroke();

    // --- Sugar break line ---
    if (sugarBreak) {
      const breakValue =
        chartMode === 'sg'
          ? parseFloat(sugarBreak)
          : calcABV(batch.og, sugarBreak);

      if (breakValue >= minY && breakValue <= maxY) {
        const yBreak = yScale(breakValue);

        // check if reached
        const latestSG = batch.sgReadings?.length
          ? parseFloat(batch.sgReadings[batch.sgReadings.length - 1].sg)
          : null;
        const reached = latestSG && latestSG <= parseFloat(sugarBreak);

        ctx.save();
        ctx.beginPath();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.lineWidth = 1.2;
        ctx.moveTo(pad.l, yBreak);
        ctx.lineTo(pad.l + W, yBreak);
        ctx.stroke();
        ctx.setLineDash([]);

        // small dot at right edge
        ctx.fillStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.beginPath();
        ctx.arc(pad.l + W - 8, yBreak, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = '12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('1/3 Break', pad.l + 8, yBreak - 6);
        ctx.restore();
      }
    }

    // --- Data points ---
    points.forEach((p, i) => {
      ctx.beginPath();
      if (i === 0) {
        ctx.fillStyle = '#ffd966';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui';
        ctx.fillStyle = '#ccc';
        ctx.fillText('OG', p.xx + 12, p.yy + 4);
      } else {
        ctx.fillStyle = chartMode === 'sg' ? '#b5e08a' : '#82cfff';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    // --- Hover highlight ---
    if (highlight) {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.arc(highlight.xx, highlight.yy, 7, 0, Math.PI * 2);
      ctx.stroke();
    }
  };

  // initial draw
  renderBase();

  // hover handling
  const radius = 14;
  c.onmousemove = evt => {
    const rect = c.getBoundingClientRect();
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    const mx = (evt.clientX - rect.left) * scaleX;
    const my = (evt.clientY - rect.top) * scaleY;

    let nearest = null;
    let minDist = radius;
    for (const p of points) {
      const dx = Math.abs(p.xx - mx);
      const dy = Math.abs(p.yy - my);
      const dist = Math.sqrt(dx * dx + dy * dy * 0.6);
      if (dist < minDist) {
        nearest = p;
        minDist = dist;
      }
    }

    if (nearest) {
      renderBase(nearest);
      tooltip.style.display = 'block';
      const left = nearest.xx / (c.width / rect.width) + 15;
      const top = nearest.yy / (c.height / rect.height) - 10;
      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
      tooltip.innerHTML = `
        <div><b>${new Date(nearest.x).toLocaleDateString()}</b></div>
        <div>${chartMode === 'sg'
          ? `SG: ${nearest.sg.toFixed(3)}`
          : `ABV: ${nearest.y.toFixed(1)}%`}</div>
        ${sugarBreak ? '<div style="color:#ffaa33;">1/3 Break: ' + sugarBreak + '</div>' : ''}
      `;
    } else {
      tooltip.style.display = 'none';
      renderBase();
    }
  }; // ✅ ← closes c.onmousemove properly

  // Separate handler for leaving canvas
  c.onmouseleave = () => {
    tooltip.style.display = 'none';
    renderBase();
  };
}

/* === UI Event Listeners === */

// Create new batch
$('#newBatchBtn').addEventListener('click', () => {
  selectedId = null;
  render();
});

// Live search in sidebar
$('#searchInput').addEventListener('input', renderBatchList);

// Clear all data (reset localStorage)
$('#clearBtn').addEventListener('click', () => {
  if (!confirm('Delete ALL mead tracker data?')) return;
  state = { batches: [] };
  selectedId = null;
   saveAll(state);
  render();
});

// Export data as downloadable JSON file
$('#exportBtn').addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(state, null, 2)], {
    type: 'application/json'
  });
  const url = URL.createObjectURL(blob);
  const a = el('a', { href: url, download: 'mead-tracker-data.json' });
  document.body.append(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// Import data from JSON file
$('#importBtn').addEventListener('click', () => $('#importFile').click());
$('#importFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  const data = JSON.parse(text);
  state = data;
  selectedId = state.batches[0]?.id || null;
   saveAll(state);
  render();
});

function openLabelMaker(batch) {
  const modal = $('#labelModal');
  const preview = $('#labelPreview');
  modal.classList.remove('hidden');

  // Helper to safely inject text into HTML
  const escapeHTML = (s) => String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

  const date = batch.startDate ? new Date(batch.startDate).toLocaleDateString() : '';
  const lastReading = (batch.sgReadings && batch.sgReadings.length)
    ? batch.sgReadings[batch.sgReadings.length - 1]
    : null;

  const OG = parseFloat(batch.og);
  const FG = lastReading ? parseFloat(lastReading.sg) : NaN;
  const abv = (isFinite(OG) && isFinite(FG))
    ? ((OG - FG) * 131.25).toFixed(1) + '%'
    : '–';

  const honey = batch.honey || 'Mixed Blossom';

  preview.innerHTML = `
    <h1 style="text-align:center;font-size:20pt;margin:0;">${escapeHTML(batch.name)}</h1>
    <p style="text-align:center;margin:2mm 0;">${escapeHTML(honey)} Mead</p>
    <hr style="border:none;border-top:1px solid #8b6b2c;margin:2mm 0;">
    <p><b>Batch:</b> ${escapeHTML(batch.name)}</p>
    <p><b>Start:</b> ${escapeHTML(date)}</p>
    <p><b>ABV:</b> ${abv}</p>
  `;

  $('#printLabel').onclick = () => window.print();
  $('#closeLabel').onclick = () => modal.classList.add('hidden');
  modal.onclick = (e) => {
  if (e.target === modal) modal.classList.add('hidden');
};
}

// === Collapsible Cloud Sync card ===
const syncCard = document.getElementById("syncCard");
if (syncCard) {
  const legend = syncCard.querySelector("legend");
  const content = document.getElementById("syncContent");

  legend.addEventListener("click", () => {
    syncCard.classList.toggle("collapsed");
    const isCollapsed = syncCard.classList.contains("collapsed");
    content.style.display = isCollapsed ? "none" : "block";
  });

  // Start collapsed to match other sections
  syncCard.classList.add("collapsed");
  content.style.display = "none";
}

// === ExtendsClass JSON Storage Hybrid ===
let EXTENDS_BIN_ID = localStorage.getItem("EXTENDS_BIN_ID") || null;
let EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY") || "";
const EXTENDS_API = "https://json.extendsclass.com/bin";
const EXTENDS_KEY = "meadtracker";

function updateSyncCard() {
  const urlEl = document.getElementById("syncUrl");
  const keyEl = document.getElementById("syncKey");
  const keyInput = document.getElementById("apiKeyInput");
  const statusEl = document.getElementById("syncStatus");
  if (urlEl) {
    urlEl.textContent = EXTENDS_BIN_ID
      ? `${EXTENDS_API}/${EXTENDS_BIN_ID}`
      : "Local only (no cloud bin)";
  }
  if (keyEl) keyEl.textContent = EXTENDS_KEY;
  if (keyInput) keyInput.value = EXTENDS_API_KEY;
  if (statusEl)
    statusEl.textContent = EXTENDS_API_KEY
      ? "☁️ Cloud Sync Active"
      : "💾 Local-only mode";
}

/**
 * Create a new ExtendsClass bin when the user has provided a key.
 */

async function createBin() {
  try {
    console.log("Api-key:", `"${EXTENDS_API_KEY}"`);
    console.log("Security-key:", `"${EXTENDS_KEY}"`);

    const res = await fetch(EXTENDS_API, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Api-key": EXTENDS_API_KEY,     // your account API key
        "Security-key": EXTENDS_KEY,    // your chosen per-bin security key
        "Private": "true"               // optional, keeps the bin private
      },
      body: JSON.stringify({ batches: [] })
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    EXTENDS_BIN_ID = data.id;
    localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
updateViewBinButton();
updateSyncCard();
    alert(`✅ Created JSON bin:\n${EXTENDS_BIN_ID}`);
  } catch (err) {
    console.error("Failed to create bin:", err);
    alert("⚠️ Could not create JSON bin.");
  }
}

/**
 * Load from ExtendsClass if API key present; otherwise from local storage.
 */
async function cloudLoad() {
  if (!EXTENDS_BIN_ID || !EXTENDS_KEY) {
    console.log("☁️ No ExtendsClass credentials — using local data only.");
    return load();
  }

  try {
    const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
      headers: { "Security-key": EXTENDS_KEY }
    });

    if (res.status === 404) {
      console.log("☁️ No cloud data yet, starting fresh.");
      await cloudSave({ batches: [] });
      updateViewBinButton();
      return null;
    }

    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const raw = await res.json();
    updateViewBinButton();

    // 🧩 Normalize ExtendsClass format
    let data = null;

    if (raw.data) {
      // If data is stored as a JSON string, parse it
      try {
        data = typeof raw.data === "string" ? JSON.parse(raw.data) : raw.data;
      } catch (e) {
        console.warn("⚠️ Failed to parse nested data, using raw:", e);
        data = raw.data;
      }
    } else {
      // Fallback: older bins (no wrapper)
      data = raw;
    }

    if (data && Array.isArray(data.batches) && data.batches.length > 0) {
      console.log("☁️ Loaded cloud data successfully.");
      return data;
    } else {
      console.log("☁️ Cloud is empty — keeping local data.");
      return null;
    }
  } catch (err) {
    console.warn("⚠️ Cloud load failed, using local copy:", err);
    updateViewBinButton();
    return null;
  }
}



/**
 * Save to ExtendsClass if API key provided, always save local.
 */
/**
 * Save to ExtendsClass if API key provided, always save local.
 * Uses PATCH (merge) when possible instead of full PUT overwrite.
 */
async function cloudSave(payload, patchOnly = true) {
  try {
    // 🔧 Always start from full state
    let merged = structuredClone(state);

    // If payload is partial, merge it into the existing state before sending
    if (payload && payload.batches) {
      for (const patchBatch of payload.batches) {
        const idx = merged.batches.findIndex(b => b.id === patchBatch.id);
        if (idx !== -1) {
          Object.assign(merged.batches[idx], patchBatch);
        } else {
          // new batch
          merged.batches.push(patchBatch);
        }
      }
    }

    const method = patchOnly ? "PATCH" : "PUT";
    const headers = {
      "Content-Type": patchOnly
        ? "application/merge-patch+json"
        : "application/json",
      "Security-key": EXTENDS_KEY
    };

    const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
      method,
      headers,
      // ✅ send merged full dataset
      body: JSON.stringify({ data: merged })
    });

    if (!res.ok) {
      if (patchOnly && (res.status === 400 || res.status === 404)) {
        console.warn(`⚠️ PATCH failed (${res.status}), retrying full PUT`);
        return cloudSave(state, false);
      }
      throw new Error(`HTTP ${res.status}`);
    }

    console.log(`☁️ ${method} sync successful`);
    updateViewBinButton();
  } catch (err) {
    console.warn("⚠️ ExtendsClass sync failed", err);
    updateViewBinButton();
  }
}


window.addEventListener("beforeunload", () => cloudSave(state));

/**
 * Handle API-key input in the side panel.
 */
const saveApiKeyBtn = document.getElementById("saveApiKeyBtn");
if (saveApiKeyBtn) {
  saveApiKeyBtn.addEventListener("click", async () => {
    const keyInput = document.getElementById("apiKeyInput");
    const newKey = keyInput.value.trim();

    // 🧹 If the field is blank, clear all ExtendsClass info
    if (!newKey) {
      clearExtendsCredentials();
      EXTENDS_API_KEY = "";
      EXTENDS_BIN_ID = "";
      updateSyncCard();
      updateViewBinButton();
      console.log("💾 Cloud sync disabled — reverted to local-only mode.");
      alert("💾 Cloud sync disabled — now saving locally only.");
      return;
    }

    // Otherwise, save normally
    EXTENDS_API_KEY = newKey;
    localStorage.setItem("EXTENDS_API_KEY", EXTENDS_API_KEY);
    localStorage.setItem("EXTENDS_KEY", EXTENDS_KEY);

    console.log("🔑 ExtendsClass API key saved:", EXTENDS_API_KEY);

    // Create a new bin if one doesn’t exist yet
    if (!EXTENDS_BIN_ID) {
  // 🧩 Check if a bin already exists for this API key
  const existingBin = await getExistingBin();
  if (existingBin) {
    EXTENDS_BIN_ID = existingBin;
    localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
    console.log(`☁️ Using existing bin: ${EXTENDS_BIN_ID}`);
  } else {
    await createBin();
  }
}

    updateSyncCard();
    updateViewBinButton();
    alert("✅ API key saved — cloud sync enabled.");
  });
}

/**
 * Try to find an existing ExtendsClass bin for this API key.
 * Uses GET https://json.extendsclass.com/bins with header "Api-key".
 * Returns the first bin ID if found, or null if none.
 */
async function getExistingBin() {
  if (!EXTENDS_API_KEY) {
    console.log("⚠️ No ExtendsClass API key — skipping bin lookup.");
    return null;
  }

  try {
    const res = await fetch(`https://json.extendsclass.com/bins?nocache=${Date.now()}`, {
      headers: { "Api-key": EXTENDS_API_KEY },
      cache: "no-store"
    });

    console.log("Fetched /bins at", new Date().toISOString(), "status", res.status);

    if (res.status === 401) {
      console.warn("⚠️ Wrong API key — cannot fetch bins.");
      return null;
    }
    if (res.status === 429) {
      console.warn("⚠️ ExtendsClass rate limit exceeded — try again later.");
      return null;
    }
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const bins = await res.json();
    if (Array.isArray(bins) && bins.length > 0) {
      console.log(`☁️ Found existing bins: ${bins.join(", ")}`);
      // reuse the first bin
      return bins[0];
    }

    console.log("☁️ No existing bins found for this API key.");
    return null;
  } catch (err) {
    console.warn("⚠️ Could not fetch existing bins:", err);
    return null;
  }
}



function updateViewBinButton() {
  const btn = document.getElementById('viewBinBtn');
  if (!btn) return;

  if (EXTENDS_BIN_ID && EXTENDS_API_KEY) {
    btn.style.display = 'inline-block';
    btn.onclick = async () => {
      try {
        const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
          headers: { 'Security-key': EXTENDS_KEY }
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        // 🟢 open a pretty viewer window
        const popup = window.open('', '_blank', 'width=600,height=600');
        popup.document.write(
          `<pre style="font-family:monospace;white-space:pre-wrap;">${
            JSON.stringify(data, null, 2)
          }</pre>`
        );
        popup.document.title = 'ExtendsClass Bin Viewer';
      } catch (err) {
        alert('Failed to load bin: ' + err.message);
      }
    };
  } else {
    btn.style.display = 'none';
  }
}

async function saveAll(state, changedBatch = null, changedFields = null) {
  save(state); // always save local first

  // No cloud connection configured
  if (!EXTENDS_BIN_ID || !EXTENDS_KEY) {
    console.log("💾 Local-only save (no ExtendsClass key).");
    return;
  }

  // Build minimal patch payload if we know what changed
  let payload;
  if (changedBatch && Array.isArray(changedFields) && changedFields.length) {
    const partial = { batches: [] };
    const patch = { id: changedBatch.id };
    for (const f of changedFields) {
      // Copy only requested properties
      if (changedBatch[f] !== undefined)
        patch[f] = structuredClone(changedBatch[f]);
    }
    partial.batches.push(patch);
    payload = partial;
    console.log("☁️ Sending minimal PATCH:", partial);
  } else {
    payload = state;
    console.log("☁️ Sending full PATCH (no diff info).");
  }

  // Send to cloud
  await cloudSave(state, true);
}

function clearExtendsCredentials() {
  const keys = [
    "EXTENDS_BIN_ID",
    "EXTENDS_KEY",
    "EXTENDS_API_KEY"
  ];
  for (const k of keys) localStorage.removeItem(k);

  // 🧠 Mark that user intentionally disabled cloud sync
  localStorage.setItem("EXTENDS_MANUAL_DISABLE", "1");

  console.log("🧹 Cleared ExtendsClass credentials from localStorage.");
}


// === Migration: old Mead Tracker → new system ===
function migrateOldLocalData() {
  try {
    const oldKeyNames = [
      "mead-tracker:v1",
      "meadTrackerState",
      "batches",
      "meadTracker" // catch older keys
    ];

    // find first matching old key
    const foundKey = oldKeyNames.find((k) => localStorage.getItem(k));
    if (!foundKey) return false; // nothing to migrate

    const oldData = JSON.parse(localStorage.getItem(foundKey));
    if (!oldData || localStorage.getItem("MIGRATION_DONE")) return false;

    console.log(`🧩 Found old Mead Tracker data in '${foundKey}' → migrating...`);

    // Build new state format
    const newState = oldData.batches
      ? oldData
      : { batches: Array.isArray(oldData) ? oldData : [oldData] };

    // Save under new format
    save(newState);
    localStorage.setItem("MIGRATION_DONE", "true");

    // If user already has cloud enabled, push immediately
    if (EXTENDS_API_KEY && EXTENDS_BIN_ID) {
      cloudSave(newState).then(() =>
        console.log("☁️ Migrated data uploaded to cloud.")
      );
    }

    alert(
      "✅ Your old Mead Tracker data has been automatically migrated to the new version.\nAll batches are safe and backed up locally."
    );

    return true;
  } catch (err) {
    console.warn("Migration check failed:", err);
    return false;
  }
}


// === Startup ===
(async () => {
  // === detect if we have a valid ExtendsClass bin ===
  const hasValidBin =
    typeof EXTENDS_BIN_ID !== "undefined" &&
    EXTENDS_BIN_ID &&
    EXTENDS_BIN_ID.trim() !== "";

  // If no bin, politely remind the user once
  // Only show the local-only alert if the user hasn’t manually disabled cloud sync
const manuallyDisabled = localStorage.getItem("EXTENDS_MANUAL_DISABLE") === "1";
  
if (!hasValidBin && !manuallyDisabled && !localStorage.getItem("EXTENDS_NOTICE_SHOWN")) {
  alert(
    "💾 Mead Tracker is saving locally for now.\n\n" +
    "To enable free cloud backup, create an account at:\n" +
    "https://extendsclass.com/json-storage.html\n" +
    "and paste your API key into the Cloud Sync panel."
  );
  localStorage.setItem("EXTENDS_NOTICE_SHOWN", "true");
}

  // --- normal startup ---
  migrateOldLocalData();

  // Step 1: local render
  state = load();
  render();
  updateSyncCard();

  // Step 2: cloud logic only if bin exists
  if (hasValidBin) {
    try {
      const cloud = await cloudLoad();

      if (cloud && cloud.batches && cloud.batches.length > 0) {
        console.log("☁️ Loaded cloud data successfully.");
        console.log("☁️ Replacing local with cloud data.");
        state = cloud;
        save(state);
        render();
      } else if (state && state.batches && state.batches.length > 0) {
        console.log("☁️ Cloud empty — pushing local data up for the first time.");
        await cloudSave(state);
      } else {
        console.log("☁️ Cloud and local both empty — starting fresh.");
      }
    } catch (err) {
      console.warn("⚠️ Cloud load failed — using local copy:", err);
    }
  } else {
    console.log("💾 Loaded local data (no ExtendsClass bin configured).");
  }

  updateSyncCard();
})();








</script>
<!-- === Label Maker Modal === -->
<div id="labelModal" class="hidden" style="
  position:fixed; inset:0; background:rgba(0,0,0,0.6);
  display:flex; align-items:center; justify-content:center;
  z-index:1000;
">
  <div id="labelBox" style="
    background:#fefaf3; color:#333; border:2px solid #8b6b2c;
    border-radius:10px; padding:10mm; width:100mm; height:70mm;
    font-family:'Georgia',serif; position:relative;
  ">
    <div id="labelPreview"></div>
    <div style="position:absolute;bottom:6mm;right:6mm;font-size:9pt;font-style:italic;">
      Crafted with ♥ in Meadtrics
    </div>
  </div>
  <div style="position:absolute;bottom:20px;">
    <button id="printLabel" class="btn-accent">Print Label</button>
    <button id="closeLabel" class="btn-danger">Close</button>
  </div>
</div>
</body>
</html>