<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mead Tracker</title>
  <style>
:root {
  /* ==== Theme Variables ==== */
  /* Background color for the app (main page background) */
  --bg: #0f1216;
  /* Panel background color (cards, sidebars, etc.) */
  --panel: #161a20;
  /* Muted text color for secondary information */
  --muted: #aab2c0;
  /* Main text color for normal content */
  --text: #e8edf5;
  /* Primary accent color (used for highlights, buttons, and lines) */
  --accent: #82cfff;
  /* Secondary accent color (used for hover or complementary effects) */
  --accent-2: #b5e08a;
  /* Error or warning color (used for delete buttons, alerts, etc.) */
  --danger: #ff6b6b;
  /* Border color for panels, inputs, and dividers */
  --border: #2a2f39;
  /* Box shadow for raised UI elements (cards, modals, etc.) */
  --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  /* Default border radius for rounded corners */
  --radius: 14px;
}
	
/* Apply universal box-sizing to make layout calculations consistent */
* {
  box-sizing: border-box;
}

/* Ensure the document and body take up the full viewport height */
html, body {
  height: 100%;
}

/* Base body styles */
body {
  margin: 0; /* Remove default browser margin */
  
  /* Use a modern, system-based sans-serif font stack for readability */
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
    Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";

  /* Subtle radial gradient background, darker at center edges */
  background: radial-gradient(
    1200px 800px at 100% -10%,  /* Gradient size and position */
    #16202e 0,                 /* Lighter blue-gray center tone */
    #0f1216 50%                /* Dark background base tone */
  );

  /* Default text color for the entire page (from theme variable) */
  color: var(--text);
}

/* Style for all numeric input fields */
input[type="number"] {
  font-size: 16px; /* Slightly larger text for readability */
}

/* Wide variant of numeric inputs (used in forms where full width is desired) */
input[type="number"].wide {
  width: 100%;       /* Expand to fill available container width */
  min-width: 150px;  /* Prevent input from becoming too narrow */
}


/* Main application layout container */
/* Uses a two-column grid: sidebar (fixed width) + main content (flexible) */
.app {
  display: grid;                         /* establish grid layout */
  grid-template-columns: 320px 1fr;      /* sidebar = 320px, main content = remaining space */
  gap: 16px;                             /* space between columns */
  height: 100%;                          /* fill full viewport height */
  padding: 16px;                         /* outer spacing around the app */
}

/* === Layout & Card Structure === */

/* Shared card style used for panels and sections */
.card {
  background: var(--panel);                 /* panel background color */
  border: 1px solid var(--border);          /* subtle border outline */
  border-radius: var(--radius);             /* consistent rounded corners */
  box-shadow: var(--shadow);                /* soft depth shadow */
}

/* Sidebar container ‚Äî vertical layout for batch list and controls */
.sidebar {
  display: flex;
  flex-direction: column;
  overflow: hidden; /* prevent scrollbars on inner overflow */
}

/* Sidebar header ‚Äî title bar + New button */
.sidebar header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px; /* small gap between title and button */
}

/* Sidebar title text */
.sidebar header h1 {
  font-size: 18px;
  margin: 0;
}

/* Search bar container fills sidebar width */
.search {
  width: 100%;
}

/* Search input field styling */
.search input {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;     /* darker input background */
  color: var(--text);
}

/* Batch list container ‚Äî scrollable grid */
.list {
  overflow: auto;
  padding: 8px;
  display: grid;
  gap: 8px;
}

/* === Batch List Items === */

/* Individual batch entry card */
.batch {
  padding: 12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  cursor: pointer;
  transition: border-color .2s, background .2s; /* smooth hover feedback */
}

/* Hover highlight for batches */
.batch:hover {
  border-color: #3a4150;
  background: #111821;
}

/* Active batch (currently selected) */
.batch.active {
  outline: 2px solid var(--accent);
  background: #101722;
}

/* Batch name ‚Äî bolded */
.batch .name {
  font-weight: 600;
}

/* Batch metadata (date, OG/FG, etc.) */
.batch .meta {
  color: var(--muted);
  font-size: 12px;
  margin-top: 4px;
}

/* === Main Content Area === */

/* Main section layout: detail panel + footer */
.content {
  display: grid;
  grid-template-rows: 1fr auto; /* main area + footer */
  gap: 16px;
}

/* Detail panel that shows batch info */
.detail {
  padding: 16px;
  overflow: auto; /* allow scroll inside */
}

/* Detail title spacing */
.detail h2 {
  margin: 0 0 8px 0;
}

/* Generic grid utility for forms (12-column) */
.grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 12px;
}
.grid .col-6 { grid-column: span 6; }
.grid .col-12 { grid-column: span 12; }

/* === Fieldsets (section boxes) === */

.fieldset {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
}
.fieldset legend {
  padding: 0 6px;
  color: var(--muted);
}

/* === Form Controls === */

/* Label text for inputs */
label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}

/* Shared input / select / textarea appearance */
input[type="text"],
input[type="date"],
input[type="number"],
textarea,
select {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
}

/* Textareas can resize vertically but not horizontally */
textarea {
  resize: vertical;
  min-height: 80px;
}

/* === Buttons === */

button {
  appearance: none;
  border: 1px solid var(--border);
  background: #121923;
  color: var(--text);
  padding: 10px 14px;
  border-radius: 12px;
  cursor: pointer;
  transition: transform .04s ease, background .2s, border-color .2s;
  font-weight: 600;
}

/* Hover and active feedback */
button:hover {
  background: #182233;
  border-color: #304055;
}
button:active {
  transform: translateY(1px);
}

/* Accent (primary action) button */
.btn-accent {
  background: #0f2133;
  border-color: #21425d;
}

/* Danger (delete) button */
.btn-danger {
  background: #2a1416;
  border-color: #4e2326;
  color: #ffd6d6;
}

/* === Small UI Elements === */

/* Tag badges used in footer info */
.tag {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 9999px;
  border: 1px solid var(--border);
  color: var(--muted);
}

/* Footer layout ‚Äî info left, buttons right */
.footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 8px;
  justify-content: space-between;
}

/* === Tables === */

.table {
  width: 100%;
  border-collapse: collapse;
}
.table th,
.table td {
  border-bottom: 1px solid var(--border);
  padding: 8px 6px;
  text-align: left;
  font-size: 14px;
}

/* Empty message placeholder */
.empty {
  color: var(--muted);
  font-style: italic;
  padding: 12px 0;
}

/* === Chart Canvas === */

canvas {
  width: 100%;
  height: 220px;
  background: #0c1218;
  border: 1px solid var(--border);
  border-radius: 12px;
}

/* === Responsive Adjustments === */

@media (max-width: 980px) {
  .app { grid-template-columns: 1fr; }     /* stack sidebar & content */
  .content { grid-template-rows: auto auto; }
}

/* === Compact delete button inside batch items === */
.batch .btn-danger {
  padding: 2px 6px;
  font-size: 12px;
  line-height: 1;
  border-radius: 8px;
}
.batch .btn-danger:hover {
  background: #2a1616;
  color: #ffb5b5;
}

/* === Meta info formatting === */
.meta {
  white-space: pre-line; /* preserve newlines from JS formatting */
}
.meta::first-line {
  font-weight: 500; /* emphasize the first line (often date or title) */
}
.meta:has(> span) {
  display: flex;
  flex-direction: column;
}

/* === Batch Name Hover === */
.batch .name:hover {
  text-decoration: underline;
  cursor: pointer;
}

/* === Collapsible fieldsets and row legends === */
.fieldset .row legend {
  font-weight: 600;
  color: var(--accent);
}
.fieldset .row:hover legend {
  color: var(--accent-2);
}
.fieldset .row span {
  transition: transform .2s ease;
}

/* Reusable row layout helper */
.row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 6px;
}

/* === Chart Tooltip === */
.chart-tooltip {
  position: absolute;
  pointer-events: none; /* allow hover to pass through */
  background: #0f141b;
  color: #e8edf5;
  border: 1px solid #2a2f39;
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  backdrop-filter: blur(4px);
  z-index: 10;
}

/* === Event Row Coloring === */
.table tr[data-type="bottled"] td { background: rgba(255,255,255,0.02); color: #b5e08a; }
.table tr[data-type="feeding"] td { background: rgba(255,200,0,0.04); color: #ffe680; }
.table tr[data-type="racked"] td { color: #b0c0ff; }
.table tr[data-type="note"] td textarea { background: #111822; color: #d8dee9; }

/* === Alternating Fieldset Backgrounds === */
.fieldset:nth-of-type(1) { background: rgba(255,255,255,0.02); }
.fieldset:nth-of-type(2) { background: rgba(255,255,255,0.01); }

/* === Scrollbar Styling === */
.list::-webkit-scrollbar,
.detail::-webkit-scrollbar {
  width: 8px;
}
.list::-webkit-scrollbar-thumb,
.detail::-webkit-scrollbar-thumb {
  background: #202833;
  border-radius: 6px;
}
.list::-webkit-scrollbar-thumb:hover,
.detail::-webkit-scrollbar-thumb:hover {
  background: #2e3a4b;
}

/* === Collapsible fieldset indicator icons === */
.fieldset.collapsible legend::after { content: " ‚ñº"; }
.fieldset.collapsible.collapsed legend::after { content: " ‚ñ∂"; }

/* === Ingredient Section Visual Tweaks === */
.fieldset legend {
  font-weight: 600;
  color: var(--accent);
}
.fieldset legend:hover {
  color: var(--accent-2);
}
.fieldset + .fieldset {
  margin-top: 14px;
  border-color: #252b34;
  background: rgba(255, 255, 255, 0.02);
  padding-top: 10px;
  padding-bottom: 10px;
}
.fieldset .grid .col-4 input,
.fieldset .grid .col-12 input {
  background: #0f141b;
  border: 1px solid var(--border);
  color: var(--text);
}
.fieldset label {
  margin-top: 4px;
  margin-bottom: 4px;
  display: block;
  color: var(--muted);
  font-size: 13px;
}
.fieldset:nth-of-type(n+2) {
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
  border-radius: 10px;
}

/* === Buttons (accent variant refined) === */
.btn-accent {
  background: var(--accent);
  border: none;
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s ease;
}
.btn-accent:hover {
  background: var(--accent-2);
}

/* === Print-only styling for Label Maker === */
@media print {
  /* Hide everything on the page by default when printing */
  body * { visibility: hidden; }

  /* Make only the label box (and its contents) visible */
  #labelBox, #labelBox * { visibility: visible; }

  /* Position the label box in the top-left corner of the printed page */
  #labelBox {
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
  }
}

/* Utility class used to hide elements in normal (screen) mode */
.hidden {
  display: none !important;
}
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar card">
      <header>
        <h1>Mead Tracker</h1>
        <button id="newBatchBtn" class="btn btn-accent">+ New</button>
      </header>
      <div class="search" style="padding: 12px;">
        <input id="searchInput" type="text" placeholder="Search batches‚Ä¶ (name or notes)" />
      </div>
      <div id="batchList" class="list"></div>
	  <!-- === Cloud Sync Card === -->
<div id="syncCard" class="fieldset collapsible" style="margin:12px;">
  <legend style="cursor:pointer;">‚òÅÔ∏è Cloud Sync</legend>

<div id="syncContent">
  <p style="font-size:13px;color:var(--muted);">
    This Mead Tracker saves to a JSONSilo cloud bin.<br>
    Each bin is private ‚Äî keep your link safe.
  </p>
  <div id="syncInfo" class="tag" style="display:block;word-break:break-all;margin-top:6px;">
    <b>Bin:</b> <span id="syncUrl">Not assigned yet</span>
  </div>
  <div class="tag" style="margin-top:4px;">
    <b>Service:</b> <span id="syncKey">jsonsilo</span>
  </div>
</div>



</div>
</aside>
    </aside>

    <section class="content">
      <div id="detail" class="detail card"></div>
      <div class="footer card">
        <div class="row">
          <span class="tag">Local-only (saved to your browser)</span>
          <span class="tag">ABV uses (OG ‚àí FG) √ó 131.25</span>
        </div>
        <div class="row">
          <button id="exportBtn">Export</button>
          <input id="importFile" type="file" accept="application/json" style="display:none" />
          <button id="importBtn">Import</button>
          <button id="clearBtn" class="btn-danger">Clear All</button>
        </div>
      </div>
    </section>
  </div>

  <template id="batchItemTmpl">
    <div class="batch">
      <div class="name"></div>
      <div class="meta"></div>
    </div>
  </template>

  <script>
/* === Constants and Utility Functions === */

/* LocalStorage key used to persist app data */
const LS_KEY = 'mead-tracker:v1';

/* List of all standard event types available in the app */
const EVENTS = [
  'primary fermentation',
  'secondary fermentation',
  'racked',
  'feeding',
  'degassing',
  'conditioning',
  'cold crashing',
  'backsweetened',
  'bottled'
];

/* Shortcut helper for document.querySelector */
const $ = sel => document.querySelector(sel);

/**
 * Element creation utility
 * Simplifies DOM creation by allowing attributes and children in one call.
 *
 * Example:
 *   el('button', { class: 'btn', text: 'Save', onclick: handleSave })
 */
const el = (tag, attrs = {}, children = []) => {
  const n = document.createElement(tag);

  /* Apply all provided attributes */
  Object.entries(attrs).forEach(([k, v]) => {
    if (k === 'class') n.className = v;                            // set CSS class
    else if (k === 'text') n.textContent = v;                      // set text content
    else if (k.startsWith('on') && typeof v === 'function')        // add event listener (e.g., onclick)
      n.addEventListener(k.slice(2), v);
    else n.setAttribute(k, v);                                     // set generic attribute
  });

  /* Append any child elements or text nodes */
  children.forEach(c => n.append(c));

  return n;
};

/**
 * Format date values for display
 * @param {string|Date} d - A date string or Date object
 * @returns {string} - Localized date string (or empty if invalid)
 */
const fmt = (d) => d ? new Date(d).toLocaleDateString() : '';


/* === Application State Variables === */

// Current saved data (list of mead batches)
let state = { batches: [] }; // placeholder until loaded

// ID of the currently selected batch (or null if none selected)
let selectedId = state.batches[0]?.id || null;

// Current chart display mode: 'sg' = Specific Gravity, 'abv' = Alcohol by Volume
let chartMode = 'sg'; // default chart mode

// Collapsed state tracking for sidebar sections
let sidebarCollapse = { active: false, archived: false };

// === Core Persistence Helpers (local only) ===
function load() {
  try {
    const data = localStorage.getItem(LS_KEY);
    return data ? JSON.parse(data) : { batches: [] };
  } catch (err) {
    console.error('Failed to load local data', err);
    return { batches: [] };
  }
}

function save(state) {
  try {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  } catch (err) {
    console.error('Failed to save local data', err);
  }
}

/**
 * Render the entire UI
 * Calls both the sidebar (batch list) and the detail panel
 */
function render() {
  renderBatchList();
  renderDetail();
}

/**
 * Render the sidebar batch list
 * Divides batches into Active and Archived sections,
 * supports search filtering, inline renaming, and deletion.
 */
function renderBatchList() {
  const list = $('#batchList');
  list.innerHTML = ''; // Clear previous list content

  /* --- Filter and sort batches --- */

  const q = $('#searchInput').value.trim().toLowerCase(); // search query (lowercase)
  
  // Sort newest ‚Üí oldest, then filter by name or description
  const sorted = [...state.batches]
    .sort((a, b) => new Date(b.startDate) - new Date(a.startDate))
    .filter(
      b =>
        !q ||
        b.name.toLowerCase().includes(q) ||
        (b.description || '').toLowerCase().includes(q)
    );

  // Split batches into active vs archived (bottled)
  const active = sorted.filter(b => !b.events.some(e => e.type === 'bottled'));
  const archived = sorted.filter(b => b.events.some(e => e.type === 'bottled'));

  /**
   * Helper: create a collapsible section (Active / Archived)
   * @param {string} key - state key ('active' | 'archived')
   * @param {string} title - section title with emoji
   * @param {Array} batches - list of batch objects
   * @param {string} emptyText - placeholder if no entries
   */
  const makeSection = (key, title, batches, emptyText) => {
    const isCollapsed = sidebarCollapse[key];
    const section = el('div', { class: 'fieldset', style: 'margin-bottom:12px;' });

    /* --- Section header with collapse toggle --- */
    const header = el(
      'div',
      {
        class: 'row',
        style: `
          justify-content: space-between;
          align-items: center;
          cursor: pointer;
          user-select: none;
        `,
        onclick: () => {
          sidebarCollapse[key] = !sidebarCollapse[key]; // toggle state
          renderBatchList(); // re-render sidebar only
        }
      },
      [
        el('legend', { text: title }),
        el('span', {
          text: isCollapsed ? '‚ñ∂' : '‚ñº',
          style: 'font-size:14px; margin-left:4px;'
        })
      ]
    );
    section.append(header);

    // If collapsed, return header only
    if (isCollapsed) return section;

    // If no batches in this section, show placeholder
    if (!batches.length) {
      section.append(el('div', { class: 'empty', text: emptyText }));
      return section;
    }

    /* --- Render each batch item --- */
    batches.forEach(b => {
      const item = el('div', { class: 'batch' });

      /* --- Inline rename feature --- */
      const nameEl = (() => {
        const nameDiv = el('div', {
          class: 'name',
          text: b.name,
          title: 'Click to rename batch'
        });
        nameDiv.style.cursor = 'pointer';
        nameDiv.addEventListener('click', e => {
          e.stopPropagation();
          // Replace static name with input field
          const input = el('input', {
            type: 'text',
            value: b.name,
            class: 'wide',
            style: `
              font-size:13px;
              font-weight:600;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              border-radius:6px;
              padding:4px 6px;
            `
          });

          // Commit rename on blur or Enter
          const commit = () => {
            const newName = input.value.trim();
            if (newName) b.name = newName;
            save(state);
            render();
          };
          input.addEventListener('blur', commit);
          input.addEventListener('keydown', ev => {
            if (ev.key === 'Enter') input.blur();
            if (ev.key === 'Escape') render(); // cancel rename
          });

          // Swap element and focus
          nameDiv.replaceWith(input);
          input.focus();
          input.select();
        });
        return nameDiv;
      })();

      /* --- Delete button --- */
      const delBtn = el('button', {
        text: '‚úï',
        class: 'btn-danger',
        title: 'Delete batch',
        onclick: e => {
          e.stopPropagation();
          if (!confirm(`Delete batch ‚Äú${b.name}‚Äù? This cannot be undone.`)) return;
          const i = state.batches.indexOf(b);
          if (i >= 0) {
            state.batches.splice(i, 1); // remove from list
            // If deleted batch was selected, select next one if available
            if (selectedId === b.id) selectedId = state.batches[0]?.id || null;
            save(state);
            render();
          }
        }
      });

      // Header row for each batch (name + delete button)
      const headerRow = el(
        'div',
        {
          class: 'row',
          style: 'justify-content: space-between; align-items: center;'
        },
        [nameEl, delBtn]
      );

      /* --- Metadata formatting --- */
      const latestSG = b.sgReadings?.length
        ? b.sgReadings[b.sgReadings.length - 1].sg
        : null;
      const abv = calcABV(b.og, latestSG);

      // For archived batches: show maturity age
      const bottledEvent = b.events.find(e => e.type === 'bottled');
      const maturityText = bottledEvent
        ? `üß≠ Mature: ${formatMaturityDays(bottledEvent.date)}`
        : '';

      // For active batches: show fermentation duration
      const fermentText =
        !bottledEvent && b.startDate
          ? `üß™ ${formatFermentationDays(b.startDate)}`
          : '';

// 1/3 Sugar Break (only show for active batches)
let sugarBreakText = '';
if (!bottledEvent && b.og) {
  const target = calcSugarBreak(b.og);
  if (target) sugarBreakText = `üçØ 1/3 Sugar Break: ${target}`;
}

      // Build combined info string (dates, gravities, ABV, progress)
const metaText =
  `${fmt(b.startDate)} ¬∑ OG ${b.og}` +
  (latestSG ? ` ¬∑ FG ${latestSG}` : '') +
  (abv ? ` ¬∑ ~${abv.toFixed(1)}% ABV` : '') +
  (fermentText ? `\n${fermentText}` : '') +
  (sugarBreakText ? `\n${sugarBreakText}` : '') +
  (maturityText ? `\n${maturityText}` : '');

      // Assemble final item layout
      item.append(headerRow, el('div', { class: 'meta', text: metaText }));

      // Highlight currently selected batch
      item.classList.toggle('active', b.id === selectedId);

      // Clicking batch selects it and refreshes details
      item.addEventListener('click', () => {
        selectedId = b.id;
        render();
      });

      section.append(item);
    });

    return section;
  };

  /* --- Render both main sections --- */
  list.append(makeSection('active', 'üß™ Active Batches', active, 'No active batches.'));
  list.append(makeSection('archived', 'üçæ Archived (Bottled)', archived, 'No bottled batches.'));
}

/**
 * Render the main batch detail view.
 * Displays selected batch info, metadata, chart, and related forms.
 * If no batch is selected, shows the "New Batch" creation form instead.
 */
function renderDetail() {
  const root = $('#detail'); // main detail panel container
  const batch = state.batches.find(b => b.id === selectedId); // currently selected batch

  /* --- Handle empty state (no batch selected) --- */
  if (!batch) {
    root.innerHTML = '';             // clear any previous content
    root.append(newBatchForm());     // show "Create New Batch" form
    return;
  }

  /* --- Batch detail view --- */
  root.innerHTML = ''; // clear existing content before re-render

  root.append(
    el('div', {}, [
      (() => {
        /* === TITLE ROW === */
        // Contains the editable batch name and the duplicate button
        const titleRow = el('div', {
          class: 'row',
          style: 'justify-content: space-between; align-items: center;'
        });

        /* --- Click-to-rename batch title --- */
        const title = el('h2', {
          text: batch.name,
          title: 'Click to rename batch'
        });
        title.style.cursor = 'pointer';
        title.addEventListener('click', () => {
          // Replace <h2> with an input for inline editing
          const input = el('input', {
            type: 'text',
            value: batch.name,
            class: 'wide',
            style: `
              font-size:20px;
              font-weight:700;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              border-radius:8px;
              padding:6px 10px;
            `
          });

          // Commit rename when leaving field or pressing Enter
          const commit = () => {
            const newName = input.value.trim();
            if (newName) batch.name = newName;
            save(state);
            render();
          };

          // Handle Enter (save) and Escape (cancel)
          input.addEventListener('blur', commit);
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') input.blur();  // save on Enter
            if (e.key === 'Escape') render();     // cancel on Escape
          });

          // Replace title element and focus input
          title.replaceWith(input);
          input.focus();
          input.select();
        });

        /* --- Duplicate batch button --- */
        const dupBtn = el('button', {
          text: 'üîÅ Duplicate',
          class: 'btn-accent',
          title: 'Duplicate this batch',
          style: 'padding:4px 10px; font-size:13px;',
          onclick: () => {
            // Confirm duplication
            if (!confirm(`Duplicate batch ‚Äú${batch.name}‚Äù?`)) return;

            const today = new Date().toISOString().slice(0, 10);
            const id = crypto.randomUUID();

            // Create deep copy of the batch with reset progress
            const clone = {
              id,
              name: batch.name + ' (Copy)',              // suffix to indicate duplication
              startDate: today,                          // new start date
              og: batch.og,
              honey: batch.honey,
              yeast: batch.yeast,
              volume: batch.volume,
              description: batch.description,
              sgReadings: [],                            // clear gravity history
              events: [{ date: today, type: 'primary fermentation' }], // reset event timeline
              ingredients: JSON.parse(JSON.stringify(batch.ingredients || [])) // deep clone ingredients
            };

            // Add new batch to state and select it
            state.batches.push(clone);
            selectedId = id;
            save(state);
            render();

            alert(`Batch ‚Äú${batch.name}‚Äù duplicated as ‚Äú${clone.name}‚Äù.`);
          }
        });

        // Append both elements to the header row
        titleRow.append(title, dupBtn);
		
				// --- Label Maker button ---
		const labelBtn = el('button', {
		  text: 'üñ®Ô∏è Label Maker',
		  class: 'btn-accent',
		  title: 'Generate a printable bottle label',
		  style: 'padding:4px 10px; font-size:13px;',
		  onclick: () => openLabelMaker(batch)
		});

		// Append both elements to the header row
		titleRow.append(title, dupBtn, labelBtn);
		return titleRow;
      })(),

      /* === METADATA AND SUMMARY === */
      // Basic start date and original gravity
(()=>{
  const sugarBreak = calcSugarBreak(batch.og);
  
    // ‚úÖ Safely extract the most recent SG
  let currentSG = null;
  if (Array.isArray(batch.sgReadings) && batch.sgReadings.length > 0) {
    const last = batch.sgReadings[batch.sgReadings.length - 1];
    currentSG = typeof last === 'object' ? last.sg : last;
  }
  
  const abv = calcABV(batch.og, currentSG);
  
  // ‚úÖ Debug: see what data we actually have
  console.log('Current SG reading for', batch.name, ':', currentSG, batch.sgReadings);
  
  const text = `Started ${fmt(batch.startDate)} ¬∑ OG ${batch.og}` +
               (currentSG ? ` ¬∑ SG ${currentSG}` : '') +
               (abv ? ` ¬∑ ABV ${abv.toFixed(1)}%` : '') +
               (sugarBreak ? ` ¬∑ 1/3 Break: ${sugarBreak}` : '');
  return el('div',{text});
})(),
      // Quick metadata summary line (honey, yeast, volume)
      el('div', {
        class: 'meta',
        text:
          `${batch.honey ? 'Honey: ' + batch.honey + ' ¬∑ ' : ''}` +
          `${batch.yeast ? 'Yeast: ' + batch.yeast + ' ¬∑ ' : ''}` +
          `${batch.volume ? 'Volume: ' + batch.volume + 'L' : ''}`
      }),

      /* === INTERACTIVE COMPONENTS === */
      // Order of components: Chart ‚Üí SG Form ‚Üí Event Form ‚Üí Ingredients ‚Üí Events Table
      chartCard(batch),        // Canvas for gravity/ABV chart
      sgFormCard(batch),       // Form to add new specific gravity reading
      eventFormCard(batch),    // Form to add general events or notes
      ingredientsTable(batch), // Ingredient list for the batch
      eventsTable(batch)       // Historical event log with edit/delete
    ])
  );

  /* === CHART RENDER === */
  // Draw the Specific Gravity / ABV chart for this batch
  drawChart(batch);
}

/**
 * Create the chart fieldset for displaying fermentation data.
 * Shows a graph of Specific Gravity (SG) or ABV (%) over time,
 * with a toggle button to switch between the two views.
 *
 * @param {Object} batch - The current batch object being displayed
 * @returns {HTMLElement} - A <fieldset> element containing the chart UI
 */
function chartCard(batch) {
  // Outer fieldset container for the chart section
  const card = el('fieldset', { class: 'fieldset' }, [

    // Section title (legend)
    el('legend', { text: 'Gravity & ABV over time' }),

    /* --- Header row with mode indicator and switch button --- */
    el('div', {
      class: 'row',
      style: 'justify-content: space-between; align-items: center; margin-bottom:8px;'
    }, [
      // Text label indicating current chart mode
      el('span', {
        text: chartMode === 'sg'
          ? 'Showing Specific Gravity'
          : 'Showing ABV (%)'
      }),

      // Button to toggle between SG and ABV chart views
      el('button', {
        text: chartMode === 'sg' ? 'Switch to ABV' : 'Switch to SG',
        class: 'btn-accent',
        style: 'padding:3px 10px; font-size:12px;',
        onclick: () => {
          // Flip mode and re-render full detail view to refresh chart
          chartMode = chartMode === 'sg' ? 'abv' : 'sg';
          render();
        }
      })
    ]),

    /* --- Chart canvas --- */
    // A fixed-size canvas where drawChart() will render the data line and points
    el('canvas', {
      id: 'sgChart',
      width: 800,   // logical drawing width
      height: 260,  // logical drawing height
      style: 'width:100%; max-width:800px; border-radius:8px;' // responsive fit
    })
  ]);

  // Return the completed fieldset element to be added to the DOM
  return card;
}

/**
 * Create a fieldset form for adding new Specific Gravity (SG) readings.
 * Each reading updates both the batch‚Äôs sgReadings array and event log.
 *
 * @param {Object} batch - The batch object to which the reading belongs
 * @returns {HTMLElement} - A <fieldset> element containing the SG input form
 */
function sgFormCard(batch) {
  // Outer container fieldset for this section
  const wrap = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Add Specific Gravity Reading' }),
  ]);

  /* --- Form inputs (two columns: date and SG value) --- */
  const form = el('div', { class: 'grid' }, [
    // Left column: Date picker
    el('div', { class: 'col-6' }, [
      el('label', { text: 'Date' }),
      el('input', {
        id: 'sgDate',
        type: 'date',
        value: new Date().toISOString().slice(0, 10), // prefill with today‚Äôs date
      }),
    ]),

    // Right column: SG numeric input
    el('div', { class: 'col-6' }, [
      el('label', { text: 'Specific Gravity (SG)' }),
      el('input', {
        id: 'sgValue',
        type: 'number',
        step: '0.001',
        min: '0.800',
        max: '1.500',
        placeholder: 'e.g., 1.045', // visual hint for typical range
      }),
    ]),
  ]);

  /* --- Add Reading Button --- */
  const btn = el('button', {
    class: 'btn-accent',
    text: 'Add Reading',
    style: 'margin-top:8px;',
    onclick: () => {
      // Read input values
      const date = form.querySelector('#sgDate').value;
      const sgNum = parseFloat(form.querySelector('#sgValue').value);

      // Basic input validation
      if (!date || !isFinite(sgNum))
        return alert('Please enter a valid date and SG value.');

      const sgStr = sgNum.toFixed(3); // normalize precision to 3 decimals
      const sgId = crypto.randomUUID(); // unique ID to link event & reading

      /* --- Update batch data --- */

      // ‚úÖ Add new SG reading to batch
      batch.sgReadings.push({ id: sgId, date, sg: sgStr });

      // Ensure readings are in chronological order
      batch.sgReadings.sort((a, b) => new Date(a.date) - new Date(b.date));

      // ‚úÖ Log this as a corresponding event (visible in Events table)
      batch.events.push({
        date,
        type: 'added sg reading',
        sg: sgStr,
        sgId, // keep link to reading entry for deletion syncing
        note: `SG: ${sgStr}`,
      });

      // Save updated state and re-render the app
      save(state);
      render();
    },
  });

  // Combine form and button into the wrapper
  wrap.append(form, btn);
  return wrap;
}

/**
 * Create a fieldset form for adding general events or notes to a batch.
 * Supports predefined event types (fermentation stages, racking, etc.)
 * and a custom "note" type with free-text input.
 *
 * @param {Object} batch - The current batch to which the event will be added
 * @returns {HTMLElement} - A <fieldset> element containing the event form
 */
function eventFormCard(batch) {
  // Default date set to today (ISO format)
  const today = new Date().toISOString().slice(0, 10);

  // Create the fieldset wrapper for the event form
  const d = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Add Event' }),

    // --- Main grid container for inputs ---
    el('div', { class: 'grid' }, [

      /* === Date input === */
      el('div', { class: 'col-6' }, [
        el('label', { for: 'evDate', text: 'Date' }),
        el('input', { id: 'evDate', type: 'date', value: today })
      ]),

      /* === Event type selector === */
      el('div', { class: 'col-6' }, [
        el('label', { for: 'evType', text: 'Event' }),

        // Dropdown populated with all defined EVENTS + "note" type
        (() => {
          const sel = el('select', { id: 'evType' });
          [...EVENTS, 'note'].forEach(e =>
            sel.append(el('option', { value: e, text: e }))
          );
          return sel;
        })()
      ]),

      /* === Optional note field (hidden unless "note" is selected) === */
      el('div', { class: 'col-12', id: 'noteWrap', style: 'display:none;' }, [
        el('label', { for: 'evNote', text: 'Note text' }),
        el('textarea', {
          id: 'evNote',
          placeholder: 'Write a note about this batch...'
        })
      ]),

      /* === Add Event button === */
      el('div', { class: 'col-12' }, [
        el('button', {
          text: 'Add Event',
		  class:'btn-accent',
          onclick: () => {
            // Retrieve input values
            const date = d.querySelector('#evDate').value;
            const type = d.querySelector('#evType').value;
            const note = d.querySelector('#evNote')?.value.trim() || '';

            // Validation check
            if (!date || !type)
              return alert('Please choose a date and event.');

            // Build new event object
            const ev = { date, type };
            if (type === 'note' && note) ev.note = note;

            // Add event to current batch
            batch.events.push(ev);

            // Save changes and re-render detail view
            save(state);
            render();

            // Placeholder for potential "bottled" notification logic
            if (ev.type === 'bottled') {
              // alert(`Batch ‚Äú${batch.name}‚Äù marked as bottled and moved to Archived.`);
            }
          }
        })
      ])
    ])
  ]);

  /* === Dynamic field visibility === */
  // Show or hide the "Note text" field based on selected event type
  const sel = d.querySelector('#evType');
  sel.addEventListener('change', () => {
    d.querySelector('#noteWrap').style.display =
      sel.value === 'note' ? 'block' : 'none';
  });

  // Return completed fieldset
  return d;
}

/**
 * Create a table displaying all events and notes for a batch.
 * Includes editable note fields, event deletion, and logic to
 * remove linked SG readings when their associated event is deleted.
 *
 * @param {Object} batch - The batch whose events should be displayed
 * @returns {HTMLElement} - A <fieldset> element containing the events table
 */
function eventsTable(batch) {
  // --- Outer container ---
  const wrap = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Events & Notes' }),
  ]);

  // --- Build table structure ---
  const table = el('table', { class: 'table' });

  // Header row
  const thead = el('thead', {}, [
    el('tr', {}, [
      el('th', { text: 'Date' }),
      el('th', { text: 'Event Type' }),
      el('th', { text: 'Note' }),
      el('th', { text: '' }), // column for delete button
    ]),
  ]);

  // Table body
  const tbody = el('tbody');

  /* === Populate rows === */
  batch.events
    .slice() // clone array so original isn‚Äôt modified
    .sort((a, b) => new Date(a.date) - new Date(b.date)) // sort chronologically
    .forEach((ev) => {
      const tr = el('tr');
      tr.dataset.type = ev.type; // used for CSS row coloring

      tr.append(
        // --- Date cell ---
        el('td', { text: fmt(ev.date) }),

        // --- Event Type cell ---
        el('td', { text: ev.type }),

        // --- Note or SG display cell ---
        (() => {
          const td = el('td');

          if (ev.type === 'note') {
            // Editable textarea for note-type events
            const input = el('textarea', {
              style: 'width:100%; min-height:30px;',
              value: ev.note || '',
              oninput: (e) => {
                ev.note = e.target.value; // live-update note in memory
                save(state);              // persist immediately
              },
            });
            td.append(input);
          } else if (ev.type === 'added sg reading') {
  // --- Editable SG value on double-click ---
  const sgSpan = el('span', {
    text: `SG: ${ev.sg}`,
    title: 'Double-click to edit SG reading',
    style: 'cursor:pointer;'
  });

  sgSpan.addEventListener('dblclick', () => {
    const input = el('input', {
      type: 'number',
      step: '0.001',
      min: '0.800',
      max: '1.500',
      value: ev.sg,
      style: 'width:80px;'
    });

    // Commit edited value
    const commit = () => {
      const newVal = parseFloat(input.value);
      if (!isFinite(newVal)) return render();
      const sgStr = newVal.toFixed(3);
      ev.sg = sgStr;
      ev.note = `SG: ${sgStr}`;

      // --- Update linked sgReading entry (if exists) ---
      if (ev.sgId) {
        const reading = batch.sgReadings.find(r => r.id === ev.sgId);
        if (reading) reading.sg = sgStr;
      } else {
        // fallback: match by date if no sgId
        const reading = batch.sgReadings.find(r => r.date === ev.date);
        if (reading) reading.sg = sgStr;
      }

      save(state);
      render(); // refresh chart + summary
    };

    input.addEventListener('blur', commit);
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') input.blur();
      if (e.key === 'Escape') render();
    });

    sgSpan.replaceWith(input);
    input.focus();
    input.select();
  });

  td.append(sgSpan);
} else {
  // Non-editable text for other event types
  td.textContent =
    ev.note ||
    (ev.sg ? `SG: ${ev.sg}` : '') ||
    ev.type;
}

          return td;
        })(),

        // --- Delete button cell ---
        el('td', {}, [
          el('button', {
            text: '‚úï',
            class: 'btn-danger',
            title: 'Delete event',
            onclick: () => {
              // Remove event from batch
              const i = batch.events.indexOf(ev);
              if (i >= 0) {
                batch.events.splice(i, 1);

                /* === Linked SG Cleanup === */
                // If this event represented an SG reading, remove the matching entry
                if (ev.type === 'added sg reading') {
                  if (ev.sgId) {
                    // Case 1: event has direct sgId reference (preferred)
                    const ri = batch.sgReadings.findIndex(
                      (r) => r.id === ev.sgId
                    );
                    if (ri >= 0) batch.sgReadings.splice(ri, 1);
                  } else {
                    // Case 2: fallback heuristic (match by date + SG number)
                    const evSg =
                      ev.sg ||
                      (ev.note &&
                        ev.note.match(/([\d.]+)/)?.[1]); // extract SG from note text
                    const ri = batch.sgReadings.findIndex(
                      (r) =>
                        r.date === ev.date &&
                        Math.abs(
                          parseFloat(r.sg) - parseFloat(evSg)
                        ) < 0.00051 // tolerance for float rounding
                    );
                    if (ri >= 0) batch.sgReadings.splice(ri, 1);
                  }
                }

                // Save updated state and re-render UI
                save(state);
                render();
              }
            },
          }),
        ])
      );

      // Append completed row to body
      tbody.append(tr);
    });

  // Assemble final table
  table.append(thead, tbody);
  wrap.append(table);

  return wrap;
}

/**
 * Create an editable table for managing the batch's ingredient list.
 * Allows live editing of honey, sugar, water, and additives,
 * as well as adding or removing ingredient rows dynamically.
 *
 * @param {Object} batch - The batch object whose ingredients are displayed
 * @returns {HTMLElement} - A <fieldset> element containing the editable table
 */
function ingredientsTable(batch) {
  // --- Outer wrapper fieldset with section title ---
  const wrap = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Ingredients' })
  ]);

  // Ensure ingredients array exists (backward compatibility)
  if (!batch.ingredients) batch.ingredients = [];

  // --- Build table structure ---
  const table = el('table', { class: 'table' });

  // Table header
  const thead = el('thead', {}, [
    el('tr', {}, [
      el('th', { text: 'Honey (kg)' }),
      el('th', { text: 'Sugar (kg)' }),
      el('th', { text: 'Water (L)' }),
      el('th', { text: 'Additives' }),
      el('th', { text: '' }) // column for delete button
    ])
  ]);

  // Table body
  const tbody = el('tbody');

  /* === Render each ingredient row === */
  batch.ingredients.forEach((ing) => {
    const tr = el('tr');

    // Each ingredient row has editable inputs for all four fields
    ['honey', 'sugar', 'water', 'additives'].forEach((key) => {
      const td = el('td');

      const input = el('input', {
        // Text field for "additives", numeric for others
        type: key === 'additives' ? 'text' : 'number',
        step: '0.1',                 // small increment for fine tuning
        value: ing[key] ?? '',       // populate from current ingredient data
        style: 'width:100%;',
        oninput: (e) => {
          // Live update the corresponding property in the ingredient object
          ing[key] = key === 'additives'
            ? e.target.value
            : parseFloat(e.target.value) || '';

          // Save immediately to localStorage
          save(state);
        }
      });

      td.append(input);
      tr.append(td);
    });

    /* --- Delete button for ingredient row --- */
    tr.append(el('td', {}, [
      el('button', {
        text: '‚úï',
        class: 'btn-danger',
        title: 'Delete row',
        onclick: () => {
          // Remove this ingredient from the batch
          const i = batch.ingredients.indexOf(ing);
          if (i >= 0) batch.ingredients.splice(i, 1);
          save(state);
          render(); // refresh display
        }
      })
    ]));

    // Add completed row to table body
    tbody.append(tr);
  });

  // Assemble table
  table.append(thead, tbody);

  /* --- "Add Ingredient" button --- */
  const addRowBtn = el('button', {
    text: '+ Add Ingredient',
    class: 'btn-accent',
    style: 'margin-top:8px;',
    onclick: () => {
      // Add a new blank row to the ingredients list
      batch.ingredients.push({
        honey: '',
        sugar: '',
        water: '',
        additives: ''
      });
      save(state);
      render(); // refresh UI
    }
  });

  // Add both the table and add button to the fieldset
  wrap.append(table, addRowBtn);

  return wrap;
}

/**
 * Create a form for adding a new mead batch.
 * Captures basic batch info (name, OG, yeast, volume, etc.),
 * optional ingredients, and creates an initialized batch record
 * with a default "primary fermentation" event.
 *
 * @returns {HTMLElement} - A <fieldset> element containing the new batch form
 */
function newBatchForm() {
  // Default date is today (in yyyy-mm-dd format)
  const today = new Date().toISOString().slice(0, 10);

  // --- Main form wrapper ---
  const f = el('fieldset', { class: 'fieldset' }, [
    el('legend', { text: 'Create New Batch' }),

    /* === Basic Info Section === */

    el('label', { text: 'Name' }),
    el('input', {
      id: 'bName',
      type: 'text',
      placeholder: 'e.g., Bochet #3' // Example batch name
    }),

    el('label', { text: 'Start Date' }),
    el('input', {
      id: 'bDate',
      type: 'date',
      value: today // Auto-fill with today‚Äôs date
    }),

    el('label', { text: 'Original Gravity (OG)' }),
    el('input', {
      id: 'bOG',
      type: 'number',
      step: '0.001',
      min: '0.900',
      max: '1.500',
      placeholder: '1.100',
      class: 'wide'
    }),

    /* === Metadata Section === */
    el('label', { text: 'Honey Type' }),
    el('input', {
      id: 'bHoney',
      type: 'text',
      placeholder: 'e.g., Wildflower, Clover, Orange Blossom'
    }),

    el('label', { text: 'Yeast Strain' }),
    el('input', {
      id: 'bYeast',
      type: 'text',
      placeholder: 'e.g., Lalvin D47, EC-1118'
    }),

    el('label', { text: 'Volume (L)' }),
    el('input', {
      id: 'bVolume',
      type: 'number',
      step: '0.1',
      min: '0.1',
      placeholder: 'e.g., 5.0',
      class: 'wide'
    }),

    /* === Optional Ingredients Section === */
    (() => {
      // Nested fieldset for ingredient details
      const ingSet = el('fieldset', {
        class: 'fieldset',
        style: 'margin-top:10px;'
      }, [
        el('legend', { text: 'Ingredients (optional)' }),
        el('div', { class: 'grid' }, [
          el('div', { class: 'col-4' }, [
            el('label', { text: 'Honey (kg)' }),
            el('input', {
              id: 'bHoneyWeight',
              type: 'number',
              step: '0.1',
              placeholder: 'e.g., 2.5'
            })
          ]),
          el('div', { class: 'col-4' }, [
            el('label', { text: 'Sugar (kg)' }),
            el('input', {
              id: 'bSugar',
              type: 'number',
              step: '0.1',
              placeholder: 'optional'
            })
          ]),
          el('div', { class: 'col-4' }, [
            el('label', { text: 'Water (L)' }),
            el('input', {
              id: 'bWater',
              type: 'number',
              step: '0.1',
              placeholder: 'e.g., 4.5'
            })
          ]),
          el('div', { class: 'col-12' }, [
            el('label', { text: 'Additives (fruit, spices)' }),
            el('input', {
              id: 'bAdditives',
              type: 'text',
              placeholder: 'e.g., orange peel, cinnamon, vanilla bean'
            })
          ])
        ])
      ]);
      return ingSet;
    })(),

    /* === Description Section === */
    el('label', { text: 'Description / Notes' }),
    el('textarea', { id: 'bDesc' }),

    /* === Create Batch Button === */
    el('button', {
      class: 'btn-accent',
      text: 'Create Batch',
      onclick: () => {
        // Retrieve user input values
        const name = f.querySelector('#bName').value.trim();
        const startDate = f.querySelector('#bDate').value;
        const og = parseFloat(f.querySelector('#bOG').value);
        const honey = f.querySelector('#bHoney').value.trim();
        const yeast = f.querySelector('#bYeast').value.trim();
        const volume = parseFloat(f.querySelector('#bVolume').value);
        const description = f.querySelector('#bDesc').value.trim();

        // Optional ingredients
        const honeyWeight = parseFloat(f.querySelector('#bHoneyWeight').value);
        const sugar = parseFloat(f.querySelector('#bSugar').value);
        const water = parseFloat(f.querySelector('#bWater').value);
        const additives = f.querySelector('#bAdditives').value.trim();

        // Basic validation
        if (!name || !startDate || !isFinite(og))
          return alert('Please fill name, date, and OG.');

        // Create unique ID for this batch
        const id = crypto.randomUUID();

        /* --- Construct batch object --- */
        const batch = {
          id,
          name,
          startDate,
          og: og.toFixed(3),
          honey,
          yeast,
          volume: isFinite(volume) ? volume.toFixed(1) : null,
          description,
          sgReadings: [],
          events: [{ date: startDate, type: 'primary fermentation' }],
          ingredients: []
        };

        /* --- Optional ingredients inclusion --- */
        // Only add if any ingredient field has data
        if (
          isFinite(honeyWeight) ||
          isFinite(sugar) ||
          isFinite(water) ||
          additives
        ) {
          batch.ingredients.push({
            honey: isFinite(honeyWeight) ? honeyWeight.toFixed(1) : '',
            sugar: isFinite(sugar) ? sugar.toFixed(1) : '',
            water: isFinite(water) ? water.toFixed(1) : '',
            additives
          });
        }

        /* --- Save and render --- */
        state.batches.push(batch);   // Add to state
        selectedId = id;             // Auto-select new batch
        save(state);                 // Persist to localStorage
        render();                    // Re-render UI
      }
    })
  ]);

  return f;
}

/* === Utility Functions === */

/**
 * Calculate the 1/3 sugar break gravity.
 * Formula: 1 + (OG - 1) / 3
 * Returns a 3-decimal formatted string.
 */
function calcSugarBreak(og) {
  const ogNum = parseFloat(og);
  if (!isFinite(ogNum) || ogNum < 0.9 || ogNum > 1.5) return null;
  const sgBreak = 1 + (ogNum - 1) / 3;
  return sgBreak.toFixed(3);
}

/**
 * Calculate Alcohol by Volume (ABV) based on original and final gravity.
 * Formula: (OG ‚àí FG) √ó 131.25
 * Returns null if either value is missing or invalid.
 */
function calcABV(og, fg) {
  if (!og || !fg) return null;
  const OG = parseFloat(og), FG = parseFloat(fg);
  if (!isFinite(OG) || !isFinite(FG)) return null;
  return (OG - FG) * 131.25;
}

/**
 * Format how long ago a batch was bottled, expressed as
 * days, weeks, or months (e.g., ‚Äú3 weeks old‚Äù, ‚Äú2 months 1 wk old‚Äù).
 */
function formatMaturityDays(bottledDate) {
  const days = Math.floor((Date.now() - new Date(bottledDate)) / 86400000);
  if (days < 0) return 'Just bottled';
  if (days < 7) return `${days} day${days !== 1 ? 's' : ''} old`;
  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `${weeks} week${weeks !== 1 ? 's' : ''} old`;
  const months = Math.floor(days / 30.44);
  const remDays = Math.floor(days - months * 30.44);
  return `${months} month${months !== 1 ? 's' : ''}${
    remDays > 7 ? ` ${Math.floor(remDays / 7)} wk` : ''
  } old`;
}

/**
 * Format fermentation duration since start date,
 * returning readable strings like ‚ÄúFermenting for 3 days‚Äù
 * or ‚ÄúFermenting for 2 months 1 wk‚Äù.
 */
function formatFermentationDays(startDate) {
  const days = Math.floor((Date.now() - new Date(startDate)) / 86400000);
  if (days < 1) return 'Started today';
  if (days === 1) return 'Fermenting for 1 day';
  if (days < 7) return `Fermenting for ${days} days`;
  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `Fermenting for ${weeks} week${weeks !== 1 ? 's' : ''}`;
  const months = Math.floor(days / 30.44);
  const remDays = Math.floor(days - months * 30.44);
  return `Fermenting for ${months} month${months !== 1 ? 's' : ''}${
    remDays > 7 ? ` ${Math.floor(remDays / 7)} wk` : ''
  }`;
}

/* === Chart Rendering === */

/**
 * Draw a line chart showing either Specific Gravity (SG)
 * or ABV (%) progression over time for the selected batch.
 */

function drawChart(batch) {
  const c = document.getElementById('sgChart');
  if (!c) return;
  const ctx = c.getContext('2d');
  const pad = { l: 45, r: 10, t: 10, b: 28 };

  // sort readings and include OG
  const readings = batch.sgReadings
    ? batch.sgReadings.slice().sort((a, b) => new Date(a.date) - new Date(b.date))
    : [];
  if (!readings.length || readings[0].date !== batch.startDate)
    readings.unshift({ date: batch.startDate, sg: batch.og });
  if (!readings.length) return;

  const points = readings.map(r => ({
    x: new Date(r.date).getTime(),
    y: chartMode === 'sg' ? parseFloat(r.sg) : calcABV(batch.og, r.sg),
    date: r.date,
    sg: parseFloat(r.sg)
  }));

  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  let minY = Math.min(...ys);
  let maxY = Math.max(...ys);

  // --- include sugar break in Y-range so it always shows ---
  const sugarBreak = calcSugarBreak(batch.og);
  if (sugarBreak) {
    if (chartMode === 'sg') {
      const sb = parseFloat(sugarBreak);
      if (sb < minY) minY = sb - 0.002;
      if (sb > maxY) maxY = sb + 0.002;
    } else {
      const sbAbv = calcABV(batch.og, sugarBreak);
      if (sbAbv < minY) minY = sbAbv - 0.2;
      if (sbAbv > maxY) maxY = sbAbv + 0.2;
    }
  }

  // small breathing room
  if (chartMode === 'sg') {
    minY = Math.max(0.98, minY - 0.005);
    maxY = Math.min(1.15, maxY + 0.005);
  } else {
    minY = Math.max(0, minY - 0.5);
    maxY += 0.5;
  }

  const W = c.width - pad.l - pad.r;
  const H = c.height - pad.t - pad.b;
  const xScale = v => pad.l + (W * (v - minX)) / Math.max(1, maxX - minX);
  const yScale = v => pad.t + H - (H * (v - minY)) / Math.max(0.0001, maxY - minY);

  points.forEach(p => {
    p.xx = xScale(p.x);
    p.yy = yScale(p.y);
  });

  // --- Tooltip element setup ---
  let tooltip = document.getElementById('chart-tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'chart-tooltip';
    tooltip.className = 'chart-tooltip';
    tooltip.style.display = 'none';
    c.parentElement.style.position = 'relative';
    c.parentElement.appendChild(tooltip);
  }

  const renderBase = (highlight = null) => {
    ctx.clearRect(0, 0, c.width, c.height);

    // Axes
    ctx.strokeStyle = '#2a3340';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + H);
    ctx.lineTo(pad.l + W, pad.t + H);
    ctx.stroke();

    // --- Y grid ---
    ctx.fillStyle = '#8fa3bd';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'right';
    const step = chartMode === 'sg' ? 0.005 : Math.max(0.5, (maxY - minY) / 8);
    for (let y = minY; y <= maxY; y += step) {
      const yy = yScale(y);
      ctx.fillText(chartMode === 'sg' ? y.toFixed(3) : y.toFixed(1), pad.l - 6, yy + 3);
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.beginPath();
      ctx.moveTo(pad.l, yy);
      ctx.lineTo(pad.l + W, yy);
      ctx.stroke();
    }

    // --- X ticks ---
    ctx.textAlign = 'center';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const x = minX + (i * (maxX - minX)) / ticks;
      const xx = xScale(x);
      ctx.fillText(new Date(x).toLocaleDateString(), xx, pad.t + H + 20);
    }

    // --- Data line ---
    ctx.strokeStyle = chartMode === 'sg' ? '#82cfff' : '#b5e08a';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    points.forEach((p, i) => (i ? ctx.lineTo(p.xx, p.yy) : ctx.moveTo(p.xx, p.yy)));
    ctx.stroke();

    // --- Sugar break line ---
    if (sugarBreak) {
      const breakValue =
        chartMode === 'sg'
          ? parseFloat(sugarBreak)
          : calcABV(batch.og, sugarBreak);

      if (breakValue >= minY && breakValue <= maxY) {
        const yBreak = yScale(breakValue);

        // check if reached
        const latestSG = batch.sgReadings?.length
          ? parseFloat(batch.sgReadings[batch.sgReadings.length - 1].sg)
          : null;
        const reached = latestSG && latestSG <= parseFloat(sugarBreak);

        ctx.save();
        ctx.beginPath();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.lineWidth = 1.2;
        ctx.moveTo(pad.l, yBreak);
        ctx.lineTo(pad.l + W, yBreak);
        ctx.stroke();
        ctx.setLineDash([]);

        // small dot at right edge
        ctx.fillStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.beginPath();
        ctx.arc(pad.l + W - 8, yBreak, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = '12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('1/3 Break', pad.l + 8, yBreak - 6);
        ctx.restore();
      }
    }

    // --- Data points ---
    points.forEach((p, i) => {
      ctx.beginPath();
      if (i === 0) {
        ctx.fillStyle = '#ffd966';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui';
        ctx.fillStyle = '#ccc';
        ctx.fillText('OG', p.xx + 12, p.yy + 4);
      } else {
        ctx.fillStyle = chartMode === 'sg' ? '#b5e08a' : '#82cfff';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    // --- Hover highlight ---
    if (highlight) {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.arc(highlight.xx, highlight.yy, 7, 0, Math.PI * 2);
      ctx.stroke();
    }
  };

  // initial draw
  renderBase();

  // hover handling
  const radius = 14;
  c.onmousemove = evt => {
    const rect = c.getBoundingClientRect();
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    const mx = (evt.clientX - rect.left) * scaleX;
    const my = (evt.clientY - rect.top) * scaleY;

    let nearest = null;
    let minDist = radius;
    for (const p of points) {
      const dx = Math.abs(p.xx - mx);
      const dy = Math.abs(p.yy - my);
      const dist = Math.sqrt(dx * dx + dy * dy * 0.6);
      if (dist < minDist) {
        nearest = p;
        minDist = dist;
      }
    }

    if (nearest) {
      renderBase(nearest);
      tooltip.style.display = 'block';
      const left = nearest.xx / (c.width / rect.width) + 15;
      const top = nearest.yy / (c.height / rect.height) - 10;
      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
      tooltip.innerHTML = `
        <div><b>${new Date(nearest.x).toLocaleDateString()}</b></div>
        <div>${chartMode === 'sg'
          ? `SG: ${nearest.sg.toFixed(3)}`
          : `ABV: ${nearest.y.toFixed(1)}%`}</div>
        ${sugarBreak ? '<div style="color:#ffaa33;">1/3 Break: ' + sugarBreak + '</div>' : ''}
      `;
    } else {
      tooltip.style.display = 'none';
      renderBase();
    }
  }; // ‚úÖ ‚Üê closes c.onmousemove properly

  // Separate handler for leaving canvas
  c.onmouseleave = () => {
    tooltip.style.display = 'none';
    renderBase();
  };
}

/* === UI Event Listeners === */

// Create new batch
$('#newBatchBtn').addEventListener('click', () => {
  selectedId = null;
  render();
});

// Live search in sidebar
$('#searchInput').addEventListener('input', renderBatchList);

// Clear all data (reset localStorage)
$('#clearBtn').addEventListener('click', () => {
  if (!confirm('Delete ALL mead tracker data?')) return;
  state = { batches: [] };
  selectedId = null;
  save(state);
  render();
});

// Export data as downloadable JSON file
$('#exportBtn').addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(state, null, 2)], {
    type: 'application/json'
  });
  const url = URL.createObjectURL(blob);
  const a = el('a', { href: url, download: 'mead-tracker-data.json' });
  document.body.append(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// Import data from JSON file
$('#importBtn').addEventListener('click', () => $('#importFile').click());
$('#importFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  const data = JSON.parse(text);
  state = data;
  selectedId = state.batches[0]?.id || null;
  save(state);
  render();
});

function openLabelMaker(batch) {
  const modal = $('#labelModal');
  const preview = $('#labelPreview');
  modal.classList.remove('hidden');

  // Helper to safely inject text into HTML
  const escapeHTML = (s) => String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

  const date = batch.startDate ? new Date(batch.startDate).toLocaleDateString() : '';
  const lastReading = (batch.sgReadings && batch.sgReadings.length)
    ? batch.sgReadings[batch.sgReadings.length - 1]
    : null;

  const OG = parseFloat(batch.og);
  const FG = lastReading ? parseFloat(lastReading.sg) : NaN;
  const abv = (isFinite(OG) && isFinite(FG))
    ? ((OG - FG) * 131.25).toFixed(1) + '%'
    : '‚Äì';

  const honey = batch.honey || 'Mixed Blossom';

  preview.innerHTML = `
    <h1 style="text-align:center;font-size:20pt;margin:0;">${escapeHTML(batch.name)}</h1>
    <p style="text-align:center;margin:2mm 0;">${escapeHTML(honey)} Mead</p>
    <hr style="border:none;border-top:1px solid #8b6b2c;margin:2mm 0;">
    <p><b>Batch:</b> ${escapeHTML(batch.name)}</p>
    <p><b>Start:</b> ${escapeHTML(date)}</p>
    <p><b>ABV:</b> ${abv}</p>
  `;

  $('#printLabel').onclick = () => window.print();
  $('#closeLabel').onclick = () => modal.classList.add('hidden');
  modal.onclick = (e) => {
  if (e.target === modal) modal.classList.add('hidden');
};
}

// === Collapsible Cloud Sync card ===
const syncCard = document.getElementById('syncCard');
const syncContent = document.getElementById('syncContent');

if (syncCard) {
  const legend = syncCard.querySelector('legend');
  legend.addEventListener('click', () => {
    const collapsed = syncContent.style.display === 'none';
    syncContent.style.display = collapsed ? 'block' : 'none';
    legend.textContent = collapsed ? '‚òÅÔ∏è Cloud Sync ‚ñº' : '‚òÅÔ∏è Cloud Sync ‚ñ∂';
  });
  // Start collapsed
  syncContent.style.display = 'none';
  legend.textContent = '‚òÅÔ∏è Cloud Sync ‚ñ∂';
}

// === JSONSilo Cloud Sync ===
let SILO_ID = localStorage.getItem('SILO_ID') || null;
const SILO_API = 'https://jsonsilo.com/api/bins';

// Update sidebar
function updateSyncCard() {
  const urlEl = document.getElementById('syncUrl');
  const keyEl = document.getElementById('syncKey');
  if (urlEl) urlEl.textContent = SILO_ID ? `${SILO_API}/${SILO_ID}` : 'Not assigned yet';
  if (keyEl) keyEl.textContent = 'jsonsilo';
}

/**
 * Create a new JSONSilo bin and store its ID locally.
 */
async function createSilo() {
  try {
    const res = await fetch(SILO_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ batches: [] })
    });
    const data = await res.json();
    if (!data.id) throw new Error('No ID returned');
    SILO_ID = data.id;
    localStorage.setItem('SILO_ID', SILO_ID);
    updateSyncCard();
    alert(`‚úÖ Created JSONSilo bin:\n${SILO_ID}`);
  } catch (err) {
    console.error('Failed to create JSONSilo bin', err);
    alert('‚ö†Ô∏è Could not create JSONSilo bin.');
  }
}

/**
 * Load from JSONSilo or local fallback.
 */
async function cloudLoad() {
  if (!SILO_ID) return load();
  try {
    const res = await fetch(`${SILO_API}/${SILO_ID}`);
    if (!res.ok) throw new Error('Not found');
    const data = await res.json();
    return data || load();
  } catch (err) {
    console.warn('Cloud load failed, using local copy:', err);
    return load();
  }
}

/**
 * Save to JSONSilo and localStorage.
 */
async function cloudSave(state) {
  save(state);
  if (!SILO_ID) return;
  try {
    await fetch(`${SILO_API}/${SILO_ID}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(state)
    });
    console.log('‚òÅÔ∏è Synced to JSONSilo');
  } catch (err) {
    console.warn('‚ö†Ô∏è Cloud sync failed', err);
  }
}
window.addEventListener('beforeunload', () => cloudSave(state));

// === Startup ===
(async () => {
  if (!SILO_ID) {
    const makeNew = confirm(
      'No JSONSilo bin found for your Mead Tracker.\n\nCreate one now?'
    );
    if (makeNew) await createSilo();
  }

  state = await cloudLoad();
  render();
  updateSyncCard();
})();



</script>
<!-- === Label Maker Modal === -->
<div id="labelModal" class="hidden" style="
  position:fixed; inset:0; background:rgba(0,0,0,0.6);
  display:flex; align-items:center; justify-content:center;
  z-index:1000;
">
  <div id="labelBox" style="
    background:#fefaf3; color:#333; border:2px solid #8b6b2c;
    border-radius:10px; padding:10mm; width:100mm; height:70mm;
    font-family:'Georgia',serif; position:relative;
  ">
    <div id="labelPreview"></div>
    <div style="position:absolute;bottom:6mm;right:6mm;font-size:9pt;font-style:italic;">
      Crafted with ‚ô• in Meadtrics
    </div>
  </div>
  <div style="position:absolute;bottom:20px;">
    <button id="printLabel" class="btn-accent">Print Label</button>
    <button id="closeLabel" class="btn-danger">Close</button>
  </div>
</div>
</body>
</html>