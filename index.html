<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MeadTrics</title>
  <style>
/* ===============================
   MeadTrics Stylesheet
   =============================== */

/* === Theme Variables === */
:root {
  --bg: #0f1216;
  --panel: #161a20;
  --muted: #aab2c0;
  --text: #e8edf5;
  --accent: #82cfff;
  --accent-2: #b5e08a;
  --danger: #ff6b6b;
  --border: #2a2f39;
  --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  --radius: 14px;
}

/* === Global Reset === */
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; }
body {
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
    Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
  background: radial-gradient(1200px 800px at 100% -10%, #16202e 0, #0f1216 50%);
  color: var(--text);
}

/* === Input Styles === */
input[type="number"] { font-size: 16px; }
input[type="number"].wide { width: 100%; min-width: 150px; }

input[type="text"],
input[type="date"],
input[type="number"],
textarea,
select {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
}
textarea { resize: vertical; min-height: 80px; }

/* === Layout === */
.app {
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 16px;
  height: 100%;
  padding: 16px;
}
.sidebar {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.sidebar header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}
.sidebar header h1 { font-size: 18px; margin: 0; }

.search { width: 100%; }
.search input {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
}

.content {
  display: grid;
  grid-template-rows: 1fr auto;
  gap: 16px;
}
.detail {
  padding: 16px;
  overflow: auto;
}
.detail h2 { margin: 0 0 8px 0; }

/* === Cards & Panels === */
.card {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

/* === Lists === */
.list {
  overflow: auto;
  padding: 8px;
  display: grid;
  gap: 8px;
}
.batch {
  padding: 12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  cursor: pointer;
  transition: border-color .2s, background .2s;
}
.batch:hover { border-color: #3a4150; background: #111821; }
.batch.active { outline: 2px solid var(--accent); background: #101722; }
.batch .name { font-weight: 600; }
.batch .name:hover { text-decoration: underline; cursor: pointer; }
.batch .meta { color: var(--muted); font-size: 12px; margin-top: 4px; }
.batch .btn-danger {
  padding: 2px 6px;
  font-size: 12px;
  line-height: 1;
  border-radius: 8px;
}
.batch .btn-danger:hover {
  background: #2a1616;
  color: #ffb5b5;
}

/* === Form Layout === */
.grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 12px;
}
.grid .col-6 { grid-column: span 6; }
.grid .col-12 { grid-column: span 12; }

label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}

/* === Fieldsets === */
.fieldset {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
}
.fieldset legend {
  font-weight: 600;
  color: var(--accent);
  cursor: default;
}
.fieldset legend:hover { color: var(--accent-2); }
.fieldset + .fieldset {
  margin-top: 14px;
  border-color: #252b34;
  background: rgba(255, 255, 255, 0.02);
  padding-top: 10px;
  padding-bottom: 10px;
}
.fieldset:nth-of-type(n+2) {
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
  border-radius: 10px;
}
.fieldset.collapsible legend::after { content: " ▼"; }
.fieldset.collapsible.collapsed legend::after { content: " ▶"; }

/* === Buttons === */
button {
  appearance: none;
  border: 1px solid var(--border);
  background: #121923;
  color: var(--text);
  padding: 10px 14px;
  border-radius: 12px;
  cursor: pointer;
  transition: transform .04s ease, background .2s, border-color .2s;
  font-weight: 600;
}
button:hover { background: #182233; border-color: #304055; }
button:active { transform: translateY(1px); }

.btn-accent {
  background: var(--accent);
  border: none;
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s ease;
}
.btn-accent:hover { background: var(--accent-2); }

.btn-danger {
  background: #2a1416;
  border-color: #4e2326;
  color: #ffd6d6;
}

/* === Footer === */
.footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 8px;
  justify-content: space-between;
}
.tag {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 9999px;
  border: 1px solid var(--border);
  color: var(--muted);
}

/* === Tables === */
.table {
  width: 100%;
  border-collapse: collapse;
}
.table th, .table td {
  border-bottom: 1px solid var(--border);
  padding: 8px 6px;
  text-align: left;
  font-size: 14px;
}
.table tr[data-type="bottled"] td { background: rgba(255,255,255,0.02); color: #b5e08a; }
.table tr[data-type="feeding"] td { background: rgba(255,200,0,0.04); color: #ffe680; }
.table tr[data-type="racked"] td { color: #b0c0ff; }
.table tr[data-type="note"] td textarea { background: #111822; color: #d8dee9; }
.empty { color: var(--muted); font-style: italic; padding: 12px 0; }

/* === Chart === */
canvas {
  width: 100%;
  height: 220px;
  background: #0c1218;
  border: 1px solid var(--border);
  border-radius: 12px;
}
.chart-tooltip {
  position: absolute;
  pointer-events: none;
  background: #0f141b;
  color: #e8edf5;
  border: 1px solid #2a2f39;
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  backdrop-filter: blur(4px);
  z-index: 10;
}

/* === Utility === */
.row { display: flex; justify-content: space-between; align-items: center; gap: 6px; }
.meta { white-space: pre-line; }
.meta::first-line { font-weight: 500; }
.meta:has(> span) { display: flex; flex-direction: column; }
.hidden { display: none !important; }

/* === Scrollbars === */
.list::-webkit-scrollbar,
.detail::-webkit-scrollbar { width: 8px; }
.list::-webkit-scrollbar-thumb,
.detail::-webkit-scrollbar-thumb {
  background: #202833;
  border-radius: 6px;
}
.list::-webkit-scrollbar-thumb:hover,
.detail::-webkit-scrollbar-thumb:hover { background: #2e3a4b; }

/* === Feedback Button === */
.icon-btn {
  position: fixed;
  bottom: 16px;
  right: 16px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 50%;
  width: 46px;
  height: 46px;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  z-index: 1000;
}

/* === Popup / Feedback Modal === */
.popup {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}
.popup.hidden { display: none; }

.popup-content {
  background: var(--panel);
  color: var(--text);
  padding: 20px;
  border-radius: var(--radius);
  width: 90%;
  max-width: 420px;
  box-shadow: var(--shadow);
  border: 1px solid var(--border);
  animation: fadeIn 0.25s ease;
}
.popup-content h3 { margin-top: 0; color: var(--accent); }
.popup-content textarea {
  width: 100%;
  box-sizing: border-box;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
  resize: vertical;
  font-family: inherit;
}
.popup-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 12px;
}
.popup-actions button {
  padding: 8px 14px;
  border-radius: 10px;
  border: 1px solid var(--border);
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
}
.popup-actions .primary {
  background: var(--accent);
  color: #fff;
}
.popup-actions .primary:hover { background: var(--accent-2); }
.popup-actions .secondary {
  background: #1a2028;
  color: var(--text);
}
.popup-actions .secondary:hover { background: #222a33; }

/* === Print Labels === */
@media print {
  body * { visibility: hidden; }
  #labelBox, #labelBox * { visibility: visible; }
  #labelBox {
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
  }
}

/* === Responsive === */
@media (max-width: 980px) {
  .app { grid-template-columns: 1fr; }
  .content { grid-template-rows: auto auto; }
}

/* === Label Maker Modal === */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  background: var(--panel);
  color: var(--text);
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  padding: 20px;
  max-width: 420px;
  width: 90%;
}

/* Keep label preview positioned so QR can anchor to a corner */
.label-preview {
  position: relative;
  padding: 8mm;
  border-radius: 8px;
  background: var(--panel, #1b2330);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
  text-align: center;
}

/* Centered QR container */
#qrContainer {
  width: 28mm;       /* consistent print scaling */
  height: 28mm;
  margin: 6mm auto 0 auto;
  display: grid;
  place-items: center;
  background: transparent;
}

/* QR image/canvas crisp rendering */
#qrContainer canvas,
#qrContainer img {
  width: 100% !important;
  height: 100% !important;
  display: block;
  image-rendering: pixelated;
}

/* Optional subtle frame */
#qrContainer.qr-framed {
  padding: 2mm;
  border-radius: 6px;
  background: rgba(255,255,255,0.06);
  outline: 1px solid rgba(255,255,255,0.1);
}

/* Print layout */
@media print {
  body * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  #labelModal.modal-overlay {
    background: transparent !important;
  }

  #labelModal .modal-content {
    box-shadow: none !important;
    border: none !important;
  }

  /* Hide buttons on print */
  #labelModal .row {
    display: none !important;
  }

  .label-preview {
    margin: 0 auto !important;
    box-shadow: none !important;
    width: 90mm;          /* adjust for sticker width */
    min-height: 120mm;    /* adjust for sticker height */
  }

  #qrContainer {
    margin-top: 6mm !important;
  }
}

/* Responsive */
@media (max-width: 520px) {
  #qrContainer {
    width: 24mm;
    height: 24mm;
    margin-top: 4mm;
  }
}

/* === Enhanced Responsive Scaling === */
html {
  font-size: clamp(12px, 1vw + 0.5rem, 18px);
}

/* Sidebar and main content stack on smaller screens */
@media (max-width: 1200px) {
  .app {
    grid-template-columns: 260px 1fr;
    gap: 12px;
  }
}

/* Tablet layout: full-width stacked sections */
@media (max-width: 800px) {
  .app {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto;
  }

  .sidebar {
    order: 2;
    max-height: 40vh;
    overflow-y: auto;
  }

  .content {
    order: 1;
  }

  .detail {
    max-height: 55vh;
    overflow-y: auto;
  }

  canvas {
    height: 180px !important;
  }
}

/* Mobile layout: single-column with tighter spacing */
@media (max-width: 600px) {
  body {
    padding: 0;
  }

  .app {
    padding: 8px;
    gap: 8px;
  }

  .fieldset {
    padding: 8px;
  }

  .card {
    border-radius: 10px;
  }

  button {
    font-size: 0.9rem;
    padding: 8px 10px;
  }

  legend {
    font-size: 1rem;
  }

  h1, h2 {
    font-size: 1.1rem;
  }

  .sidebar header {
    flex-direction: column;
    align-items: flex-start;
  }

  .icon-btn {
    bottom: 12px;
    right: 12px;
    width: 40px;
    height: 40px;
    font-size: 18px;
  }
}

/* Ultra-wide: center constrain layout */
@media (min-width: 2000px) {
  .app {
    max-width: 1600px;
    margin: 0 auto;
  }
}

.tag {
  transition: background 0.2s, color 0.2s, border-color 0.2s;
}
.tag:hover {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

/* === Sidebar Drawer System === */
#sidebarToggle {
  display: none;
  position: fixed;
  top: 1rem;
  left: 1rem;
  z-index: 1001;
  background: var(--accent, #4a9fff);
  color: white;
  font-size: 1.4rem;
  border: none;
  border-radius: 8px;
  padding: 8px 12px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
  cursor: pointer;
}

/* Drawer hidden by default */
#sidebarDrawer {
  position: fixed;
  top: 0;
  left: -260px; /* hidden off-screen */
  width: 240px;
  height: 100%;
  background: var(--panel, #1b1f27);
  box-shadow: 4px 0 12px rgba(0,0,0,0.4);
  padding: 1rem;
  transition: left 0.3s ease;
  z-index: 1000;
  overflow-y: auto;
  color: var(--text, #fff);
}

#sidebarDrawer.open {
  left: 0; /* slide in */
}

/* Overlay */
#sidebarOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.45);
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease;
  z-index: 999;
}

#sidebarOverlay.visible {
  opacity: 1;
  visibility: visible;
}

/* Mobile only */
@media (max-width: 768px) {
  #sidebarToggle {
    display: block;
  }

  /* Hide desktop sidebar on mobile */
  .sidebar {
    display: none !important;
  }
}

/* Desktop keeps normal layout */
@media (min-width: 769px) {
  #sidebarDrawer,
  #sidebarOverlay,
  #sidebarToggle {
    display: none;
  }
}


  </style>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f1216">
</head>
<body>
<div class="app"></div>
</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>


  <script>

const LS_KEY = 'mead-tracker:v2';

const EVENTS = [
  'primary fermentation',
  'secondary fermentation',
  'racked',
  'feeding',
  'degassing',
  'conditioning',
  'cold crashing',
  'backsweetened',
  'bottled'
];

const TAGS = [
  "Bochet", "Braggot", "Capsicumel", "Cyser", "Historical",
  "Hydromel", "Melomel", "Metheglin", "Pyment", "Sack",
  "Sour", "Wild", "Traditional", "Experiential"
];

const $ = sel => document.querySelector(sel);


const el = (tag, attrs = {}, children = []) => {
  const n = document.createElement(tag);


  Object.entries(attrs).forEach(([k, v]) => {
    if (k === 'class') n.className = v;                            
    else if (k === 'text') n.textContent = v;                     
    else if (k.startsWith('on') && typeof v === 'function')       
      n.addEventListener(k.slice(2), v);
    else n.setAttribute(k, v);                                     
  });

  children.forEach(c => n.append(c));

  return n;
};


const fmt = (d) => d ? new Date(d).toLocaleDateString() : '';

let state = { batches: [] }; 

let selectedId = state.batches[0]?.id || null;

let chartMode = 'sg'; 

let sidebarCollapse = { active: false, archived: false };

function compressPayload(obj) {
  try {
    if (typeof LZString === "undefined") throw new Error("LZString not loaded");
    const json = JSON.stringify(obj);
    const compressed = LZString.compressToBase64(json);
    return { __compressed: true, data: compressed };
  } catch (err) {
    console.warn("⚠️ Compression failed:", err);
    return obj;
  }
}


function decompressPayload(obj) {
  try {
    if (obj && obj.__compressed && typeof obj.data === "string" && typeof LZString !== "undefined") {
      const json = LZString.decompressFromBase64(obj.data);
      return JSON.parse(json);
    }
    return obj;
  } catch (err) {
    console.warn("⚠️ Decompression failed:", err);
    return obj;
  }
}

function load() {
  try {
    const data = localStorage.getItem(LS_KEY);
    return data ? JSON.parse(data) : { batches: [] };
  } catch (err) {
    console.error('Failed to load local data', err);
    return { batches: [] };
  }
}

function save(state) {
  try {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  } catch (err) {
    console.error('Failed to save local data', err);
  }
}


function batchHeaderCard() {
  return el('div', {
    class: 'fieldset',
    id: 'batchesHeader',
    style: `
      margin-top:16px;
      text-align:center;
      padding:10px 0;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    `
  }, [
    el('legend', {
      text: '⚙️ Batches',
      style: `
        color: var(--accent);
        font-weight: 700;
        font-size: 15px;
        letter-spacing: 0.5px;
      `
    })
  ]);
}


function utilitiesHeaderCard() {
  return el('div', {
    class: 'fieldset',
    id: 'utilitiesHeader',
    style: `
      margin-top:16px;
      text-align:center;
      padding:10px 0;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    `
  }, [
    el('legend', {
      text: '⚙️ Utilities',
      style: `
        color: var(--accent);
        font-weight: 700;
        font-size: 15px;
        letter-spacing: 0.5px;
      `
    })
  ]);
}


function calcTosna() {
  const vol = parseFloat(document.getElementById("tosnaVol")?.value || 0);
  const yan = parseFloat(document.getElementById("tosnaYan")?.value || 0);
  const req = document.getElementById("tosnaReq")?.value || "medium";
  const type = document.getElementById("tosnaType")?.value || "OK";
  const result = document.getElementById("tosnaResult");

  if (!vol || !yan || !result) {
    console.warn("calcTosna() skipped — elements not ready");
    return;
  }

  
  const reqMap = { low: 125, medium: 150, high: 200 }; 
  const targetYan = reqMap[req] || 150;

  const yanNeeded = targetYan - yan;
  if (yanNeeded <= 0) {
    result.textContent = "YAN already sufficient.";
    return;
  }

  
  const fermaidO_YAN = 20;
  const fermaidK_YAN = 25;
  const dap_YAN = 60;

  let fermaidO = 0, fermaidK = 0, dap = 0;
  if (type === "O") {
    fermaidO = (yanNeeded / fermaidO_YAN) * vol;
  } else if (type === "OK") {
    fermaidO = (yanNeeded * 0.6 / fermaidO_YAN) * vol;
    fermaidK = (yanNeeded * 0.4 / fermaidK_YAN) * vol;
  } else if (type === "OKDAP") {
    fermaidO = (yanNeeded * 0.5 / fermaidO_YAN) * vol;
    fermaidK = (yanNeeded * 0.3 / fermaidK_YAN) * vol;
    dap = (yanNeeded * 0.2 / dap_YAN) * vol;
  }

  const schedule = [
    `• 24h → ${(fermaidO / 4).toFixed(2)} g O`,
    `• 48h → ${(fermaidO / 4).toFixed(2)} g O`,
    `• 72h → ${(fermaidO / 4).toFixed(2)} g O`,
    `• 1/3 Break → ${(fermaidO / 4).toFixed(2)} g O + ${fermaidK.toFixed(2)} g K + ${dap.toFixed(2)} g DAP`
  ].join("\n");

  result.innerHTML =
    `📦 For ${vol.toFixed(1)} L at ${targetYan} mg/L target YAN<br><br>` +
    `Fermaid O ≈ ${fermaidO.toFixed(1)} g · ` +
    `Fermaid K ≈ ${fermaidK.toFixed(1)} g · ` +
    `DAP ≈ ${dap.toFixed(1)} g<br><br>` +
    `Schedule:<br>${schedule.replace(/\n/g, "<br>")}`;
}



function tosnaCard() {
 
  let collapsed = true;

  
  const volInput = el('input', {
    id: 'tosnaVol',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

const abvInput = el('input', {
  id: 'tosnaYeastABV',
  type: 'number',
  step: '0.1',
  value: '14',
  style: 'width:100%;margin-bottom:6px;'
});

const sweetSel = el('select', {
  id: 'tosnaSweetness',
  style: 'width:100%;margin-bottom:6px;'
}, [
  el('option', { value: 'dry', text: 'Dry (little to no residual sugar)' }),
  el('option', { value: 'semi', text: 'Semi-sweet (balanced)', selected: true }),
  el('option', { value: 'sweet', text: 'Sweet (high residual sugar)' })
]);

abvInput.addEventListener('input', updateFGOG);
sweetSel.addEventListener('change', updateFGOG);

  const reqSel = el('select', {
    id: 'tosnaReq',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', {
      value: 'low',
      text: 'Low — e.g., D47, 71B, K1V — Traditional, show, hydromel'
    }),
    el('option', {
      value: 'medium',
      text: 'Medium — e.g., QA23, D21, RC212 — Melomel, metheglin, pyment',
      selected: true
    }),
    el('option', {
      value: 'high',
      text: 'High — e.g., EC-1118, BM4x4, D254 — Bochet, capsicumel, cyser, braggot'
    })
  ]);

  const yanInput = el('input', {
    id: 'tosnaYan',
    type: 'number',
    step: '1',
    value: '150',
    style: 'width:100%;margin-bottom:6px;'
  });

  const typeSel = el('select', {
    id: 'tosnaType',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', { value: 'O', text: 'Fermaid O (TOSNA)' }),
    el('option', { value: 'OK', text: 'Fermaid O + K' }),
    el('option', { value: 'OKDAP', text: 'Fermaid O + K + DAP' })
  ]);

  const fgog = el('div', {
    id: 'tosnaFGOG',
    style: 'font-size:13px;color:var(--muted);margin-bottom:8px;',
    text: 'Estimated FG: 1.010 → Suggested OG: 1.110'
  });

  const result = el('div', {
    id: 'tosnaResult',
    style: 'font-size:13px;color:var(--muted);'
  });

const calcBtn = el('button', {
  id: 'calcTosna',
  class: 'btn-accent',
  text: 'Calculate TOSNA',
  style: 'width:100%;',
  onclick: () => calcTosna()
});

  const body = el('div', {
    id: 'tosnaContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Based on TOSNA 2.0 — calculates nutrient additions by volume, yeast, and target YAN.'
    }),
    el('label', { text: 'Volume (L):' }),
    volInput,
    el('label', { text: 'Yeast ABV Tolerance (%):' }),
    abvInput,
    el('label', { text: 'Desired Sweetness:' }),
    sweetSel,
    fgog,
    el('label', { text: 'Yeast Nitrogen Requirement:' }),
    reqSel,
    el('label', { text: 'Target YAN (mg N/L):' }),
    yanInput,
    el('label', { text: 'Nutrient Type:' }),
    typeSel,
    calcBtn,
    el('hr', {
      style: 'margin:10px 0;border:none;border-top:1px solid var(--border);'
    }),
    result
  ]);
 
  const legend = el('legend', {
    text: '🍯 TOSNA Calculator',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '▶ ' : '▼ ') + '🍯 TOSNA Calculator';
    }
  });

  
  const card = el('div', {
    id: 'tosnaCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  
  collapsed = true;
  body.style.display = 'none';

  return card;
}


function backsweetCard() {
  let collapsed = true;

  // === Inputs ===
  const currentSG = el('input', {
    id: 'back_currentSG',
    type: 'number',
    step: '0.001',
    value: '1.000',
    style: 'width:100%;margin-bottom:6px;'
  });

  const desiredSG = el('input', {
    id: 'back_desiredSG',
    type: 'number',
    step: '0.001',
    value: '1.015',
    style: 'width:100%;margin-bottom:6px;'
  });

  const volume = el('input', {
    id: 'back_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const typeSel = el('select', {
    id: 'back_type',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', { value: 'sugar', text: 'White Sugar (100%)', selected: true }),
    el('option', { value: 'honey', text: 'Honey (≈82%)' }),
    el('option', { value: 'custom', text: 'Custom Sweetener (%)' })
  ]);

  const customWrap = el('div', {
    id: 'customPercentWrap',
    style: 'display:none;margin-bottom:6px;'
  }, [
    el('label', { text: 'Custom Sugar Content (%):' }),
    el('input', {
      id: 'back_customPercent',
      type: 'number',
      step: '1',
      min: '1',
      max: '100',
      value: '75',
      style: 'width:100%;'
    })
  ]);

  const resultField = el('input', {
    id: 'back_resultKg',
    type: 'text',
    readonly: true,
    style: 'width:100%;margin-bottom:6px;'
  });

  const resultDiv = el('div', {
    id: 'backResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  
  const calcBacksweet = () => {
    const sg1 = parseFloat(currentSG.value);
    const sg2 = parseFloat(desiredSG.value);
    const vol = parseFloat(volume.value);
    const type = typeSel.value;
    const customPct = parseFloat(document.getElementById('back_customPercent')?.value || '75');

    if (isNaN(sg1) || isNaN(sg2) || isNaN(vol) || sg2 <= sg1)
      return (resultDiv.textContent = '⚠️ Please enter valid SG and volume values.');

    const delta = (sg2 - sg1) * 1000;
    let sugarGrams = delta * vol * 1.53; 

    
    let label = '';
    if (type === 'honey') {
      sugarGrams /= 0.82;
      label = 'honey';
    } else if (type === 'custom') {
      sugarGrams /= (customPct / 100);
      label = 'custom sweetener';
    } else {
      label = 'sugar';
    }

    const kg = sugarGrams / 1000;
    resultField.value = kg.toFixed(3);
    resultDiv.innerHTML = `Add approximately <b>${kg.toFixed(3)} kg</b> of ${label}.`;
  };

  
  const calcBtn = el('button', {
    id: 'calcBacksweetBtn',
    class: 'btn-accent',
    text: 'Calculate Backsweetening',
    style: 'width:100%;',
    onclick: calcBacksweet
  });

  
  const body = el('div', {
    id: 'backContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Estimate how much sugar, honey, or custom sweetener to add after fermentation to reach your desired sweetness. (Ensure your mead is stabilized first!)'
    }),
    el('label', { text: 'Current SG (after fermentation):' }),
    currentSG,
    el('label', { text: 'Desired Final SG:' }),
    desiredSG,
    el('label', { text: 'Volume (L):' }),
    volume,
    el('label', { text: 'Addition Type:' }),
    typeSel,
    customWrap,
    el('label', { text: 'Amount to Add (kg):' }),
    resultField,
    calcBtn,
    el('hr', {
      style: 'margin:10px 0;border:none;border-top:1px solid var(--border);'
    }),
    resultDiv
  ]);

  
  const legend = el('legend', {
    text: '🍯 Backsweetening Additions',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '▶ ' : '▼ ') + '🍯 Backsweetening Additions';
    }
  });

  
  const card = el('div', {
    id: 'backsweetCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  
  collapsed = true;
  body.style.display = 'none';

  
  typeSel.addEventListener('change', () => {
    customWrap.style.display = typeSel.value === 'custom' ? 'block' : 'none';
  });

  return card;
  updateFGOG();
  
}


function dilutionCard() {
  let collapsed = true;

  
  const sg1Input = el('input', {
    id: 'dil_sg1',
    type: 'number',
    step: '0.001',
    value: '1.120',
    style: 'width:100%;margin-bottom:6px;'
  });

  const sg2Input = el('input', {
    id: 'dil_sg2',
    type: 'number',
    step: '0.001',
    value: '1.070',
    style: 'width:100%;margin-bottom:6px;'
  });

  const volumeInput = el('input', {
    id: 'dil_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const resultDiv = el('div', {
    id: 'dilResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  
  const calcDilution = () => {
    const sg1 = parseFloat(sg1Input.value);
    const sg2 = parseFloat(sg2Input.value);
    const vol = parseFloat(volumeInput.value);

    if (isNaN(sg1) || isNaN(sg2) || isNaN(vol) || sg2 >= sg1) {
      resultDiv.textContent = '⚠️ Please enter valid values (target SG must be lower).';
      return;
    }

    
    const points1 = (sg1 - 1) * 1000;
    const points2 = (sg2 - 1) * 1000;

   
    const addWater = (vol * (points1 - points2)) / points2;

    resultDiv.innerHTML =
      `To dilute <b>${vol.toFixed(2)} L</b> of ${sg1.toFixed(3)} SG must ` +
      `to ${sg2.toFixed(3)} SG, add approximately <b>${addWater.toFixed(2)} L</b> of water.`;
  };

 
  const calcBtn = el('button', {
    id: 'calcDilution',
    class: 'btn-accent',
    text: 'Calculate Dilution',
    style: 'width:100%;',
    onclick: calcDilution
  });

  
  const body = el('div', {
    id: 'dilContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Determine how much water to add to reach your target specific gravity.'
    }),
    el('label', { text: 'Current SG:' }),
    sg1Input,
    el('label', { text: 'Target SG:' }),
    sg2Input,
    el('label', { text: 'Current Volume (L):' }),
    volumeInput,
    calcBtn,
    el('hr', {
      style: 'margin:10px 0;border:none;border-top:1px solid var(--border);'
    }),
    resultDiv
  ]);

  
  const legend = el('legend', {
    text: '💧 Dilution Calculator',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '▶ ' : '▼ ') + '💧 Dilution Calculator';
    }
  });

  
  const card = el('div', {
    id: 'dilutionCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  collapsed = true;
  body.style.display = 'none';

  return card;
}


function primingCard() {
  let collapsed = true;

  
  const volInput = el('input', {
    id: 'prime_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const tempInput = el('input', {
    id: 'prime_temp',
    type: 'number',
    step: '0.1',
    value: '20',
    style: 'width:100%;margin-bottom:6px;'
  });

  const co2Input = el('input', {
    id: 'prime_co2',
    type: 'number',
    step: '0.1',
    value: '2.5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const sugarSel = el('select', {
    id: 'prime_sugar',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', { value: 'dextrose', text: 'Corn Sugar (Dextrose)', selected: true }),
    el('option', { value: 'sucrose', text: 'Table Sugar (Sucrose)' }),
    el('option', { value: 'honey', text: 'Honey' })
  ]);

  const resultDiv = el('div', {
    id: 'primeResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  
  const calcPriming = () => {
    const vol = parseFloat(volInput.value);
    const temp = parseFloat(tempInput.value);
    const co2 = parseFloat(co2Input.value);
    const sugarType = sugarSel.value;

    if (isNaN(vol) || isNaN(temp) || isNaN(co2)) {
      resultDiv.textContent = '⚠️ Please enter valid volume, temperature, and CO₂ level.';
      return;
    }

    
    const residualCO2 = 3.0378 - 0.050062 * temp + 0.00026555 * temp ** 2;

    
    const neededCO2 = co2 - residualCO2;
    if (neededCO2 <= 0) {
      resultDiv.textContent = 'No priming sugar needed — CO₂ already at or above target.';
      return;
    }

    
    let factor = 4.01; 
    if (sugarType === 'sucrose') factor = 3.83;
    if (sugarType === 'honey') factor = 4.52;

    const grams = neededCO2 * vol * factor;
    const tsp = grams / 4.2; 

    resultDiv.innerHTML =
      `To reach <b>${co2.toFixed(2)} volumes CO₂</b> at ${temp.toFixed(1)}°C ` +
      `for <b>${vol.toFixed(1)} L</b>, add approximately:<br>` +
      `<b>${grams.toFixed(1)} g</b> (${tsp.toFixed(1)} tsp) of ${sugarType}.`;
  };

  
  const calcBtn = el('button', {
    id: 'calcPriming',
    class: 'btn-accent',
    text: 'Calculate Priming Sugar',
    style: 'width:100%;',
    onclick: calcPriming
  });

 
  const body = el('div', {
    id: 'primeContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Estimate how much sugar to add for bottle carbonation. Experimental values only; verify before bottling!'
    }),
    el('label', { text: 'Batch Volume (L):' }),
    volInput,
    el('label', { text: 'Beer/Mead Temperature (°C):' }),
    tempInput,
    el('label', { text: 'Target CO₂ Volumes:' }),
    co2Input,
    el('label', { text: 'Sugar Type:' }),
    sugarSel,
    calcBtn,
    el('hr', { style: 'margin:10px 0;border:none;border-top:1px solid var(--border);' }),
    resultDiv
  ]);

  
  const legend = el('legend', {
    text: '🧪 Priming Calculator (Experimental)',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '▶ ' : '▼ ') + '🧪 Priming Calculator (Experimental)';
    }
  });

  
  const card = el('div', {
    id: 'primingCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  collapsed = true;
  body.style.display = 'none';

  return card;
}


function stabilCard() {
  let collapsed = true;

  
  const volInput = el('input', {
    id: 'stab_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const campdenInput = el('input', {
    id: 'stab_campden',
    type: 'number',
    step: '0.1',
    value: '0.44',
    style: 'width:100%;margin-bottom:6px;'
  });

  const sorbateInput = el('input', {
    id: 'stab_sorbate',
    type: 'number',
    step: '0.1',
    value: '0.75',
    style: 'width:100%;margin-bottom:6px;'
  });

  const resultDiv = el('div', {
    id: 'stabResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  const calcStabil = () => {
    const vol = parseFloat(volInput.value);
    const campden = parseFloat(campdenInput.value);
    const sorbate = parseFloat(sorbateInput.value);

    if (isNaN(vol) || isNaN(campden) || isNaN(sorbate)) {
      resultDiv.textContent = '⚠️ Please enter valid numbers.';
      return;
    }

   
    const campdenTotal = (vol * campden) / 5;
    const sorbateTotal = (vol * sorbate) / 5;

    resultDiv.innerHTML =
      `For <b>${vol.toFixed(1)} L</b> batch:<br>` +
      `Add approximately <b>${campdenTotal.toFixed(2)} g</b> potassium metabisulfite (≈ ${(
        campdenTotal / 0.44
      ).toFixed(1)} tablets)<br>` +
      `and <b>${sorbateTotal.toFixed(2)} g</b> potassium sorbate.<br><br>` +
      `<i>Ensure fermentation has completely stopped before stabilising.</i>`;
  };


  const calcBtn = el('button', {
    id: 'calcStabil',
    class: 'btn-accent',
    text: 'Calculate Additions',
    style: 'width:100%;',
    onclick: calcStabil
  });


  const body = el('div', {
    id: 'stabContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Estimate stabilising agent additions before backsweetening. Typical use: 0.44 g K-meta and 0.75 g sorbate per 5 L.'
    }),
    el('label', { text: 'Batch Volume (L):' }),
    volInput,
    el('label', { text: 'K-meta (g per 5 L):' }),
    campdenInput,
    el('label', { text: 'K-sorbate (g per 5 L):' }),
    sorbateInput,
    calcBtn,
    el('hr', { style: 'margin:10px 0;border:none;border-top:1px solid var(--border);' }),
    resultDiv
  ]);


  const legend = el('legend', {
    text: '⚗️ Stabilisation Calculator',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent =
        (collapsed ? '▶ ' : '▼ ') + '⚗️ Stabilisation Calculator';
    }
  });


  const card = el('div', {
    id: 'stabilCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  collapsed = true;
  body.style.display = 'none';

  return card;
}


function brixCard() {
  let collapsed = true;


  const brixToSG = (brix) =>
    1 + (brix / (258.6 - ((brix / 258.2) * 227.1)));
  const sgToBrix = (sg) =>
    (((182.4601 * sg - 775.6821) * sg + 1262.7794) * sg - 669.5622);


  const brixInput = el("input", {
    id: "brixInput",
    type: "number",
    step: "0.01",
    placeholder: "e.g. 20.5",
    style: "width:100%;margin-bottom:6px;"
  });

  const sgInput = el("input", {
    id: "sgInput",
    type: "number",
    step: "0.0001",
    placeholder: "e.g. 1.083",
    style: "width:100%;margin-bottom:6px;"
  });

  const resultDiv = el("div", {
    id: "brixResult",
    style: "font-size:13px;color:var(--muted);"
  });


  const convertBrixToSG = () => {
    const brix = parseFloat(brixInput.value);
    if (isNaN(brix)) return (resultDiv.textContent = "⚠️ Enter a valid Brix value.");
    const sg = brixToSG(brix);
    sgInput.value = sg.toFixed(4);
    resultDiv.innerHTML = `<b>${brix.toFixed(2)} °Bx</b> = SG <b>${sg.toFixed(4)}</b>`;
  };

  const convertSGToBrix = () => {
    const sg = parseFloat(sgInput.value);
    if (isNaN(sg)) return (resultDiv.textContent = "⚠️ Enter a valid SG value.");
    const brix = sgToBrix(sg);
    brixInput.value = brix.toFixed(2);
    resultDiv.innerHTML = `SG <b>${sg.toFixed(4)}</b> = <b>${brix.toFixed(2)} °Bx</b>`;
  };

  const clearFields = () => {
    brixInput.value = "";
    sgInput.value = "";
    resultDiv.textContent = "";
  };


  const btnBrixToSG = el("button", {
    class: "btn-accent",
    text: "Brix → SG",
    style: "flex:1;",
    onclick: convertBrixToSG
  });
  const btnSGToBrix = el("button", {
    class: "btn-accent",
    text: "SG → Brix",
    style: "flex:1;",
    onclick: convertSGToBrix
  });
  const btnClear = el("button", {
    class: "btn-danger",
    text: "Clear",
    style: "flex:1;",
    onclick: clearFields
  });

  const buttonRow = el("div", {
    class: "row",
    style: "margin-top:8px;gap:8px;"
  }, [btnBrixToSG, btnSGToBrix, btnClear]);


  const body = el("div", {
    id: "brixContent",
    style: "margin-top:8px;"
  }, [
    el("p", {
      style: "font-size:13px;color:var(--muted);",
      text: "Convert between Brix and Specific Gravity using BrewersFriend formulas."
    }),
    el("label", { text: "Brix (°Bx):" }),
    brixInput,
    el("label", { text: "Specific Gravity (SG):" }),
    sgInput,
    buttonRow,
    el("hr", { style: "margin:10px 0;border:none;border-top:1px solid var(--border);" }),
    resultDiv
  ]);


  const legend = el("legend", {
    text: "🧮 Brix ↔ SG Converter",
    style: "cursor:pointer;",
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? "none" : "block";
      legend.textContent = (collapsed ? "▶ " : "▼ ") + "🧮 Brix ↔ SG Converter";
    }
  });


  const card = el("div", {
    id: "brixConverterCard",
    class: "fieldset collapsible",
    style: "margin-top:16px;"
  }, [legend, body]);

  collapsed = true;
  body.style.display = "none";

  return card;
}


function backupHeaderCard() {
  return el("div", {
    class: "fieldset",
    id: "backupHeader",
    style: `
      margin-top:16px;
      text-align:center;
      padding:10px 0;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    `
  }, [
    el("legend", {
      text: "💾 Backup & Restore",
      style: `
        color: var(--accent);
        font-weight: 700;
        font-size: 15px;
        letter-spacing: 0.5px;
      `
    })
  ]);
}


function syncCard() {
  let collapsed = true;


  const infoPara = el("p", {
    style: "font-size:13px;color:var(--muted);"
  }, [
    el("b", { text: "ExtendsClass JSON Storage" }),
    document.createTextNode(" (optional cloud backup)"),
    el("br"),
    document.createTextNode("• Make a free account at "),
    el("a", {
      href: "https://extendsclass.com/json-storage.html",
      target: "_blank",
      text: "extendsclass.com/json-storage"
    }),
    el("br"),
    document.createTextNode("• Copy your "),
    el("b", { text: "API key" }),
    document.createTextNode(" from your account."),
    el("br"),
    document.createTextNode("• Paste it below to enable cloud sync.")
  ]);


  const apiInput = el("input", {
    id: "apiKeyInput",
    type: "text",
    placeholder: "Paste your ExtendsClass API key here",
    value: localStorage.getItem("EXTENDS_API_KEY") || "",
    style: `
      width:100%;margin:6px 0;padding:6px;
      border-radius:8px;border:1px solid var(--border);
      background:#0f141b;color:var(--text);
    `
  });


const saveBtn = el("button", {
  id: "saveApiKeyBtn",
  class: "btn-accent",
  text: "Save API Key",
  style: "width:100%;",
onclick: async () => {
  const key = apiInput.value.trim();

  if (!key) {
    clearExtendsCredentials();
    EXTENDS_API_KEY = "";
    EXTENDS_BIN_ID = "";
    state.cloudEnabled = false;
    updateSyncCard();
    updateViewBinButton();
    syncStatus.textContent = "💾 Cloud sync disabled — now saving locally only.";
    console.log("💾 Cloud sync disabled — reverted to local-only mode.");
    alert("💾 Cloud sync disabled — now saving locally only.");
    return;
  }

  EXTENDS_API_KEY = key;
  localStorage.setItem("EXTENDS_API_KEY", EXTENDS_API_KEY);
  localStorage.setItem("EXTENDS_KEY", EXTENDS_KEY);
  state.cloudEnabled = true;
  syncStatus.textContent = "☁️ Cloud API key saved.";
  console.log("☁️ Cloud API key saved:", key);

  if (!EXTENDS_BIN_ID) {
    const existingBin = await getExistingBin();
    if (existingBin) {
      EXTENDS_BIN_ID = existingBin;
      localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
      console.log(`☁️ Using existing bin: ${EXTENDS_BIN_ID}`);
    } else {
      await createBin();
    }
  }

  updateViewBinButton();
  updateSyncCard();

  try {
    let cloudData = await cloudLoad();
    if (cloudData?.data?.batches) cloudData = cloudData.data;

    if (cloudData && cloudData.batches?.length) {
      console.log("☁️ Loaded cloud data after saving key:", cloudData);
      state = cloudData;
      save(state);
      render();
      alert("✅ API key saved — cloud data loaded successfully.");
    } else {
      console.log("☁️ Cloud empty — uploading local data to cloud.");
      await cloudSave(state);
      alert("✅ API key saved — local data uploaded to cloud.");
    }
  } catch (err) {
    console.warn("⚠️ Failed to load cloud data:", err);
    alert("⚠️ API key saved, but cloud load failed. Using local data for now.");
  }
}
});


const viewBtn = el("button", {
  id: "viewBinBtn",
  class: "btn-accent",
  text: "🔗 View Bin",
  style: "display:none;width:100%;margin-top:6px;",
  onclick: async (e) => {
    e.stopPropagation();
    const bin = localStorage.getItem("EXTENDS_BIN_ID");
    if (!bin) return alert("⚠️ No bin ID found yet.");

    try {
      const data = await cloudLoad();
      if (!data) return alert("⚠️ Could not load bin data.");


      const popup = window.open("", "binPopup", "width=700,height=600,resizable,scrollbars=yes");
      if (!popup) return alert("⚠️ Popup blocked. Please allow popups for this site.");


      popup.document.write(`
        <html>
          <head>
            <title>MeadTrics Cloud Bin – ${bin}</title>
            <style>
              body {
                background-color: #0f141b;
                color: #e4e9f0;
                font-family: monospace;
                padding: 16px;
                white-space: pre-wrap;
                overflow-wrap: anywhere;
              }
              h2 {
                font-family: system-ui, sans-serif;
                font-size: 16px;
                margin-top: 0;
                color: #ffd86b;
              }
              code {
                background: #1a2028;
                padding: 8px;
                display: block;
                border-radius: 8px;
                border: 1px solid #2a3340;
              }
            </style>
          </head>
          <body>
            <h2>Cloud Bin: ${bin}</h2>
            <code id="jsonArea">Loading...</code>
          </body>
        </html>
      `);
      popup.document.close();


      const jsonString = JSON.stringify(data, null, 2);
      popup.document.getElementById("jsonArea").textContent = jsonString;

      console.log("✅ Cloud bin opened in popup");
    } catch (err) {
      console.error("Failed to load bin:", err);
      alert("⚠️ Failed to open bin.\n" + err.message);
    }
  }
});



  const syncStatus = el("div", {
    id: "syncStatus",
    style: "margin-top:6px;color:var(--muted);font-size:13px;",
    text: "💾 Local-only mode"
  });

  const syncUrl = el("span", { id: "syncUrl", text: "Local only" });
  const syncKey = el("span", { id: "syncKey", text: "meadtracker" }); 

  const syncInfo = el("div", {
    id: "syncInfo",
    class: "tag",
    style: "display:block;word-break:break-all;"
  }, [
    el("b", { text: "Bin:" }), document.createTextNode(" "), syncUrl
  ]);

  const keyInfo = el("div", {
    class: "tag",
    style: "margin-top:4px;"
  }, [
    el("b", { text: "Security Key:" }), document.createTextNode(" "), syncKey
  ]);


  const body = el("div", {
    id: "syncContent",
    style: "margin-top:8px;"
  }, [
    infoPara,
    apiInput,
    saveBtn,
    viewBtn,
    syncStatus,
    el("hr", { style: "margin:10px 0;border:none;border-top:1px solid var(--border);" }),
    syncInfo,
    keyInfo
  ]);


  const legend = el("legend", {
    text: "☁️ Cloud Sync",
    style: "cursor:pointer;",
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? "none" : "block";
      legend.textContent = (collapsed ? "▶ " : "▼ ") + "☁️ Cloud Sync";
    }
  });


  const card = el("div", {
    id: "syncCard",
    class: "fieldset collapsible",
    style: "margin-top:16px;"
  }, [legend, body]);


  const hasAPI = localStorage.getItem("EXTENDS_API_KEY");
  const hasBIN = localStorage.getItem("EXTENDS_BIN_ID");
  if (hasAPI && hasBIN) {
    collapsed = false;
    body.style.display = "block";
    legend.textContent = "▼ ☁️ Cloud Sync";
  } else {
    collapsed = true;
    body.style.display = "none";
    legend.textContent = "▶ ☁️ Cloud Sync";
  }


  setTimeout(updateViewBinButton, 0);

  return card;
}

function renderApp() {
  const app = document.querySelector('.app');
  if (!app) {
    console.error('❌ No .app container found.');
    return;
  }

  app.innerHTML = '';


  const sidebar = el('aside', { class: 'sidebar card' });
  const content = el('section', { class: 'content' });
  app.append(sidebar, content);


  const header = el('header', { id: 'sidebarHeader' });
  const searchBox = el('div', { id: 'searchBox', class: 'search', style: 'padding: 12px;' });
  const batchList = el('div', { id: 'batchList', class: 'list' });
  sidebar.append(header, searchBox, batchList);


  const detail = el('div', { id: 'detail', class: 'detail card' });
  const footer = el('div', { class: 'footer card' });
  content.append(detail, footer);


  try {
    renderSidebarHeader();
    renderSearchBox();
    renderBatchList();
    renderDetail();
    renderFooterButtons();
  } catch (err) {
    console.error('⚠️ RenderApp sub-render error:', err);
  }
}


function renderContent() {
  const content = document.querySelector('.content');
  if (!content) return;


  content.innerHTML = '';


  const detail = el('div', { id: 'detail', class: 'detail card' });
  const footer = el('div', { class: 'footer card' });

  content.append(detail, footer);


  renderDetail();
  renderFooterButtons();
}

function renderSidebar() {
  const sidebar = document.querySelector('.sidebar');
  if (!sidebar) return;
  sidebar.innerHTML = ''; 


  const header = el('header', { id: 'sidebarHeader' });
  const searchBox = el('div', { id: 'searchBox', class: 'search', style: 'padding: 12px;' });
  const batchList = el('div', { id: 'batchList', class: 'list' });


  sidebar.append(header, searchBox, batchList);


  renderSidebarHeader();
  renderSearchBox();
  renderBatchList();
}


function renderSidebarHeader() {
  const header = document.getElementById("sidebarHeader");
  if (!header) return;
  header.innerHTML = "";


  const title = el("h1", { text: "MeadTrics" });


  const btnLabel = state.cloudEnabled ? "+ Cloud Batch" : "+ New";
const newBtn = el("button", {
  id: "newBatchBtn",
  class: "btn btn-accent",
  text: btnLabel,
  title: "Create a new mead batch",
  onclick: () => {
    // Instead of creating a blank batch, just show the new batch form
    selectedId = null;
    render(); // will trigger newBatchForm() in the detail panel
  }
});


  header.append(title, newBtn);
}

function renderFooterButtons() {
  const footer = document.querySelector('.footer');
  if (!footer) return;

  footer.innerHTML = '';


  const tagRow = el('div', { class: 'row' });

  const modeText = state.cloudEnabled
    ? '☁️ Cloud Sync Active'
    : '💾 Local-only (saved to your browser)';
  const abvFormula = state.abvFormula || '(OG − FG) × 131.25';
  const abvText = `ABV uses ${abvFormula}`;

  const modeTag = el('span', { class: 'tag', text: modeText });
  const abvTag = el('span', { class: 'tag', text: abvText });

  tagRow.append(modeTag, abvTag);


  const btnRow = el('div', { class: 'row', id: 'footerActions' });

  const hasData = state.batches && state.batches.length > 0;


  const exportBtn = el('button', {
    id: 'exportBtn',
    text: state.cloudEnabled ? 'Sync' : 'Export',
    title: state.cloudEnabled
      ? 'Sync your data with the cloud'
      : 'Export local backup',
    onclick: () => {
      if (state.cloudEnabled) {
        cloudSave(state);
      } else {
        exportData();
      }
    },
  });


  const importBtn = el('button', {
    id: 'importBtn',
    text: state.cloudEnabled ? 'Cloud Load' : 'Import',
    title: state.cloudEnabled
      ? 'Load from cloud storage'
      : 'Import a saved JSON file',
    onclick: () => importFile.click(),
  });


  let importFile = document.getElementById('importFile');
  if (!importFile) {
    importFile = el('input', {
      id: 'importFile',
      type: 'file',
      accept: 'application/json',
      style: 'display:none',
    });
    importFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        state = data;
        selectedId = state.batches[0]?.id || null;
        saveAll(state);
        render();
      } catch (err) {
        console.error('❌ Import failed:', err);
        alert('Import failed: ' + err.message);
      }
    });
    footer.insertBefore(importFile, footer.firstChild);
  }


  const clearBtn = el('button', {
    id: 'clearBtn',
    class: 'btn-danger',
    text: 'Clear All',
    title: 'Delete all saved batches',
    onclick: () => {
      if (confirm('⚠️ Clear all saved data? This cannot be undone.')) {
        clearAll();
      }
    },
  });

  exportBtn.disabled = !hasData;
  clearBtn.disabled = !hasData;

  btnRow.append(exportBtn, importBtn, clearBtn);


  footer.append(tagRow, btnRow);
}


function initFeedbackPopup() {

  document.getElementById('feedbackBtn')?.remove();
  document.getElementById('feedbackPopup')?.remove();

  const btn = el('button', {
    id: 'feedbackBtn',
    title: 'Send Feedback',
    class: 'icon-btn',
    text: '📝',
    onclick: () => popup.classList.remove('hidden')
  });


  const popup = el('div', { id: 'feedbackPopup', class: 'popup hidden' }, [
    el('div', { class: 'popup-content' }, [
      el('h3', { text: 'Send Feedback' }),
      el('textarea', {
        id: 'feedbackText',
        placeholder: 'Describe your idea, bug, or suggestion...',
        rows: '5'
      }),
      el('div', { class: 'popup-actions' }, [
        el('button', {
          id: 'feedbackSubmit',
          class: 'primary',
          text: 'Submit',
          onclick: async () => {
            const text = document.getElementById('feedbackText').value.trim();
            if (!text) return alert('Please enter your feedback first!');
            console.log('📝 Feedback submitted:', text);
            alert('Thanks for your feedback!');
            popup.classList.add('hidden');
            document.getElementById('feedbackText').value = '';
          }
        }),
        el('button', {
          id: 'feedbackCancel',
          class: 'secondary',
          text: 'Cancel',
          onclick: () => popup.classList.add('hidden')
        })
      ])
    ])
  ]);


  document.body.append(btn, popup);
}


initFeedbackPopup();


function exportData() {
  try {
    const dataStr = JSON.stringify(state, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'meadtrics_backup.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    URL.revokeObjectURL(url);
    console.log('✅ Exported MeadTrics data.');
  } catch (err) {
    console.error('❌ Export failed:', err);
    alert('Export failed: ' + err.message);
  }
}


function renderSearchBox() {
  const container = document.getElementById('searchBox');
  if (!container) return;

  container.innerHTML = ''; 

const placeholder = 'Search batches… (name or notes)';


  const input = el('input', {
    id: 'searchInput',
    type: 'text',
    placeholder,
    style: `
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0f141b;
      color: var(--text);
    `
  });


  input.addEventListener('input', () => {
    renderBatchList();
  });


  input.addEventListener('keydown', ev => {
    if (ev.key === 'Escape') {
      input.value = '';
      renderBatchList();
    }
  });

  container.append(input);
}


function render(highlightId = null) {

  const app = document.querySelector('.app');
  if (!app.children.length) renderApp();

  renderSidebarHeader();
  renderSearchBox();
  renderBatchList();
  renderDetail(highlightId);
  renderFooterButtons();
}


// === Mobile Sidebar Drawer System ===
function initMobileSidebar() {
  // Remove old instances if reloaded
  document.getElementById('sidebarToggle')?.remove();
  document.getElementById('sidebarDrawer')?.remove();
  document.getElementById('sidebarOverlay')?.remove();

  // Create core elements
  const toggleBtn = el('button', {
    id: 'sidebarToggle',
    'aria-label': 'Toggle menu',
    text: '☰'
  });
  const drawer = el('aside', { id: 'sidebarDrawer' });
  const overlay = el('div', { id: 'sidebarOverlay' });

  // Insert before .app so it's top-level
  const app = document.querySelector('.app');
  if (app) {
    document.body.insertBefore(toggleBtn, app);
    document.body.insertBefore(drawer, app);
    document.body.insertBefore(overlay, app);
  }

  // === Helper: attach open/close logic ===
  function attachDrawerListeners() {
    toggleBtn.onclick = () => {
      drawer.classList.toggle('open');
      overlay.classList.toggle('visible');
    };
    overlay.onclick = () => {
      drawer.classList.remove('open');
      overlay.classList.remove('visible');
    };
  }

  // === Helper: rebuild collapsible interactivity inside the drawer ===
  function reattachCollapsibles(target) {
    target.querySelectorAll('.fieldset.collapsible legend').forEach(legend => {
      legend.addEventListener('click', () => {
        const fs = legend.parentElement;
        fs.classList.toggle('collapsed');
        const content = Array.from(fs.children).find(c => c.tagName !== 'LEGEND');
        if (content)
          content.style.display = fs.classList.contains('collapsed') ? 'none' : 'block';
      });
    });
  }

  // === Render the sidebar content into the drawer ===
  const desktopSidebar = document.querySelector('.sidebar');
  if (desktopSidebar) {
    drawer.innerHTML = '';
    const tempSidebar = el('div', { class: 'sidebar-temp' });
    drawer.append(tempSidebar);
    renderSidebar(); // reuse your existing function
    const built = document.querySelector('.sidebar');
    if (built) drawer.innerHTML = built.innerHTML;
  }

  // Re-activate collapsibles and button logic
  reattachCollapsibles(drawer);
  attachDrawerListeners();

  // Return helpers for reuse (sync observer)
  return { attachDrawerListeners, reattachCollapsibles };
}

// Run after the app is rendered
document.addEventListener('DOMContentLoaded', () => {
  const { attachDrawerListeners, reattachCollapsibles } = initMobileSidebar();

  // Watch for sidebar changes and mirror into the drawer
  const sidebar = document.querySelector('.sidebar');
  if (sidebar) {
    const obs = new MutationObserver(() => {
      const drawer = document.getElementById('sidebarDrawer');
      if (drawer && sidebar) {
        drawer.innerHTML = sidebar.innerHTML;
        reattachCollapsibles(drawer);
        attachDrawerListeners();
      }
    });
    obs.observe(sidebar, { childList: true, subtree: true });
  }
});


function renderBatchList() {
  const list = document.getElementById('batchList');
  if (!list) return;


  list.innerHTML = '';


  const q = document.getElementById('searchInput').value.trim().toLowerCase();

  const sorted = [...state.batches]
    .sort((a, b) => new Date(b.startDate) - new Date(a.startDate))
    .filter(b =>
      !q ||
      b.name.toLowerCase().includes(q) ||
      (b.description || '').toLowerCase().includes(q)
    );

  const active = sorted.filter(b => !b.events.some(e => e.type === 'bottled'));
  const archived = sorted.filter(b => b.events.some(e => e.type === 'bottled'));


  const makeSection = (key, title, batches, emptyText) => {
    const isCollapsed = sidebarCollapse[key];
    const section = el('div', { class: 'fieldset', style: 'margin-bottom:12px;' });


    const header = el(
      'div',
      {
        class: 'row',
        style: `
          display:flex;
          align-items:center;
          justify-content:flex-start;
          gap:6px;
          cursor:pointer;
          user-select:none;
        `,
        onclick: () => {
          sidebarCollapse[key] = !sidebarCollapse[key];
          renderBatchList();
        }
      },
      [
        el('legend', { text: title }),
        el('span', {
          text: isCollapsed ? '▶' : '▼',
          style: 'font-size:14px;margin-left:4px;'
        })
      ]
    );

    section.append(header);

    if (isCollapsed) return section;


    if (!batches.length) {
      section.append(el('div', { class: 'empty', text: emptyText }));
      return section;
    }


    batches.forEach(b => {
      const item = el('div', { class: 'batch' });


      const nameEl = (() => {
        const nameDiv = el('div', {
          class: 'name',
          text: b.name,
          title: 'Click to rename batch'
        });
        nameDiv.style.cursor = 'pointer';
        nameDiv.addEventListener('click', e => {
          e.stopPropagation();
          const input = el('input', {
            type: 'text',
            value: b.name,
            class: 'wide',
            style: `
              font-size:13px;
              font-weight:600;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              border-radius:6px;
              padding:4px 6px;
            `
          });
          const commit = () => {
            const newName = input.value.trim();
            if (newName) b.name = newName;
            saveAll(state, b, ['name']);
            render();
          };
          input.addEventListener('blur', commit);
          input.addEventListener('keydown', ev => {
            if (ev.key === 'Enter') input.blur();
            if (ev.key === 'Escape') render();
          });
          nameDiv.replaceWith(input);
          input.focus();
          input.select();
        });
        return nameDiv;
      })();


      const delBtn = el('button', {
        text: '✕',
        class: 'btn-danger',
        title: 'Delete batch',
        onclick: e => {
          e.stopPropagation();
          if (!confirm(`Delete batch “${b.name}”? This cannot be undone.`)) return;
          const i = state.batches.indexOf(b);
          if (i >= 0) {
            state.batches.splice(i, 1);
            if (selectedId === b.id) selectedId = state.batches[0]?.id || null;
            saveAll(state);
            render();
          }
        }
      });

      const headerRow = el('div', {
        class: 'row',
        style: 'justify-content:space-between;align-items:center;'
      }, [nameEl, delBtn]);


      const latestSG = b.sgReadings?.length
        ? b.sgReadings[b.sgReadings.length - 1].sg
        : null;
      const abv = calcABV(b.og, latestSG);

      const bottledEvent = b.events.find(e => e.type === 'bottled');
      const maturityText = bottledEvent
        ? `🧭 Mature: ${formatMaturityDays(bottledEvent.date)}`
        : '';
      const fermentText =
        !bottledEvent && b.startDate
          ? `🧪 ${formatFermentationDays(b.startDate)}`
          : '';

      let sugarBreakText = '';
      if (!bottledEvent && b.og) {
        const target = calcSugarBreak(b.og);
        if (target) sugarBreakText = `🍯 1/3 Sugar Break: ${target}`;
      }

const metaText =
  `${fmt(b.startDate)} · OG ${b.og}` +
  (latestSG ? ` · FG ${latestSG}` : '') +
  (abv ? ` · ~${abv.toFixed(1)}% ABV` : '') +
  (fermentText ? `\n${fermentText}` : '') +
  (sugarBreakText ? `\n${sugarBreakText}` : '') +
  (maturityText ? `\n${maturityText}` : '');

const metaDiv = el('div', { class: 'meta', text: metaText });

// === 🏷️ Tag display under batch ===
const tagsRow = el('div', {
  class: 'row',
  style: 'flex-wrap:wrap;gap:4px;margin-top:4px;'
});

if (Array.isArray(b.tags) && b.tags.length > 0) {
  b.tags.forEach(tag => {
    const tagEl = el('span', {
      class: 'tag',
      text: tag,
      style: `
        font-size:11px;
        padding:2px 6px;
        border-color:#2f3b4b;
        background:#1a2028;
        color:var(--accent);
      `
    });
    tagsRow.append(tagEl);
  });
} else {
  tagsRow.append(el('span', {
    class: 'tag',
    text: 'No tags',
    style: 'opacity:0.5;font-size:11px;'
  }));
}

item.append(headerRow, metaDiv, tagsRow);
      item.classList.toggle('active', b.id === selectedId);

      item.addEventListener('click', () => {
        selectedId = b.id;
        render();
      });

      section.append(item);
    });

    return section;
  };


  const sidebarSections = [
    batchHeaderCard,
    () => makeSection('active', '🧪 Active Batches', active, 'No active batches.'),
    () => makeSection('archived', '🍾 Archived (Bottled)', archived, 'No bottled batches.'),
    utilitiesHeaderCard,
    tosnaCard,
    backsweetCard,
    dilutionCard,
    primingCard,
    stabilCard,
    brixCard,
    backupHeaderCard,
    syncCard
  ];


  for (const create of sidebarSections) {
    try {
      const node = create();
      if (node) list.append(node);
    } catch (err) {
      console.error('Sidebar section error:', err);
    }
  }

  initTosnaBindings();
}

function renderTagsSection(batch) {
  if (!Array.isArray(batch.tags)) batch.tags = [];

  const wrap = el("div", {
    class: "fieldset",
    style: "margin-top:16px;"
  }, [
    el("legend", { text: "🏷️ Tags", style: "font-weight:600;" })
  ]);

  const tagContainer = el("div", {
    class: "row",
    style: `
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    `
  });

  // Render current tags
  const renderTags = () => {
    tagContainer.innerHTML = "";
    if (batch.tags.length === 0) {
      tagContainer.append(el("span", {
        class: "tag",
        text: "No tags selected",
        style: "opacity:0.6;"
      }));
    } else {
      batch.tags.forEach(tag => {
        const t = el("span", {
          class: "tag",
          text: `❌ ${tag}`,
          style: `
            cursor:pointer;
            background:#1a2028;
            color:var(--accent);
            border-color:#2f3b4b;
          `,
          onclick: () => {
            batch.tags = batch.tags.filter(x => x !== tag);
            saveAll(state, batch, ["tags"]);
            render();
          }
        });
        tagContainer.append(t);
      });
    }

    // Add button to add new tags
    const addBtn = el("button", {
      class: "btn-accent",
      text: "+ Add Tag",
      style: "padding:3px 10px;font-size:12px;",
      onclick: openTagSelector
    });
    tagContainer.append(addBtn);
  };

  // Popup tag selector
  const openTagSelector = () => {
    const overlay = el("div", {
      class: "popup",
      style: "z-index:9999;"
    }, [
      el("div", { class: "popup-content" }, [
        el("h3", { text: "Select Tags" }),
        el("div", {
          style: `
            display:flex;
            flex-wrap:wrap;
            gap:6px;
            margin-bottom:10px;
          `
        }, TAGS.map(tag =>
          el("span", {
            class: "tag",
            text: tag,
            style: `
              cursor:pointer;
              background:${batch.tags.includes(tag) ? 'var(--accent)' : '#1a2028'};
              color:${batch.tags.includes(tag) ? '#fff' : 'var(--text)'};
            `,
            onclick: () => {
              if (batch.tags.includes(tag)) {
                batch.tags = batch.tags.filter(t => t !== tag);
              } else {
                batch.tags.push(tag);
              }
              saveAll(state, batch, ["tags"]);
              render();
            }
          })
        )),
        el("div", { class: "popup-actions" }, [
          el("button", {
            class: "secondary",
            text: "Close",
            onclick: () => overlay.remove()
          })
        ])
      ])
    ]);
    document.body.append(overlay);
  };

  wrap.append(tagContainer);
  renderTags();
  return wrap;
}

function renderDetail() {
  const root = document.getElementById('detail');
  if (!root) return;

  const batch = state.batches.find(b => b.id === selectedId);

  if (!batch) {
    root.innerHTML = '';
    root.append(newBatchForm());
    return;
  }

  root.innerHTML = '';

  const titleRow = (() => {
    const row = el('div', {
      class: 'row',
      style: 'justify-content: space-between; align-items: center;'
    });

    const title = el('h2', {
      text: batch.name,
      title: 'Click to rename batch'
    });
    title.style.cursor = 'pointer';
    title.addEventListener('click', () => {
      const input = el('input', {
        type: 'text',
        value: batch.name,
        class: 'wide',
        style: `
          font-size:20px;
          font-weight:700;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
          border-radius:8px;
          padding:6px 10px;
        `
      });

      const commit = () => {
        const newName = input.value.trim();
        if (newName) batch.name = newName;
        saveAll(state, batch, ['name']);
        render();
      };

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') input.blur();
        if (e.key === 'Escape') render();
      });

      title.replaceWith(input);
      input.focus();
      input.select();
    });

    const dupBtn = el('button', {
      text: '🔁 Duplicate',
      class: 'btn-accent',
      title: 'Duplicate this batch',
      style: 'padding:4px 10px;font-size:13px;',
      onclick: () => {
        if (!confirm(`Duplicate batch “${batch.name}”?`)) return;
        const today = new Date().toISOString().slice(0, 10);
        const id = crypto.randomUUID();
        const clone = {
          id,
          name: batch.name + ' (Copy)',
          startDate: today,
          og: batch.og,
          honey: batch.honey,
          yeast: batch.yeast,
          volume: batch.volume,
          description: batch.description,
          sgReadings: [],
          events: [{ date: today, type: 'primary fermentation' }],
          ingredients: JSON.parse(JSON.stringify(batch.ingredients || []))
        };
        state.batches.push(clone);
        selectedId = id;
        saveAll(state);
        render();
        alert(`Batch “${batch.name}” duplicated as “${clone.name}”.`);
      }
    });

    const labelBtn = el('button', {
      text: '🖨️ Label Maker',
      class: 'btn-accent',
      title: 'Generate a printable bottle label',
      style: 'padding:4px 10px;font-size:13px;',
      onclick: () => openLabelMaker(batch)
    });

    row.append(title, dupBtn, labelBtn);
    return row;
  })();

  const summarySection = (() => {
    const sugarBreak = calcSugarBreak(batch.og);

    let currentSG = null;
    if (Array.isArray(batch.sgReadings) && batch.sgReadings.length > 0) {
      const last = batch.sgReadings[batch.sgReadings.length - 1];
      currentSG = typeof last === 'object' ? last.sg : last;
    }

    const abv = calcABV(batch.og, currentSG);
    console.log('Current SG reading for', batch.name, ':', currentSG, batch.sgReadings);

    const textParts = [];
    if (batch.startDate) textParts.push(`Started ${fmt(batch.startDate)}`);
    if (batch.og) textParts.push(`OG ${batch.og}`);
    if (currentSG) textParts.push(`SG ${currentSG}`);
    if (abv) textParts.push(`ABV ${abv.toFixed(1)}%`);
    if (sugarBreak) textParts.push(`1/3 Break: ${sugarBreak}`);

    const metaLine = el('div', { text: textParts.join(' · ') });
    const honeyLine = el('div', {
      class: 'meta',
      text:
        `${batch.honey ? 'Honey: ' + batch.honey + ' · ' : ''}` +
        `${batch.yeast ? 'Yeast: ' + batch.yeast + ' · ' : ''}` +
        `${batch.volume ? 'Volume: ' + batch.volume + 'L' : ''}`
    });

    return el('div', {}, [metaLine, honeyLine]);
  })();

const components = [
  chartCard(batch),
  sgFormCard(batch),
  eventFormCard(batch),
  ingredientsTable(batch),
  renderTagsSection(batch),
  eventsTable(batch)
];

  const container = el('div', {}, [titleRow, summarySection, ...components]);
  root.append(container);

  drawChart(batch);
}




function chartCard(batch) {
  return el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [

    el('legend', {
      text: '📈 Gravity & ABV Over Time',
      style: 'font-weight:600;'
    }),

    el('div', {
      class: 'row',
      style: `
        justify-content: space-between;
        align-items: center;
        margin-bottom:8px;
      `
    }, [
      el('span', {
        id: 'chartModeLabel',
        text: chartMode === 'sg'
          ? 'Showing Specific Gravity'
          : 'Showing ABV (%)',
        style: 'font-size:13px;color:var(--muted);'
      }),
      el('button', {
        id: 'chartModeToggle',
        class: 'btn-accent',
        text: chartMode === 'sg' ? 'Switch to ABV' : 'Switch to SG',
        style: 'padding:3px 10px;font-size:12px;',
        onclick: () => {
          chartMode = chartMode === 'sg' ? 'abv' : 'sg';
          render();
        }
      })
    ]),

    el('canvas', {
      id: 'sgChart',
      width: 800,
      height: 260,
      style: `
        width:100%;
        max-width:800px;
        border-radius:8px;
        background:#0f141b;
        box-shadow:var(--shadow);
      `
    })
  ]);
}


function sgFormCard(batch) {

  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: '📏 Add Specific Gravity Reading',
      style: 'font-weight:600;'
    })
  ]);


  const form = el('div', {
    class: 'grid',
    style: 'gap:8px;'
  }, [

    el('div', { class: 'col-6' }, [
      el('label', { text: 'Date' }),
      el('input', {
        id: 'sgDate',
        type: 'date',
        value: new Date().toISOString().slice(0, 10),
        style: `
          width:100%;
          border-radius:6px;
          padding:6px;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
        `
      })
    ]),


    el('div', { class: 'col-6' }, [
      el('label', { text: 'Specific Gravity (SG)' }),
      el('input', {
        id: 'sgValue',
        type: 'number',
        step: '0.001',
        min: '0.800',
        max: '1.500',
        placeholder: 'e.g. 1.045',
        style: `
          width:100%;
          border-radius:6px;
          padding:6px;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
        `
      })
    ])
  ]);


  const addBtn = el('button', {
    class: 'btn-accent',
    text: 'Add Reading',
    style: 'margin-top:10px;width:100%;',
    onclick: () => {
      const date = form.querySelector('#sgDate').value;
      const sgNum = parseFloat(form.querySelector('#sgValue').value);

      if (!date || !isFinite(sgNum)) {
        alert('Please enter a valid date and SG value.');
        return;
      }

      const sgStr = sgNum.toFixed(3);
      const sgId = crypto.randomUUID();


      batch.sgReadings.push({ id: sgId, date, sg: sgStr });
      batch.sgReadings.sort((a, b) => new Date(a.date) - new Date(b.date));


      batch.events.push({
        date,
        type: 'added sg reading',
        sg: sgStr,
        sgId,
        note: `SG: ${sgStr}`
      });

      saveAll(state, batch, ['sgReadings', 'events']);
      render();
    }
  });


  card.append(form, addBtn);
  return card;
}



function eventFormCard(batch) {
  const today = new Date().toISOString().slice(0, 10);


  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: '🗓️ Add Event',
      style: 'font-weight:600;'
    })
  ]);

  const grid = el('div', {
    class: 'grid',
    style: 'gap:8px;'
  });

  const dateInput = el('input', {
    id: 'evDate',
    type: 'date',
    value: today,
    style: `
      width:100%;
      border-radius:6px;
      padding:6px;
      border:1px solid var(--border);
      background:#0f141b;
      color:var(--text);
    `
  });
  const dateCol = el('div', { class: 'col-6' }, [
    el('label', { for: 'evDate', text: 'Date' }),
    dateInput
  ]);

  const typeSelect = (() => {
    const sel = el('select', {
      id: 'evType',
      style: `
        width:100%;
        border-radius:6px;
        padding:6px;
        border:1px solid var(--border);
        background:#0f141b;
        color:var(--text);
      `
    });
    [...EVENTS, 'note'].forEach(e =>
      sel.append(el('option', { value: e, text: e }))
    );
    return sel;
  })();

  const typeCol = el('div', { class: 'col-6' }, [
    el('label', { for: 'evType', text: 'Event Type' }),
    typeSelect
  ]);

  const noteWrap = el('div', {
    class: 'col-12',
    id: 'noteWrap',
    style: 'display:none;'
  }, [
    el('label', { for: 'evNote', text: 'Note Text' }),
    el('textarea', {
      id: 'evNote',
      placeholder: 'Write a note about this batch...',
      style: `
        width:100%;
        min-height:60px;
        border-radius:6px;
        padding:6px;
        border:1px solid var(--border);
        background:#0f141b;
        color:var(--text);
        resize:vertical;
      `
    })
  ]);


  const addBtn = el('button', {
    class: 'btn-accent',
    text: 'Add Event',
    style: 'width:100%;margin-top:8px;',
    onclick: () => {
      const date = dateInput.value;
      const type = typeSelect.value;
      const note = card.querySelector('#evNote')?.value.trim() || '';

      if (!date || !type) {
        alert('Please choose a date and event.');
        return;
      }

      const ev = { date, type };
      if (type === 'note' && note) ev.note = note;

      batch.events.push(ev);
      saveAll(state, batch, ['events']);
      render();


      if (ev.type === 'bottled') {

      }
    }
  });

  const btnRow = el('div', { class: 'col-12' }, [addBtn]);


  grid.append(dateCol, typeCol, noteWrap, btnRow);
  card.append(grid);


  typeSelect.addEventListener('change', () => {
    noteWrap.style.display = typeSelect.value === 'note' ? 'block' : 'none';
  });

  return card;
}


function eventsTable(batch) {

  const card = el("div", {
    class: "fieldset",
    style: "margin-top:16px;"
  }, [
    el("legend", {
      text: "📜 Events & Notes",
      style: "font-weight:600;"
    })
  ]);


  const table = el("table", {
    class: "table",
    style: `
      width:100%;
      border-collapse:collapse;
      border:1px solid var(--border);
      border-radius:8px;
      overflow:hidden;
      font-size:13px;
    `
  });


  const thead = el("thead", {}, [
    el("tr", {}, [
      el("th", { text: "Date" }),
      el("th", { text: "Event Type" }),
      el("th", { text: "Note / SG" }),
      el("th", { text: "" }) 
    ])
  ]);

  const tbody = el("tbody");


  batch.events
    .slice()
    .sort((a, b) => new Date(a.date) - new Date(b.date))
    .forEach(ev => {
      const tr = el("tr", {}, []);
      tr.dataset.type = ev.type;


      const dateCell = el("td", { text: fmt(ev.date) });


      const typeCell = el("td", { text: ev.type });


      const noteCell = (() => {
        const td = el("td");
        if (ev.type === "note") {
			const textarea = el("textarea", {
			  style: `
				width:100%;
				min-height:28px;
				border-radius:6px;
				padding:4px;
				border:1px solid var(--border);
				background:#0f141b;
				color:var(--text);
				resize:vertical;
			  `,
			  oninput: e => {
				ev.note = e.target.value;
				saveAll(state, batch, ["events"]);
			  }
			});
			textarea.value = ev.note || "";
			td.append(textarea);
        } else if (ev.type === "added sg reading") {
          const sgSpan = el("span", {
            text: `SG: ${ev.sg}`,
            title: "Double-click to edit SG reading",
            style: "cursor:pointer;"
          });

          sgSpan.addEventListener("dblclick", () => {
            const input = el("input", {
              type: "number",
              step: "0.001",
              min: "0.800",
              max: "1.500",
              value: ev.sg,
              style: `
                width:80px;
                border-radius:6px;
                padding:4px;
                border:1px solid var(--border);
                background:#0f141b;
                color:var(--text);
              `
            });

            const commit = () => {
              const newVal = parseFloat(input.value);
              if (!isFinite(newVal)) return render();
              const sgStr = newVal.toFixed(3);
              ev.sg = sgStr;
              ev.note = `SG: ${sgStr}`;


              if (ev.sgId) {
                const r = batch.sgReadings.find(x => x.id === ev.sgId);
                if (r) r.sg = sgStr;
              } else {
                const r = batch.sgReadings.find(x => x.date === ev.date);
                if (r) r.sg = sgStr;
              }

              saveAll(state, batch, ["sgReadings", "events"]);
              render();
            };

            input.addEventListener("blur", commit);
            input.addEventListener("keydown", e => {
              if (e.key === "Enter") input.blur();
              if (e.key === "Escape") render();
            });

            sgSpan.replaceWith(input);
            input.focus();
            input.select();
          });

          td.append(sgSpan);
        } else {
          td.textContent =
            ev.note ||
            (ev.sg ? `SG: ${ev.sg}` : "") ||
            ev.type;
        }
        return td;
      })();


      const delCell = el("td", {}, [
        el("button", {
          text: "✕",
          class: "btn-danger",
          title: "Delete event",
          style: "padding:2px 6px;font-size:12px;",
          onclick: () => {
            const i = batch.events.indexOf(ev);
            if (i >= 0) {
              batch.events.splice(i, 1);


              if (ev.type === "added sg reading") {
                if (ev.sgId) {
                  const idx = batch.sgReadings.findIndex(r => r.id === ev.sgId);
                  if (idx >= 0) batch.sgReadings.splice(idx, 1);
                } else {
                  const evSg = ev.sg || (ev.note && ev.note.match(/([\d.]+)/)?.[1]);
                  const idx = batch.sgReadings.findIndex(r =>
                    r.date === ev.date &&
                    Math.abs(parseFloat(r.sg) - parseFloat(evSg)) < 0.00051
                  );
                  if (idx >= 0) batch.sgReadings.splice(idx, 1);
                }
              }

              saveAll(state, batch, ["sgReadings", "events"]);
              render();
            }
          }
        })
      ]);

      tr.append(dateCell, typeCell, noteCell, delCell);
      tbody.append(tr);
    });

  table.append(thead, tbody);
  card.append(table);

  return card;
}


function ingredientsTable(batch) {

  if (!batch.ingredients) batch.ingredients = [];


  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: '🍯 Ingredients',
      style: 'font-weight:600;'
    })
  ]);


  const table = el('table', {
    class: 'table',
    style: `
      width:100%;
      border-collapse:collapse;
      border:1px solid var(--border);
      border-radius:8px;
      overflow:hidden;
      font-size:13px;
    `
  });


  const thead = el('thead', {}, [
    el('tr', {}, [
      el('th', { text: 'Honey (kg)' }),
      el('th', { text: 'Sugar (kg)' }),
      el('th', { text: 'Water (L)' }),
      el('th', { text: 'Additives' }),
      el('th', { text: '' })
    ])
  ]);

  const tbody = el('tbody');


  batch.ingredients.forEach(ing => {
    const tr = el('tr', {}, []);

    ['honey', 'sugar', 'water', 'additives'].forEach(key => {
      const td = el('td');
      const input = el('input', {
        type: key === 'additives' ? 'text' : 'number',
        step: '0.1',
        value: ing[key] ?? '',
        style: `
          width:100%;
          border-radius:6px;
          padding:4px;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
        `,
        oninput: e => {
          ing[key] = key === 'additives'
            ? e.target.value
            : parseFloat(e.target.value) || '';
          saveAll(state, batch, ['ingredients']);
        }
      });
      td.append(input);
      tr.append(td);
    });


    const delBtn = el('button', {
      text: '✕',
      class: 'btn-danger',
      title: 'Delete ingredient row',
      style: 'padding:2px 6px;font-size:12px;',
      onclick: () => {
        const i = batch.ingredients.indexOf(ing);
        if (i >= 0) batch.ingredients.splice(i, 1);
        saveAll(state, batch, ['ingredients']);
        render();
      }
    });

    tr.append(el('td', {}, [delBtn]));
    tbody.append(tr);
  });

  table.append(thead, tbody);


  const addRowBtn = el('button', {
    text: '+ Add Ingredient',
    class: 'btn-accent',
    style: 'margin-top:10px;width:100%;',
    onclick: () => {
      batch.ingredients.push({
        honey: '',
        sugar: '',
        water: '',
        additives: ''
      });
      saveAll(state, batch, ['ingredients']);
      render();
    }
  });

  card.append(table, addRowBtn);
  return card;
}

function newBatchForm() {
  const today = new Date().toISOString().slice(0, 10);


  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: '✨ Create New Batch',
      style: 'font-weight:600;'
    })
  ]);

  const inputStyle = `
    width:100%;
    border-radius:6px;
    padding:6px;
    border:1px solid var(--border);
    background:#0f141b;
    color:var(--text);
    margin-bottom:8px;
  `;


  const basicInfo = el('div', {}, [
    el('label', { text: 'Name' }),
    el('input', { id: 'bName', type: 'text', placeholder: 'e.g. Bochet #3', style: inputStyle }),

    el('label', { text: 'Start Date' }),
    el('input', { id: 'bDate', type: 'date', value: today, style: inputStyle }),

    el('label', { text: 'Original Gravity (OG)' }),
    el('input', {
      id: 'bOG',
      type: 'number',
      step: '0.001',
      min: '0.900',
      max: '1.500',
      placeholder: 'e.g. 1.100',
      style: inputStyle
    }),

    el('label', { text: 'Honey Type' }),
    el('input', { id: 'bHoney', type: 'text', placeholder: 'e.g. Wildflower, Clover, Orange Blossom', style: inputStyle }),

    el('label', { text: 'Yeast Strain' }),
    el('input', { id: 'bYeast', type: 'text', placeholder: 'e.g. Lalvin D47, EC-1118', style: inputStyle }),

    el('label', { text: 'Volume (L)' }),
    el('input', { id: 'bVolume', type: 'number', step: '0.1', min: '0.1', placeholder: 'e.g. 5.0', style: inputStyle })
  ]);


  const ingSet = el('div', {
    class: 'fieldset',
    style: 'margin-top:10px;'
  }, [
    el('legend', { text: '🍯 Ingredients (optional)', style: 'font-weight:600;' }),
    el('div', { class: 'grid', style: 'gap:8px;' }, [
      el('div', { class: 'col-4' }, [
        el('label', { text: 'Honey (kg)' }),
        el('input', { id: 'bHoneyWeight', type: 'number', step: '0.1', placeholder: 'e.g. 2.5', style: inputStyle })
      ]),
      el('div', { class: 'col-4' }, [
        el('label', { text: 'Sugar (kg)' }),
        el('input', { id: 'bSugar', type: 'number', step: '0.1', placeholder: 'optional', style: inputStyle })
      ]),
      el('div', { class: 'col-4' }, [
        el('label', { text: 'Water (L)' }),
        el('input', { id: 'bWater', type: 'number', step: '0.1', placeholder: 'e.g. 4.5', style: inputStyle })
      ]),
      el('div', { class: 'col-12' }, [
        el('label', { text: 'Additives (fruit, spices)' }),
        el('input', { id: 'bAdditives', type: 'text', placeholder: 'e.g. orange peel, cinnamon, vanilla bean', style: inputStyle })
      ])
    ])
  ]);


  const desc = el('div', { style: 'margin-top:10px;' }, [
    el('label', { text: 'Description / Notes' }),
    el('textarea', {
      id: 'bDesc',
      placeholder: 'Optional notes about this batch...',
      style: `
        ${inputStyle}
        min-height:80px;
        resize:vertical;
      `
    })
  ]);


  const createBtn = el('button', {
    class: 'btn-accent',
    text: 'Create Batch',
    style: 'margin-top:10px;width:100%;',
    onclick: () => {
      const name = card.querySelector('#bName').value.trim();
      const startDate = card.querySelector('#bDate').value;
      const og = parseFloat(card.querySelector('#bOG').value);
      const honey = card.querySelector('#bHoney').value.trim();
      const yeast = card.querySelector('#bYeast').value.trim();
      const volume = parseFloat(card.querySelector('#bVolume').value);
      const description = card.querySelector('#bDesc').value.trim();

      const honeyWeight = parseFloat(card.querySelector('#bHoneyWeight').value);
      const sugar = parseFloat(card.querySelector('#bSugar').value);
      const water = parseFloat(card.querySelector('#bWater').value);
      const additives = card.querySelector('#bAdditives').value.trim();

      if (!name || !startDate || !isFinite(og)) {
        alert('Please fill in name, date, and OG.');
        return;
      }

      const id = crypto.randomUUID();
      const batch = {
        id,
        name,
        startDate,
        og: og.toFixed(3),
        honey,
        yeast,
        volume: isFinite(volume) ? volume.toFixed(1) : null,
        description,
        sgReadings: [],
        events: [{ date: startDate, type: 'primary fermentation' }],
        ingredients: [],
		tags: [] // ✅ add this line
      };


      if (isFinite(honeyWeight) || isFinite(sugar) || isFinite(water) || additives) {
        batch.ingredients.push({
          honey: isFinite(honeyWeight) ? honeyWeight.toFixed(1) : '',
          sugar: isFinite(sugar) ? sugar.toFixed(1) : '',
          water: isFinite(water) ? water.toFixed(1) : '',
          additives
        });
      }

      state.batches.push(batch);
      selectedId = id;
      saveAll(state);
      render();
    }
  });

  card.append(basicInfo, ingSet, desc, createBtn);
  return card;
}


function calcSugarBreak(og) {
  const ogNum = parseFloat(og);
  if (!isFinite(ogNum) || ogNum < 0.9 || ogNum > 1.5) return null;
  const sgBreak = 1 + (ogNum - 1) / 3;
  return sgBreak.toFixed(3);
}


function calcABV(og, fg) {
  if (!og || !fg) return null;
  const OG = parseFloat(og), FG = parseFloat(fg);
  if (!isFinite(OG) || !isFinite(FG)) return null;
  return (OG - FG) * 131.25;
}

function formatMaturityDays(bottledDate) {
  const diffMs = Date.now() - new Date(bottledDate).getTime();
  const days = Math.floor(diffMs / 86400000);

  if (isNaN(days)) return 'Unknown age';
  if (days < 0) return 'Future date';
  if (days === 0) return 'Bottled today';
  if (days === 1) return '1 day old';
  if (days < 7) return `${days} days old`;

  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `${weeks} week${weeks !== 1 ? 's' : ''} old`;

  const months = Math.floor(days / 30.44);
  const remainingDays = Math.round(days - months * 30.44);
  const extraWeeks = Math.floor(remainingDays / 7);

  let result = `${months} month${months !== 1 ? 's' : ''}`;
  if (extraWeeks >= 1) result += ` ${extraWeeks} wk`;
  return result + ' old';
}

function formatFermentationDays(startDate) {
  const diffMs = Date.now() - new Date(startDate).getTime();
  const days = Math.floor(diffMs / 86400000);

  if (isNaN(days)) return 'Unknown start date';
  if (days < 0) return 'Future start date';
  if (days === 0) return 'Started today';
  if (days === 1) return 'Fermenting for 1 day';
  if (days < 7) return `Fermenting for ${days} days`;

  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `Fermenting for ${weeks} week${weeks !== 1 ? 's' : ''}`;

  const months = Math.floor(days / 30.44);
  const remainingDays = Math.round(days - months * 30.44);
  const extraWeeks = Math.floor(remainingDays / 7);

  let result = `Fermenting for ${months} month${months !== 1 ? 's' : ''}`;
  if (extraWeeks >= 1) result += ` ${extraWeeks} wk`;
  return result;
}

function drawChart(batch) {
  const c = document.getElementById('sgChart');
  if (!c) return;

  const ctx = c.getContext('2d');
  const pad = { l: 45, r: 10, t: 10, b: 28 };

  const dpr = window.devicePixelRatio || 1;
  const logicalW = 800;
  const logicalH = 260;
  c.width = logicalW * dpr;
  c.height = logicalH * dpr;
  c.style.width = logicalW + 'px';
  c.style.height = logicalH + 'px';
  ctx.scale(dpr, dpr);

  const readings = (batch.sgReadings || [])
    .slice()
    .sort((a, b) => new Date(a.date) - new Date(b.date));

  if (!readings.length || readings[0].date !== batch.startDate)
    readings.unshift({ date: batch.startDate, sg: batch.og });
  if (!readings.length) return;

  const points = readings.map(r => ({
    x: new Date(r.date).getTime(),
    y: chartMode === 'sg' ? parseFloat(r.sg) : calcABV(batch.og, r.sg),
    date: r.date,
    sg: parseFloat(r.sg)
  }));

  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  let minY = Math.min(...ys);
  let maxY = Math.max(...ys);

  const sugarBreak = calcSugarBreak(batch.og);
  if (sugarBreak) {
    const sb = parseFloat(sugarBreak);
    const val = chartMode === 'sg' ? sb : calcABV(batch.og, sugarBreak);
    minY = Math.min(minY, val - 0.002);
    maxY = Math.max(maxY, val + 0.002);
  }

  if (chartMode === 'sg') {
    minY = Math.max(0.98, minY - 0.005);
    maxY = Math.min(1.15, maxY + 0.005);
  } else {
    minY = Math.max(0, minY - 0.5);
    maxY += 0.5;
  }

  const W = logicalW - pad.l - pad.r;
  const H = logicalH - pad.t - pad.b;
  const xScale = v => pad.l + (W * (v - minX)) / Math.max(1, maxX - minX);
  const yScale = v => pad.t + H - (H * (v - minY)) / Math.max(0.0001, maxY - minY);

  points.forEach(p => {
    p.xx = xScale(p.x);
    p.yy = yScale(p.y);
  });

  let tooltip = document.getElementById('chart-tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'chart-tooltip';
    tooltip.className = 'chart-tooltip';
    tooltip.style.display = 'none';
    c.parentElement.style.position = 'relative';
    c.parentElement.appendChild(tooltip);
  }

  const renderBase = (highlight = null) => {
    ctx.clearRect(0, 0, logicalW, logicalH);
    ctx.save();


    ctx.strokeStyle = '#2a3340';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + H);
    ctx.lineTo(pad.l + W, pad.t + H);
    ctx.stroke();


    ctx.fillStyle = '#8fa3bd';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'right';
    const step = chartMode === 'sg' ? 0.005 : Math.max(0.5, (maxY - minY) / 8);
    for (let y = minY; y <= maxY; y += step) {
      const yy = yScale(y);
      ctx.fillText(chartMode === 'sg' ? y.toFixed(3) : y.toFixed(1), pad.l - 6, yy + 3);
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.beginPath();
      ctx.moveTo(pad.l, yy);
      ctx.lineTo(pad.l + W, yy);
      ctx.stroke();
    }


    ctx.textAlign = 'center';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const x = minX + (i * (maxX - minX)) / ticks;
      const xx = xScale(x);
      ctx.fillText(new Date(x).toLocaleDateString(), xx, pad.t + H + 20);
    }


    ctx.strokeStyle = chartMode === 'sg' ? '#82cfff' : '#b5e08a';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    points.forEach((p, i) => (i ? ctx.lineTo(p.xx, p.yy) : ctx.moveTo(p.xx, p.yy)));
    ctx.stroke();


    if (sugarBreak) {
      const breakValue =
        chartMode === 'sg'
          ? parseFloat(sugarBreak)
          : calcABV(batch.og, sugarBreak);
      if (breakValue >= minY && breakValue <= maxY) {
        const yBreak = yScale(breakValue);
        const latestSG =
          batch.sgReadings?.length &&
          parseFloat(batch.sgReadings[batch.sgReadings.length - 1].sg);
        const reached = latestSG && latestSG <= parseFloat(sugarBreak);

        ctx.save();
        ctx.beginPath();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.lineWidth = 1.2;
        ctx.moveTo(pad.l, yBreak);
        ctx.lineTo(pad.l + W, yBreak);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.beginPath();
        ctx.arc(pad.l + W - 8, yBreak, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('1/3 Break', pad.l + 8, yBreak - 6);
        ctx.restore();
      }
    }


    points.forEach((p, i) => {
      ctx.beginPath();
      if (i === 0) {
        ctx.fillStyle = '#ffd966';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui';
        ctx.fillStyle = '#ccc';
        ctx.fillText('OG', p.xx + 12, p.yy + 4);
      } else {
        ctx.fillStyle = chartMode === 'sg' ? '#b5e08a' : '#82cfff';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    if (highlight) {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.arc(highlight.xx, highlight.yy, 7, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  };

  renderBase();


  const radius = 14;
  c.onmousemove = evt => {
    const rect = c.getBoundingClientRect();
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    const mx = (evt.clientX - rect.left) * scaleX / dpr;
    const my = (evt.clientY - rect.top) * scaleY / dpr;

    let nearest = null;
    let minDist = radius;
    for (const p of points) {
      const dx = p.xx - mx;
      const dy = p.yy - my;
      const dist = Math.sqrt(dx * dx + dy * dy * 0.6);
      if (dist < minDist) {
        nearest = p;
        minDist = dist;
      }
    }

    if (nearest) {
      renderBase(nearest);
      tooltip.style.display = 'block';


      const left = nearest.xx / dpr + 12;
      const top = nearest.yy / dpr - 28;
      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;

      const dateLabel = new Date(nearest.x).toLocaleDateString();
      const valueLabel =
        chartMode === 'sg'
          ? `SG: ${nearest.sg?.toFixed(3) ?? '—'}`
          : `ABV: ${nearest.y?.toFixed(1) ?? '—'}%`;
      const sugarLabel = sugarBreak
        ? `<div style="color:#ffaa33;">1/3 Break: ${sugarBreak}</div>`
        : '';

      tooltip.innerHTML = `
        <div><b>${dateLabel}</b></div>
        <div>${valueLabel}</div>
        ${sugarLabel}
      `;
    } else {
      tooltip.style.display = 'none';
      renderBase();
    }
  };

  c.onmouseleave = () => {
    tooltip.style.display = 'none';
    renderBase();
  };
} 





$('#newBatchBtn')?.addEventListener('click', () => {
  selectedId = null;
  render();
});


$('#searchInput')?.addEventListener('input', () => renderBatchList());


$('#clearBtn')?.addEventListener('click', () => {
  if (!confirm('⚠️ Delete ALL MeadTrics data? This cannot be undone.')) return;
  state = { batches: [] };
  selectedId = null;
  saveAll(state);
  render();
});


$('#exportBtn')?.addEventListener('click', () => {
  try {
    const blob = new Blob([JSON.stringify(state, null, 2)], {
      type: 'application/json'
    });
    const url = URL.createObjectURL(blob);
    const a = el('a', { href: url, download: 'meadtrics-data.json' });
    document.body.append(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error('Export failed:', err);
    alert('Export failed. Check console for details.');
  }
});

function openLabelMaker(batch) {
  const existing = document.getElementById('labelModal');
  if (existing) existing.remove();

  const escapeHTML = s => String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

  const date = batch.startDate ? new Date(batch.startDate).toLocaleDateString() : '—';
  const lastReading = (batch.sgReadings && batch.sgReadings.length)
    ? batch.sgReadings[batch.sgReadings.length - 1]
    : null;

  const OG = parseFloat(batch.og);
  const FG = lastReading ? parseFloat(lastReading.sg) : NaN;
  const abv = (isFinite(OG) && isFinite(FG))
    ? ((OG - FG) * 131.25).toFixed(1) + '%'
    : '–';
  const honey = batch.honey || 'Mixed Blossom';

  // 🧩 Create modal structure
  const modal = el('div', { id: 'labelModal', class: 'modal-overlay' }, [
    el('div', { class: 'modal-content card' }, [
      el('div', { class: 'label-preview', id: 'labelPreview', style: 'position:relative;' }, [
        el('h1', {
          text: batch.name,
          style: 'text-align:center;font-size:20pt;margin:0;'
        }),
        el('p', {
          text: `${honey} Mead`,
          style: 'text-align:center;margin:2mm 0;'
        }),
        el('hr', {
          style: 'border:none;border-top:1px solid #8b6b2c;margin:2mm 0;'
        }),
        el('p', { text: `Batch: ${batch.name}` }),
        el('p', { text: `Start: ${date}` }),
        el('p', { text: `ABV: ${abv}` }),

        // 🧩 QR placeholder (auto-filled below)
        el('div', {
          id: 'qrContainer',
          style: 'width:80px;height:80px;margin:6mm auto 0 auto;'
        })
      ]),
      el('div', { class: 'row', style: 'justify-content:center;gap:8px;margin-top:10px;' }, [
        el('button', {
          id: 'printLabel',
          text: '🖨️ Print Label',
          class: 'btn-accent',
          onclick: () => window.print()
        }),
        el('button', {
          id: 'closeLabel',
          text: '✕ Close',
          class: 'btn-danger',
          onclick: () => modal.remove()
        })
      ])
    ])
  ]);

  document.body.append(modal);

  // Close handlers
  modal.addEventListener('click', e => {
    if (e.target === modal) modal.remove();
  });

  document.addEventListener('keydown', function escHandler(ev) {
    if (ev.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', escHandler);
    }
  });

  // 🧩 Auto-generate QR code on open
  setTimeout(() => {
    const container = document.getElementById('qrContainer');
    if (!container) return;

    // You can change the encoded text here
    const qrText = `https://meadtrics.app/batch/${encodeURIComponent(batch.name)}`;

    container.innerHTML = '';
    new QRCode(container, {
      text: qrText,
      width: 80,
      height: 80,
      colorDark: '#000000',
      colorLight: 'transparent',
      correctLevel: QRCode.CorrectLevel.H
    });

    console.log(`📦 QR code generated for: ${qrText}`);
  }, 100);
}




let EXTENDS_BIN_ID = localStorage.getItem("EXTENDS_BIN_ID") || null;
let EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY") || "";
const EXTENDS_API = "https://json.extendsclass.com/bin";
const EXTENDS_KEY = "meadtracker";

function updateSyncCard() {
  const urlEl = document.getElementById("syncUrl");
  const keyEl = document.getElementById("syncKey");
  const keyInput = document.getElementById("apiKeyInput");
  const statusEl = document.getElementById("syncStatus");
  if (urlEl) {
    urlEl.textContent = EXTENDS_BIN_ID
      ? `${EXTENDS_API}/${EXTENDS_BIN_ID}`
      : "Local only (no cloud bin)";
  }
  if (keyEl) keyEl.textContent = EXTENDS_KEY;
  if (keyInput) keyInput.value = EXTENDS_API_KEY;
  if (statusEl)
    statusEl.textContent = EXTENDS_API_KEY
      ? "☁️ Cloud Sync Active"
      : "💾 Local-only mode";
}


function updateYAN() {
  const yeastABV = parseFloat(document.getElementById('tosnaYeastABV').value) || 14;
  const sweetness = document.getElementById('tosnaSweetness').value;
  const req = document.getElementById('tosnaReq').value;
  let effYAN = 150;

  if (yeastABV <= 12) {
    if (sweetness === 'dry') effYAN = req === 'low' ? 100 : req === 'medium' ? 125 : 150;
    else if (sweetness === 'semi') effYAN = req === 'low' ? 120 : req === 'medium' ? 140 : 160;
    else effYAN = req === 'low' ? 130 : req === 'medium' ? 150 : 180;
  } else if (yeastABV <= 14) {
    if (sweetness === 'dry') effYAN = req === 'low' ? 120 : req === 'medium' ? 140 : 160;
    else if (sweetness === 'semi') effYAN = req === 'low' ? 130 : req === 'medium' ? 150 : 180;
    else effYAN = req === 'low' ? 150 : req === 'medium' ? 180 : 200;
  } else if (yeastABV <= 16) {
    if (sweetness === 'dry') effYAN = req === 'low' ? 140 : req === 'medium' ? 170 : 190;
    else if (sweetness === 'semi') effYAN = req === 'low' ? 160 : req === 'medium' ? 190 : 220;
    else effYAN = req === 'low' ? 170 : req === 'medium' ? 200 : 250;
  } else {
    effYAN = req === 'low' ? 180 : req === 'medium' ? 210 : 260;
  }

  document.getElementById('tosnaYan').value = Math.round(effYAN);
}

function initTosnaBindings() {
  const ids = ['tosnaYeastABV','tosnaSweetness','tosnaReq'];
  let found = false;
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (el) {
      found = true;
      el.addEventListener('input', updateYAN);
    }
  });
  if (found) updateYAN();
  
}


function updateFGOG() {
  const yeastABV = parseFloat(document.getElementById('tosnaYeastABV').value) || 14;
  const sweetness = document.getElementById('tosnaSweetness').value;
  let fg = 1.000;

  if (sweetness === 'dry') fg = 1.000;
  else if (sweetness === 'semi') fg = 1.015;
  else if (sweetness === 'sweet') fg = 1.030;


  const og = (fg + (yeastABV / 131.25)).toFixed(3);

  const display = document.getElementById('tosnaFGOG');
  display.innerHTML = `Estimated FG: <b>${fg.toFixed(3)}</b> → Suggested OG: <b>${og}</b>`;
}


function calcBacksweetening() {
  const sg1 = parseFloat(document.getElementById('back_currentSG').value);
  const sg2 = parseFloat(document.getElementById('back_desiredSG').value);
  const vol = parseFloat(document.getElementById('back_volume').value);
  const type = document.getElementById('back_type').value;
  const customPercent = parseFloat(document.getElementById('back_customPercent').value);

  if (isNaN(sg1) || isNaN(sg2) || isNaN(vol)) {
    alert("Please enter valid SG values and volume.");
    return;
  }


  const sgToGpl = sg => (182.4601 * sg ** 3) - (775.6821 * sg ** 2) + (1262.7794 * sg) - 669.5622;
  const sugarCurrent = sgToGpl(sg1);
  const sugarDesired = sgToGpl(sg2);
  const sugarDiff = sugarDesired - sugarCurrent;

  const sugarKg = (sugarDiff * vol) / 1000; 


  let factor = 1;
  let label = "sugar";

  if (type === "honey") {
    factor = 0.82;
    label = "honey";
  } else if (type === "custom") {
    if (isNaN(customPercent) || customPercent <= 0 || customPercent > 100) {
      alert("Please enter a valid custom sugar % between 1–100.");
      return;
    }
    factor = customPercent / 100;
    label = `${customPercent}% custom sweetener`;
  }

  const requiredKg = sugarKg / factor;

  document.getElementById('back_resultKg').value = requiredKg.toFixed(3);
  document.getElementById('backResult').innerHTML = `
    <b>Result:</b><br>
    • Add <b>${requiredKg.toFixed(3)} kg</b> of ${label}<br>
    (to raise SG from ${sg1.toFixed(3)} → ${sg2.toFixed(3)})
  `;
}

function calcDilution() {
  const sg1 = parseFloat(document.getElementById('dil_current').value);
  const sg2 = parseFloat(document.getElementById('dil_target').value);
  const vol = parseFloat(document.getElementById('dil_volume').value);

  if (isNaN(sg1) || isNaN(sg2) || isNaN(vol) || sg2 >= sg1) {
    alert("Enter valid numbers (target SG must be lower than current).");
    return;
  }

  const waterToAdd = vol * ((sg1 - sg2) / sg2);
  document.getElementById('dilResult').innerHTML =
    `Add approximately <b>${waterToAdd.toFixed(2)} L</b> of water to reduce from ${sg1.toFixed(3)} → ${sg2.toFixed(3)} SG.`;
}


function calcPriming() {
  const vol = parseFloat(document.getElementById('prime_volume').value);
  const co2 = parseFloat(document.getElementById('prime_co2').value);

  if (isNaN(vol) || vol <= 0) {
    alert("Enter a valid batch volume in litres.");
    return;
  }

  if (co2 === 0) {
    document.getElementById('primeResult').innerHTML = `
      For <b>${vol.toFixed(1)} L</b> batch:<br>
      • No sugar needed — for still mead.
    `;
    return;
  }


  const sugarPerL = co2 * 4;
  const totalSugarG = vol * sugarPerL;
  const totalSugarKg = totalSugarG / 1000;

  document.getElementById('primeResult').innerHTML = `
    For <b>${vol.toFixed(1)} L</b> batch:<br>
    • Add <b>${totalSugarG.toFixed(0)} g</b> sugar 
      (<b>${totalSugarKg.toFixed(2)} kg</b>)<br>
    • Target carbonation: <b>${co2.toFixed(1)} vols CO₂</b><br>
    (Use table sugar or dextrose. Mix thoroughly before bottling.)
  `;
}


function calcStabilisation() {
  const vol = parseFloat(document.getElementById('stab_volume').value);
  if (isNaN(vol) || vol <= 0) {
    alert("Enter a valid batch volume in litres.");
    return;
  }


  const sorbate = vol * 0.2;
  const meta = vol * 0.15;

  document.getElementById('stabResult').innerHTML = `
    For <b>${vol.toFixed(1)} L</b> batch:<br>
    • Add <b>${sorbate.toFixed(2)} g</b> Potassium Sorbate<br>
    • Add <b>${meta.toFixed(2)} g</b> Potassium Metabisulfite<br>
  `;
}


function brixToSG(brix) {
  return 1 + (brix / (258.6 - ((brix / 258.2) * 227.1)));
}

function sgToBrix(sg) {
  return (((182.4601 * sg - 775.6821) * sg + 1262.7794) * sg - 669.5622);
}

async function createBin() {
  try {
    const EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY");
    const EXTENDS_KEY = localStorage.getItem("EXTENDS_KEY");
    if (!EXTENDS_API_KEY || !EXTENDS_KEY)
      throw new Error("Missing API or Security key");

    console.log("Api-key:", `"${EXTENDS_API_KEY}"`);
    console.log("Security-key:", `"${EXTENDS_KEY}"`);

    const res = await fetch(EXTENDS_API, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Api-key": EXTENDS_API_KEY,
        "Security-key": EXTENDS_KEY,
        "Private": "true"
      },
      body: JSON.stringify({ data: { batches: [] } })
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    EXTENDS_BIN_ID = data.id;
    localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
    updateViewBinButton();
    updateSyncCard();
    alert(`✅ Created JSON bin:\n${EXTENDS_BIN_ID}`);
  } catch (err) {
    console.error("Failed to create bin:", err);
    alert("⚠️ Could not create JSON bin.\n" + err.message);
  }
}

async function cloudLoad() {
  try {
    const EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY");
    const EXTENDS_KEY = localStorage.getItem("EXTENDS_KEY");
    const EXTENDS_BIN_ID = localStorage.getItem("EXTENDS_BIN_ID");
    if (!EXTENDS_API_KEY || !EXTENDS_KEY || !EXTENDS_BIN_ID)
      throw new Error("Missing API key, Security key, or bin ID");

    const url = `${EXTENDS_API}/${EXTENDS_BIN_ID}`;
    const res = await fetch(url, {
      method: "GET",
      headers: {
        "Api-key": EXTENDS_API_KEY,
        "Security-key": EXTENDS_KEY
      }
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
	
	let data = await res.json();
	
// 🔹 Handle compressed payloads and unwrap formats
if (data && data.data && data.data.__compressed) {
  data.data = decompressPayload(data.data);
}
if (data.data && data.data.batches) data = data.data;

console.log("☁️ Cloud data loaded:", data);
return data;

    // 🧩 unwrap legacy/new bin formats
    if (data.data && data.data.batches) data = data.data;
    console.log("☁️ Cloud data loaded:", data);
    return data;
  } catch (err) {
    console.error("Failed to load bin:", err);
    alert("⚠️ Failed to load cloud data.\n" + err.message);
  }
}

let offlineQueue = JSON.parse(localStorage.getItem('offlineQueue') || '[]');

window.addEventListener('online', async () => {
  console.log('🌐 Back online — syncing queued updates...');
  for (const queued of offlineQueue) {
    try {
      await cloudSave(queued, true);
      console.log('☁️ Synced queued payload:', queued);
    } catch (err) {
      console.warn('⚠️ Failed to sync queued payload:', err);
    }
  }
  offlineQueue = [];
  localStorage.removeItem('offlineQueue');
});

async function cloudSave(payload, patchOnly = true) {
  try {
    // 🧩 Offline queue support (for PWA)
    if (!navigator.onLine) {
      console.log("📦 Offline — queuing save for later sync.");
      const offlineQueue = JSON.parse(localStorage.getItem("offlineQueue") || "[]");
      offlineQueue.push(payload);
      localStorage.setItem("offlineQueue", JSON.stringify(offlineQueue));
      save(state); // always keep local up to date
      return;
    }

    // --- Safety guards ---
    if (!EXTENDS_BIN_ID || !EXTENDS_KEY) {
      console.warn("⚠️ No ExtendsClass bin/key — skipping cloud save.");
      return;
    }

    // --- Merge state with patch payload ---
    let merged = structuredClone(state);
    if (payload && payload.batches) {
      for (const patchBatch of payload.batches) {
        const idx = merged.batches.findIndex(b => b.id === patchBatch.id);
        if (idx !== -1) Object.assign(merged.batches[idx], patchBatch);
        else merged.batches.push(patchBatch);
      }
    }

    // --- Detect legacy bin format ---
    let shouldMigrate = false;
    try {
      const checkRes = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
        headers: { "Security-key": EXTENDS_KEY }
      });
      if (checkRes.ok) {
        const checkJson = await checkRes.json();
        if (Array.isArray(checkJson.batches) && !checkJson.data) {
          console.log("🧩 Legacy bin detected — migrating to {data:...} format.");
          shouldMigrate = true;
        }
      }
    } catch (e) {
      console.warn("⚠️ Could not inspect bin before save:", e);
    }

    // --- Compress payload before upload ---
    let compressedData;
    try {
      if (typeof LZString !== "undefined") {
        const json = JSON.stringify(merged);
        const compressed = LZString.compressToBase64(json);
        compressedData = { __compressed: true, data: compressed };
      } else {
        console.warn("⚠️ LZString not loaded — saving uncompressed.");
        compressedData = merged;
      }
    } catch (err) {
      console.warn("⚠️ Compression failed — fallback to plain JSON:", err);
      compressedData = merged;
    }

    // --- Prepare request ---
    const method = patchOnly ? "PATCH" : "PUT";
    const headers = {
      "Content-Type": patchOnly ? "application/merge-patch+json" : "application/json",
      "Security-key": EXTENDS_KEY
    };

    // remove redundant nesting if needed
    if (merged.data && merged.batches) delete merged.batches;

    const body = JSON.stringify({ data: compressedData });

    const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
      method,
      headers,
      body
    });

    if (!res.ok) {
      if (patchOnly && (res.status === 400 || res.status === 404)) {
        console.warn(`⚠️ PATCH failed (${res.status}), retrying full PUT`);
        return cloudSave(state, false);
      }
      throw new Error(`HTTP ${res.status}`);
    }

    console.log(`☁️ ${method} sync successful${shouldMigrate ? " — bin migrated to new format" : ""}`);
    updateViewBinButton();
  } catch (err) {
    console.warn("⚠️ ExtendsClass sync failed:", err);

    // Fallback: if offline or failed mid-way, queue for later
    if (!navigator.onLine) {
      const offlineQueue = JSON.parse(localStorage.getItem("offlineQueue") || "[]");
      offlineQueue.push(payload);
      localStorage.setItem("offlineQueue", JSON.stringify(offlineQueue));
      console.log("📦 Queued cloud save due to network issue.");
    }

    updateViewBinButton();
  }
}

// 🔹 When connection is restored, flush queued saves
window.addEventListener("online", async () => {
  const queued = JSON.parse(localStorage.getItem("offlineQueue") || "[]");
  if (!queued.length) return;
  console.log(`🌐 Back online — syncing ${queued.length} queued updates...`);
  for (const p of queued) {
    try {
      await cloudSave(p, true);
      console.log("☁️ Synced queued payload");
    } catch (err) {
      console.warn("⚠️ Failed to sync queued payload:", err);
    }
  }
  localStorage.removeItem("offlineQueue");
});

window.addEventListener("beforeunload", () => cloudSave(state));


const saveApiKeyBtn = document.getElementById("saveApiKeyBtn");
if (saveApiKeyBtn) {
  saveApiKeyBtn.addEventListener("click", async () => {
    const keyInput = document.getElementById("apiKeyInput");
    const newKey = keyInput.value.trim();

    // 🧹 If blank — disable cloud mode completely
    if (!newKey) {
      clearExtendsCredentials();
      EXTENDS_API_KEY = "";
      EXTENDS_BIN_ID = "";
      state.cloudEnabled = false;
      updateSyncCard();
      updateViewBinButton();
      console.log("💾 Cloud sync disabled — reverted to local-only mode.");
      alert("💾 Cloud sync disabled — now saving locally only.");
      return;
    }

    // ✅ Save new key and enable cloud mode
    EXTENDS_API_KEY = newKey;
    localStorage.setItem("EXTENDS_API_KEY", EXTENDS_API_KEY);
    localStorage.setItem("EXTENDS_KEY", EXTENDS_KEY);
    state.cloudEnabled = true;

    console.log("🔑 ExtendsClass API key saved:", EXTENDS_API_KEY);

    // 🪣 Create or reuse bin
    if (!EXTENDS_BIN_ID) {
      const existingBin = await getExistingBin();
      if (existingBin) {
        EXTENDS_BIN_ID = existingBin;
        localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
        console.log(`☁️ Using existing bin: ${EXTENDS_BIN_ID}`);
      } else {
        await createBin();
      }
    }

    updateViewBinButton();
    updateSyncCard();

    // ☁️ Attempt to load cloud data, or upload local if empty
    try {
      const cloudData = await cloudLoad();
      const dataToUse =
        cloudData && (cloudData.batches?.length || cloudData.data?.batches?.length)
          ? (cloudData.data?.batches ? cloudData.data : cloudData)
          : null;

      if (dataToUse) {
        console.log("☁️ Loaded cloud data after key entry:", dataToUse);
        state = dataToUse;
        save(state);
        render();
        alert("✅ API key saved — cloud data loaded successfully.");
      } else {
        console.log("☁️ No cloud data found — uploading local state.");
        await cloudSave(state);
        alert("✅ API key saved — local data uploaded to cloud.");
      }
    } catch (err) {
      console.warn("⚠️ Failed to load cloud data after key entry:", err);
      alert("⚠️ API key saved, but failed to fetch cloud data. Using local data for now.");
    }
  });
}

async function getExistingBin() {
  if (!EXTENDS_API_KEY) {
    console.log("⚠️ No ExtendsClass API key — skipping bin lookup.");
    return null;
  }

  try {
    const res = await fetch(`https://json.extendsclass.com/bins?nocache=${Date.now()}`, {
      headers: { "Api-key": EXTENDS_API_KEY },
      cache: "no-store"
    });

    console.log("Fetched /bins at", new Date().toISOString(), "status", res.status);

    if (res.status === 401) {
      console.warn("⚠️ Wrong API key — cannot fetch bins.");
      return null;
    }
    if (res.status === 429) {
      console.warn("⚠️ ExtendsClass rate limit exceeded — try again later.");
      return null;
    }
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const bins = await res.json();
    if (Array.isArray(bins) && bins.length > 0) {
      console.log(`☁️ Found existing bins: ${bins.join(", ")}`);
      return bins[0];
    }

    console.log("☁️ No existing bins found for this API key.");
    return null;
  } catch (err) {
    console.warn("⚠️ Could not fetch existing bins:", err);
    return null;
  }
}

function updateViewBinButton() {
  const btn = document.getElementById("viewBinBtn");
  if (!btn) return;

  if (EXTENDS_BIN_ID && EXTENDS_API_KEY) {
    btn.style.display = "inline-block";
    btn.onclick = async (e) => {
      e.stopPropagation();
      try {
        const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
          headers: {
            "Api-key": EXTENDS_API_KEY,
            "Security-key": EXTENDS_KEY
          }
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();


        const popup = window.open("about:blank", "binPopup", "width=700,height=600,resizable,scrollbars=yes");
        if (!popup) return alert("⚠️ Popup blocked. Please allow popups for this site.");


        popup.document.write(`
          <html>
            <head>
              <title>MeadTrics Cloud Bin – ${EXTENDS_BIN_ID}</title>
              <style>
                body {
                  background-color: #0f141b;
                  color: #e4e9f0;
                  font-family: monospace;
                  padding: 16px;
                  white-space: pre-wrap;
                  overflow-wrap: anywhere;
                }
                h2 {
                  font-family: system-ui, sans-serif;
                  font-size: 16px;
                  margin-top: 0;
                  color: #ffd86b;
                }
                code {
                  background: #1a2028;
                  padding: 8px;
                  display: block;
                  border-radius: 8px;
                  border: 1px solid #2a3340;
                }
              </style>
            </head>
            <body>
              <h2>Cloud Bin: ${EXTENDS_BIN_ID}</h2>
              <code id="jsonArea">Loading...</code>
            </body>
          </html>
        `);
        popup.document.close();

        popup.onload = () => {
          const area = popup.document.getElementById("jsonArea");
          if (area) area.textContent = JSON.stringify(data, null, 2);
        };

      } catch (err) {
        console.error("Failed to load bin:", err);
        alert("⚠️ Failed to load bin:\n" + err.message);
      }
    };
  } else {
    btn.style.display = "none";
  }
}


async function saveAll(state, changedBatch = null, changedFields = null) {
  save(state); 


  if (!EXTENDS_BIN_ID || !EXTENDS_KEY) {
    console.log("💾 Local-only save (no ExtendsClass key).");
    return;
  }

  let payload;
  if (changedBatch && Array.isArray(changedFields) && changedFields.length) {
    const partial = { batches: [] };
    const patch = { id: changedBatch.id };
    for (const f of changedFields) {

      if (changedBatch[f] !== undefined)
        patch[f] = structuredClone(changedBatch[f]);
    }
    partial.batches.push(patch);
    payload = partial;
    console.log("☁️ Sending minimal PATCH:", partial);
  } else {
    payload = state;
    console.log("☁️ Sending full PATCH (no diff info).");
  }


  await cloudSave(state, true);
}

function clearExtendsCredentials() {
  const keys = [
    "EXTENDS_BIN_ID",
    "EXTENDS_KEY",
    "EXTENDS_API_KEY"
  ];
  for (const k of keys) localStorage.removeItem(k);


  localStorage.setItem("EXTENDS_MANUAL_DISABLE", "1");

  console.log("🧹 Cleared ExtendsClass credentials from localStorage.");
}


function migrateOldLocalData() {
  try {
    const oldKeyNames = [
      "mead-tracker:v1",
      "meadTrackerState",
      "batches",
      "meadTracker" 
    ];


    const foundKey = oldKeyNames.find((k) => localStorage.getItem(k));
    if (!foundKey) return false; 

    const oldData = JSON.parse(localStorage.getItem(foundKey));
    if (!oldData || localStorage.getItem("MIGRATION_DONE")) return false;

    console.log(`🧩 Found old MeadTrics data in '${foundKey}' → migrating...`);


    const newState = oldData.batches
      ? oldData
      : { batches: Array.isArray(oldData) ? oldData : [oldData] };


    save(newState);
    localStorage.setItem("MIGRATION_DONE", "true");


    if (EXTENDS_API_KEY && EXTENDS_BIN_ID) {
      cloudSave(newState).then(() =>
        console.log("☁️ Migrated data uploaded to cloud.")
      );
    }

    alert(
      "✅ Your old MeadTrics data has been automatically migrated to the new version.\nAll batches are safe and backed up locally."
    );

    return true;
  } catch (err) {
    console.warn("Migration check failed:", err);
    return false;
  }
}

function integrityCheck() {
  if (!state || !Array.isArray(state.batches)) {
    console.warn("🧩 Invalid state.batches — resetting to empty array.");
    state = { batches: [] };
    save(state);
    return;
  }

  let fixed = 0;
  for (const b of state.batches) {
    let changed = false;

    // Ensure each batch has required base fields
    if (!b.id) { b.id = crypto.randomUUID(); changed = true; }
    if (!Array.isArray(b.sgReadings)) { b.sgReadings = []; changed = true; }
    if (!Array.isArray(b.events)) { b.events = []; changed = true; }
    if (!Array.isArray(b.ingredients)) { b.ingredients = []; changed = true; }
    if (!Array.isArray(b.tags)) { b.tags = []; changed = true; }
    if (typeof b.name !== "string") { b.name = "Unnamed Batch"; changed = true; }
    if (!b.startDate) { b.startDate = new Date().toISOString().slice(0, 10); changed = true; }

    // Ensure all events have date & type
    for (const ev of b.events) {
      if (!ev.date) ev.date = b.startDate;
      if (!ev.type) ev.type = "note";
    }

    // Ensure all SG readings have id & sg fields
    for (const r of b.sgReadings) {
      if (!r.id) r.id = crypto.randomUUID();
      if (typeof r.sg === "string") r.sg = r.sg.trim();
      if (!r.date) r.date = b.startDate;
    }

    if (changed) fixed++;
  }

  if (fixed > 0) {
    console.log(`🧩 Integrity check: fixed ${fixed} batch(es).`);
    save(state);
  } else {
    console.log("✅ Integrity check passed — all batches valid.");
  }
}

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then(reg => {
    console.log('✅ Service Worker registered');

    // 🔹 Check if there’s an updated service worker waiting
    function showUpdatePrompt(worker) {
      const shouldUpdate = confirm("🧪 MeadTrics update available!\n\nReload now to apply the latest version?");
      if (shouldUpdate) {
        worker.postMessage({ type: 'SKIP_WAITING' });
      }
    }

    // If a new worker is waiting
    if (reg.waiting) {
      showUpdatePrompt(reg.waiting);
    }

    // If a new worker is installed and waiting
    reg.addEventListener('updatefound', () => {
      const newWorker = reg.installing;
      newWorker?.addEventListener('statechange', () => {
        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
          showUpdatePrompt(newWorker);
        }
      });
    });

    // When the new worker activates
    let refreshing = false;
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      if (refreshing) return;
      refreshing = true;
      window.location.reload();
    });
  }).catch(err => console.warn('⚠️ SW registration failed:', err));
}

(async () => {

  const hasValidBin =
    typeof EXTENDS_BIN_ID !== "undefined" &&
    EXTENDS_BIN_ID &&
    EXTENDS_BIN_ID.trim() !== "";


  const manuallyDisabled = localStorage.getItem("EXTENDS_MANUAL_DISABLE") === "1";
  
  if (!hasValidBin && !manuallyDisabled && !localStorage.getItem("EXTENDS_NOTICE_SHOWN")) {
    alert(
      "💾 MeadTrics is saving locally for now.\n\n" +
      "To enable free cloud backup, create an account at:\n" +
      "https://extendsclass.com/json-storage.html\n" +
      "and paste your API key into the Cloud Sync panel."
    );
    localStorage.setItem("EXTENDS_NOTICE_SHOWN", "true");
  }


  migrateOldLocalData();


  renderApp();

const isPWA =
  window.matchMedia('(display-mode: standalone)').matches ||
  window.navigator.standalone;

if (isPWA) {
  console.log('📦 MeadTrics running in PWA mode');

  // Optional: auto-save state every 3 min while installed
  setInterval(() => {
    if (navigator.onLine) {
      cloudSave(state, true);
      console.log('🔁 Background sync (PWA)');
    }
  }, 180000); // 3 minutes
}

  state = load();
  render();
  updateSyncCard();
  updateViewBinButton();


  if (hasValidBin && (!state.batches || !state.batches.length)) {
    try {
      const cloud = await cloudLoad();
      if (cloud && cloud.batches?.length) {
        console.log("☁️ Loaded cloud data on startup (local was empty).");
        state = cloud;
        save(state);
        render();
      }
    } catch (err) {
      console.warn("⚠️ Initial cloud load failed:", err);
    }
  }


  if (hasValidBin) {
    try {
      const cloud = await cloudLoad();

      if (cloud && cloud.batches && cloud.batches.length > 0) {
        console.log("☁️ Loaded cloud data successfully.");
        console.log("☁️ Replacing local with cloud data.");
        state = cloud;
        save(state);
        render();
      } else if (state && state.batches && state.batches.length > 0) {
        console.log("☁️ Cloud empty — pushing local data up for the first time.");
        await cloudSave(state);
      } else {
        console.log("☁️ Cloud and local both empty — starting fresh.");
      }
    } catch (err) {
      console.warn("⚠️ Cloud load failed — using local copy:", err);
    }
  } else {
    console.log("💾 Loaded local data (no ExtendsClass bin configured).");
  };
  updateSyncCard();
  integrityCheck();
})();

</script>
</body>
</html>
