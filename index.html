<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MeadTrics</title>
  <style>
:root {
  /* ==== Theme Variables ==== */
  /* Background color for the app (main page background) */
  --bg: #0f1216;
  /* Panel background color (cards, sidebars, etc.) */
  --panel: #161a20;
  /* Muted text color for secondary information */
  --muted: #aab2c0;
  /* Main text color for normal content */
  --text: #e8edf5;
  /* Primary accent color (used for highlights, buttons, and lines) */
  --accent: #82cfff;
  /* Secondary accent color (used for hover or complementary effects) */
  --accent-2: #b5e08a;
  /* Error or warning color (used for delete buttons, alerts, etc.) */
  --danger: #ff6b6b;
  /* Border color for panels, inputs, and dividers */
  --border: #2a2f39;
  /* Box shadow for raised UI elements (cards, modals, etc.) */
  --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  /* Default border radius for rounded corners */
  --radius: 14px;
}
	
/* Apply universal box-sizing to make layout calculations consistent */
* {
  box-sizing: border-box;
}

/* Ensure the document and body take up the full viewport height */
html, body {
  height: 100%;
}

/* Base body styles */
body {
  margin: 0; /* Remove default browser margin */
  
  /* Use a modern, system-based sans-serif font stack for readability */
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
    Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";

  /* Subtle radial gradient background, darker at center edges */
  background: radial-gradient(
    1200px 800px at 100% -10%,  /* Gradient size and position */
    #16202e 0,                 /* Lighter blue-gray center tone */
    #0f1216 50%                /* Dark background base tone */
  );

  /* Default text color for the entire page (from theme variable) */
  color: var(--text);
}

/* Style for all numeric input fields */
input[type="number"] {
  font-size: 16px; /* Slightly larger text for readability */
}

/* Wide variant of numeric inputs (used in forms where full width is desired) */
input[type="number"].wide {
  width: 100%;       /* Expand to fill available container width */
  min-width: 150px;  /* Prevent input from becoming too narrow */
}


/* Main application layout container */
/* Uses a two-column grid: sidebar (fixed width) + main content (flexible) */
.app {
  display: grid;                         /* establish grid layout */
  grid-template-columns: 320px 1fr;      /* sidebar = 320px, main content = remaining space */
  gap: 16px;                             /* space between columns */
  height: 100%;                          /* fill full viewport height */
  padding: 16px;                         /* outer spacing around the app */
}

/* === Layout & Card Structure === */

/* Shared card style used for panels and sections */
.card {
  background: var(--panel);                 /* panel background color */
  border: 1px solid var(--border);          /* subtle border outline */
  border-radius: var(--radius);             /* consistent rounded corners */
  box-shadow: var(--shadow);                /* soft depth shadow */
}

/* Sidebar container ‚Äî vertical layout for batch list and controls */
.sidebar {
  display: flex;
  flex-direction: column;
  overflow: hidden; /* prevent scrollbars on inner overflow */
}

/* Sidebar header ‚Äî title bar + New button */
.sidebar header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px; /* small gap between title and button */
}

/* Sidebar title text */
.sidebar header h1 {
  font-size: 18px;
  margin: 0;
}

/* Search bar container fills sidebar width */
.search {
  width: 100%;
}

/* Search input field styling */
.search input {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;     /* darker input background */
  color: var(--text);
}

/* Batch list container ‚Äî scrollable grid */
.list {
  overflow: auto;
  padding: 8px;
  display: grid;
  gap: 8px;
}

/* === Batch List Items === */

/* Individual batch entry card */
.batch {
  padding: 12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  cursor: pointer;
  transition: border-color .2s, background .2s; /* smooth hover feedback */
}

/* Hover highlight for batches */
.batch:hover {
  border-color: #3a4150;
  background: #111821;
}

/* Active batch (currently selected) */
.batch.active {
  outline: 2px solid var(--accent);
  background: #101722;
}

/* Batch name ‚Äî bolded */
.batch .name {
  font-weight: 600;
}

/* Batch metadata (date, OG/FG, etc.) */
.batch .meta {
  color: var(--muted);
  font-size: 12px;
  margin-top: 4px;
}

/* === Main Content Area === */

/* Main section layout: detail panel + footer */
.content {
  display: grid;
  grid-template-rows: 1fr auto; /* main area + footer */
  gap: 16px;
}

/* Detail panel that shows batch info */
.detail {
  padding: 16px;
  overflow: auto; /* allow scroll inside */
}

/* Detail title spacing */
.detail h2 {
  margin: 0 0 8px 0;
}

/* Generic grid utility for forms (12-column) */
.grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 12px;
}
.grid .col-6 { grid-column: span 6; }
.grid .col-12 { grid-column: span 12; }

/* === Fieldsets (section boxes) === */

.fieldset {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
}
.fieldset legend {
  padding: 0 6px;
  color: var(--muted);
}

/* === Form Controls === */

/* Label text for inputs */
label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}

/* Shared input / select / textarea appearance */
input[type="text"],
input[type="date"],
input[type="number"],
textarea,
select {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
}

/* Textareas can resize vertically but not horizontally */
textarea {
  resize: vertical;
  min-height: 80px;
}

/* === Buttons === */

button {
  appearance: none;
  border: 1px solid var(--border);
  background: #121923;
  color: var(--text);
  padding: 10px 14px;
  border-radius: 12px;
  cursor: pointer;
  transition: transform .04s ease, background .2s, border-color .2s;
  font-weight: 600;
}

/* Hover and active feedback */
button:hover {
  background: #182233;
  border-color: #304055;
}
button:active {
  transform: translateY(1px);
}

/* Accent (primary action) button */
.btn-accent {
  background: #0f2133;
  border-color: #21425d;
}

/* Danger (delete) button */
.btn-danger {
  background: #2a1416;
  border-color: #4e2326;
  color: #ffd6d6;
}

/* === Small UI Elements === */

/* Tag badges used in footer info */
.tag {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 9999px;
  border: 1px solid var(--border);
  color: var(--muted);
}

/* Footer layout ‚Äî info left, buttons right */
.footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 8px;
  justify-content: space-between;
}

/* === Tables === */

.table {
  width: 100%;
  border-collapse: collapse;
}
.table th,
.table td {
  border-bottom: 1px solid var(--border);
  padding: 8px 6px;
  text-align: left;
  font-size: 14px;
}

/* Empty message placeholder */
.empty {
  color: var(--muted);
  font-style: italic;
  padding: 12px 0;
}

/* === Chart Canvas === */

canvas {
  width: 100%;
  height: 220px;
  background: #0c1218;
  border: 1px solid var(--border);
  border-radius: 12px;
}

/* === Responsive Adjustments === */

@media (max-width: 980px) {
  .app { grid-template-columns: 1fr; }     /* stack sidebar & content */
  .content { grid-template-rows: auto auto; }
}

/* === Compact delete button inside batch items === */
.batch .btn-danger {
  padding: 2px 6px;
  font-size: 12px;
  line-height: 1;
  border-radius: 8px;
}
.batch .btn-danger:hover {
  background: #2a1616;
  color: #ffb5b5;
}

/* === Meta info formatting === */
.meta {
  white-space: pre-line; /* preserve newlines from JS formatting */
}
.meta::first-line {
  font-weight: 500; /* emphasize the first line (often date or title) */
}
.meta:has(> span) {
  display: flex;
  flex-direction: column;
}

/* === Batch Name Hover === */
.batch .name:hover {
  text-decoration: underline;
  cursor: pointer;
}

/* === Collapsible fieldsets and row legends === */
.fieldset .row legend {
  font-weight: 600;
  color: var(--accent);
}
.fieldset .row:hover legend {
  color: var(--accent-2);
}
.fieldset .row span {
  transition: transform .2s ease;
}

/* Reusable row layout helper */
.row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 6px;
}

/* === Chart Tooltip === */
.chart-tooltip {
  position: absolute;
  pointer-events: none; /* allow hover to pass through */
  background: #0f141b;
  color: #e8edf5;
  border: 1px solid #2a2f39;
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  backdrop-filter: blur(4px);
  z-index: 10;
}

/* === Event Row Coloring === */
.table tr[data-type="bottled"] td { background: rgba(255,255,255,0.02); color: #b5e08a; }
.table tr[data-type="feeding"] td { background: rgba(255,200,0,0.04); color: #ffe680; }
.table tr[data-type="racked"] td { color: #b0c0ff; }
.table tr[data-type="note"] td textarea { background: #111822; color: #d8dee9; }

/* === Alternating Fieldset Backgrounds === */
.fieldset:nth-of-type(1) { background: rgba(255,255,255,0.02); }
.fieldset:nth-of-type(2) { background: rgba(255,255,255,0.01); }

/* === Scrollbar Styling === */
.list::-webkit-scrollbar,
.detail::-webkit-scrollbar {
  width: 8px;
}
.list::-webkit-scrollbar-thumb,
.detail::-webkit-scrollbar-thumb {
  background: #202833;
  border-radius: 6px;
}
.list::-webkit-scrollbar-thumb:hover,
.detail::-webkit-scrollbar-thumb:hover {
  background: #2e3a4b;
}

/* === Collapsible fieldset indicator icons === */
.fieldset.collapsible legend::after { content: " ‚ñº"; }
.fieldset.collapsible.collapsed legend::after { content: " ‚ñ∂"; }

/* === Ingredient Section Visual Tweaks === */
.fieldset legend {
  font-weight: 600;
  color: var(--accent);
}
.fieldset legend:hover {
  color: var(--accent-2);
}
.fieldset + .fieldset {
  margin-top: 14px;
  border-color: #252b34;
  background: rgba(255, 255, 255, 0.02);
  padding-top: 10px;
  padding-bottom: 10px;
}
.fieldset .grid .col-4 input,
.fieldset .grid .col-12 input {
  background: #0f141b;
  border: 1px solid var(--border);
  color: var(--text);
}
.fieldset label {
  margin-top: 4px;
  margin-bottom: 4px;
  display: block;
  color: var(--muted);
  font-size: 13px;
}
.fieldset:nth-of-type(n+2) {
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
  border-radius: 10px;
}

/* === Buttons (accent variant refined) === */
.btn-accent {
  background: var(--accent);
  border: none;
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s ease;
}
.btn-accent:hover {
  background: var(--accent-2);
}

/* === Print-only styling for Label Maker === */
@media print {
  /* Hide everything on the page by default when printing */
  body * { visibility: hidden; }

  /* Make only the label box (and its contents) visible */
  #labelBox, #labelBox * { visibility: visible; }

  /* Position the label box in the top-left corner of the printed page */
  #labelBox {
    position: absolute;
    left: 0;
    top: 0;
    margin: 0;
  }
}

/* Utility class used to hide elements in normal (screen) mode */
.hidden {
  display: none !important;
}

/* --- Feedback Button --- */
.icon-btn {
  position: fixed;
  top: 16px;
  right: 16px;
  background: var(--accent, #3b5);
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  transition: background 0.2s;
  z-index: 9999;
}
.icon-btn:hover {
  background: var(--accent-hover, #2a4);
}

/* --- Popup background --- */
.popup {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}
.popup.hidden {
  display: none;
}

/* --- Popup card (dark theme to match MeadTrics) --- */
.popup-content {
  background: var(--panel);
  color: var(--text);
  padding: 20px;
  border-radius: var(--radius);
  width: 90%;
  max-width: 420px;
  box-shadow: var(--shadow);
  border: 1px solid var(--border);
  animation: fadeIn 0.25s ease;
}
.popup-content h3 {
  margin-top: 0;
  color: var(--accent);
}
.popup-content textarea {
  width: 100%;
  box-sizing: border-box;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0f141b;
  color: var(--text);
  resize: vertical;
  font-family: inherit;
}
.popup-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 12px;
}
.popup-actions button {
  padding: 8px 14px;
  border-radius: 10px;
  border: 1px solid var(--border);
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
}
.popup-actions .primary {
  background: var(--accent);
  color: #fff;
}
.popup-actions .primary:hover {
  background: var(--accent-2);
}
.popup-actions .secondary {
  background: #1a2028;
  color: var(--text);
}
.popup-actions .secondary:hover {
  background: #222a33;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(10, 15, 20, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
}

.modal-content {
  background: #0f141b;
  color: var(--text);
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 18px rgba(0, 0, 0, 0.5);
  max-width: 320px;
  text-align: left;
}

.icon-btn {
  position: fixed;
  bottom: 16px;
  right: 16px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 50%;
  width: 46px;
  height: 46px;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  z-index: 1000;
}

.popup {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.6);
  z-index: 999;
}

.popup.hidden { display: none; }

.popup-content {
  background: #0f141b;
  color: var(--text);
  padding: 16px;
  border-radius: 8px;
  width: 300px;
  box-shadow: 0 4px 18px rgba(0,0,0,0.5);
}

.popup-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 8px;
}


  </style>
  
</head>
<body>
  <div class="app">
    <aside class="sidebar card">
      <header>
        <h1>MeadTrics</h1>
        <button id="newBatchBtn" class="btn btn-accent">+ New</button>
      </header>
      <div class="search" style="padding: 12px;">
        <input id="searchInput" type="text" placeholder="Search batches‚Ä¶ (name or notes)" />
      </div>
<div id="batchList" class="list">
</div>
</aside>
    </aside>
	
    <section class="content">
      <div id="detail" class="detail card"></div>
      <div class="footer card">
        <div class="row">
          <span class="tag">Local-only (saved to your browser)</span>
          <span class="tag">ABV uses (OG ‚àí FG) √ó 131.25</span>
        </div>
        <div class="row">
          <button id="exportBtn">Export</button>
          <input id="importFile" type="file" accept="application/json" style="display:none" />
          <button id="importBtn">Import</button>
          <button id="clearBtn" class="btn-danger">Clear All</button>
        </div>
      </div>
    </section>
  </div>

  <template id="batchItemTmpl">
    <div class="batch">
      <div class="name"></div>
      <div class="meta"></div>
    </div>
  </template>

<button id="feedbackBtn" title="Send Feedback" class="icon-btn">
  üìù
</button>

<!-- Feedback popup -->
<div id="feedbackPopup" class="popup hidden">
  <div class="popup-content">
    <h3>Send Feedback</h3>
    <textarea id="feedbackText" placeholder="Describe your idea, bug, or suggestion..." rows="5"></textarea>
    <div class="popup-actions">
      <button id="feedbackSubmit" class="primary">Submit</button>
      <button id="feedbackCancel" class="secondary">Cancel</button>
    </div>
  </div>
</div>


  <script>
/* === Constants and Utility Functions === */

/* LocalStorage key used to persist app data */
const LS_KEY = 'mead-tracker:v2';

/* List of all standard event types available in the app */
const EVENTS = [
  'primary fermentation',
  'secondary fermentation',
  'racked',
  'feeding',
  'degassing',
  'conditioning',
  'cold crashing',
  'backsweetened',
  'bottled'
];

/* Shortcut helper for document.querySelector */
const $ = sel => document.querySelector(sel);

/**
 * Element creation utility
 * Simplifies DOM creation by allowing attributes and children in one call.
 *
 * Example:
 *   el('button', { class: 'btn', text: 'Save', onclick: handleSave })
 */
const el = (tag, attrs = {}, children = []) => {
  const n = document.createElement(tag);

  /* Apply all provided attributes */
  Object.entries(attrs).forEach(([k, v]) => {
    if (k === 'class') n.className = v;                            // set CSS class
    else if (k === 'text') n.textContent = v;                      // set text content
    else if (k.startsWith('on') && typeof v === 'function')        // add event listener (e.g., onclick)
      n.addEventListener(k.slice(2), v);
    else n.setAttribute(k, v);                                     // set generic attribute
  });

  /* Append any child elements or text nodes */
  children.forEach(c => n.append(c));

  return n;
};

/**
 * Format date values for display
 * @param {string|Date} d - A date string or Date object
 * @returns {string} - Localized date string (or empty if invalid)
 */
const fmt = (d) => d ? new Date(d).toLocaleDateString() : '';


/* === Application State Variables === */

// Current saved data (list of mead batches)
let state = { batches: [] }; // placeholder until loaded

// ID of the currently selected batch (or null if none selected)
let selectedId = state.batches[0]?.id || null;

// Current chart display mode: 'sg' = Specific Gravity, 'abv' = Alcohol by Volume
let chartMode = 'sg'; // default chart mode

// Collapsed state tracking for sidebar sections
let sidebarCollapse = { active: false, archived: false };

// === Core Persistence Helpers (local only) ===
function load() {
  try {
    const data = localStorage.getItem(LS_KEY);
    return data ? JSON.parse(data) : { batches: [] };
  } catch (err) {
    console.error('Failed to load local data', err);
    return { batches: [] };
  }
}

function save(state) {
  try {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  } catch (err) {
    console.error('Failed to save local data', err);
  }
}

/**
 * Create the "‚öôÔ∏è Batches" header card dynamically
 * using the `el()` utility.
 */
function batchHeaderCard() {
  return el('div', {
    class: 'fieldset',
    id: 'batchesHeader',
    style: `
      margin-top:16px;
      text-align:center;
      padding:10px 0;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    `
  }, [
    el('legend', {
      text: '‚öôÔ∏è Batches',
      style: `
        color: var(--accent);
        font-weight: 700;
        font-size: 15px;
        letter-spacing: 0.5px;
      `
    })
  ]);
}

/**
 * Create the "‚öôÔ∏è Utilities" header card dynamically
 * using the `el()` utility.
 */
function utilitiesHeaderCard() {
  return el('div', {
    class: 'fieldset',
    id: 'utilitiesHeader',
    style: `
      margin-top:16px;
      text-align:center;
      padding:10px 0;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    `
  }, [
    el('legend', {
      text: '‚öôÔ∏è Utilities',
      style: `
        color: var(--accent);
        font-weight: 700;
        font-size: 15px;
        letter-spacing: 0.5px;
      `
    })
  ]);
}

/**
 * üçØ TOSNA calculator logic (global)
 * Calculates nutrient additions based on batch volume, YAN, yeast, and protocol
 */
function calcTosna() {
  const vol = parseFloat(document.getElementById("tosnaVol")?.value || 0);
  const yan = parseFloat(document.getElementById("tosnaYan")?.value || 0);
  const req = document.getElementById("tosnaReq")?.value || "medium";
  const type = document.getElementById("tosnaType")?.value || "OK";
  const result = document.getElementById("tosnaResult");

  if (!vol || !yan || !result) {
    console.warn("calcTosna() skipped ‚Äî elements not ready");
    return;
  }

  // === Base ratios ===
  const reqMap = { low: 125, medium: 150, high: 200 }; // mg N/L targets
  const targetYan = reqMap[req] || 150;

  const yanNeeded = targetYan - yan;
  if (yanNeeded <= 0) {
    result.textContent = "YAN already sufficient.";
    return;
  }

  // Approximate yields (mg N per g/L)
  const fermaidO_YAN = 20;
  const fermaidK_YAN = 25;
  const dap_YAN = 60;

  let fermaidO = 0, fermaidK = 0, dap = 0;
  if (type === "O") {
    fermaidO = (yanNeeded / fermaidO_YAN) * vol;
  } else if (type === "OK") {
    fermaidO = (yanNeeded * 0.6 / fermaidO_YAN) * vol;
    fermaidK = (yanNeeded * 0.4 / fermaidK_YAN) * vol;
  } else if (type === "OKDAP") {
    fermaidO = (yanNeeded * 0.5 / fermaidO_YAN) * vol;
    fermaidK = (yanNeeded * 0.3 / fermaidK_YAN) * vol;
    dap = (yanNeeded * 0.2 / dap_YAN) * vol;
  }

  const schedule = [
    `‚Ä¢ 24h ‚Üí ${(fermaidO / 4).toFixed(2)} g O`,
    `‚Ä¢ 48h ‚Üí ${(fermaidO / 4).toFixed(2)} g O`,
    `‚Ä¢ 72h ‚Üí ${(fermaidO / 4).toFixed(2)} g O`,
    `‚Ä¢ 1/3 Break ‚Üí ${(fermaidO / 4).toFixed(2)} g O + ${fermaidK.toFixed(2)} g K + ${dap.toFixed(2)} g DAP`
  ].join("\n");

  result.innerHTML =
    `üì¶ For ${vol.toFixed(1)} L at ${targetYan} mg/L target YAN<br><br>` +
    `Fermaid O ‚âà ${fermaidO.toFixed(1)} g ¬∑ ` +
    `Fermaid K ‚âà ${fermaidK.toFixed(1)} g ¬∑ ` +
    `DAP ‚âà ${dap.toFixed(1)} g<br><br>` +
    `Schedule:<br>${schedule.replace(/\n/g, "<br>")}`;
}


/**
 * üçØ Create the TOSNA Calculator card dynamically using `el()`
 * Returns a collapsible fieldset with all inputs and logic
 */
function tosnaCard() {
  // --- Collapsed state ---
  let collapsed = true;

  // === Core DOM structure ===
  const volInput = el('input', {
    id: 'tosnaVol',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

const abvInput = el('input', {
  id: 'tosnaYeastABV',
  type: 'number',
  step: '0.1',
  value: '14',
  style: 'width:100%;margin-bottom:6px;'
});

const sweetSel = el('select', {
  id: 'tosnaSweetness',
  style: 'width:100%;margin-bottom:6px;'
}, [
  el('option', { value: 'dry', text: 'Dry (little to no residual sugar)' }),
  el('option', { value: 'semi', text: 'Semi-sweet (balanced)', selected: true }),
  el('option', { value: 'sweet', text: 'Sweet (high residual sugar)' })
]);

abvInput.addEventListener('input', updateFGOG);
sweetSel.addEventListener('change', updateFGOG);

  const reqSel = el('select', {
    id: 'tosnaReq',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', {
      value: 'low',
      text: 'Low ‚Äî e.g., D47, 71B, K1V ‚Äî Traditional, show, hydromel'
    }),
    el('option', {
      value: 'medium',
      text: 'Medium ‚Äî e.g., QA23, D21, RC212 ‚Äî Melomel, metheglin, pyment',
      selected: true
    }),
    el('option', {
      value: 'high',
      text: 'High ‚Äî e.g., EC-1118, BM4x4, D254 ‚Äî Bochet, capsicumel, cyser, braggot'
    })
  ]);

  const yanInput = el('input', {
    id: 'tosnaYan',
    type: 'number',
    step: '1',
    value: '150',
    style: 'width:100%;margin-bottom:6px;'
  });

  const typeSel = el('select', {
    id: 'tosnaType',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', { value: 'O', text: 'Fermaid O (TOSNA)' }),
    el('option', { value: 'OK', text: 'Fermaid O + K' }),
    el('option', { value: 'OKDAP', text: 'Fermaid O + K + DAP' })
  ]);

  const fgog = el('div', {
    id: 'tosnaFGOG',
    style: 'font-size:13px;color:var(--muted);margin-bottom:8px;',
    text: 'Estimated FG: 1.010 ‚Üí Suggested OG: 1.110'
  });

  const result = el('div', {
    id: 'tosnaResult',
    style: 'font-size:13px;color:var(--muted);'
  });

const calcBtn = el('button', {
  id: 'calcTosna',
  class: 'btn-accent',
  text: 'Calculate TOSNA',
  style: 'width:100%;',
  onclick: () => calcTosna()
});

  // --- Content body ---
  const body = el('div', {
    id: 'tosnaContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Based on TOSNA 2.0 ‚Äî calculates nutrient additions by volume, yeast, and target YAN.'
    }),
    el('label', { text: 'Volume (L):' }),
    volInput,
    el('label', { text: 'Yeast ABV Tolerance (%):' }),
    abvInput,
    el('label', { text: 'Desired Sweetness:' }),
    sweetSel,
    fgog,
    el('label', { text: 'Yeast Nitrogen Requirement:' }),
    reqSel,
    el('label', { text: 'Target YAN (mg N/L):' }),
    yanInput,
    el('label', { text: 'Nutrient Type:' }),
    typeSel,
    calcBtn,
    el('hr', {
      style: 'margin:10px 0;border:none;border-top:1px solid var(--border);'
    }),
    result
  ]);

  // --- Legend (collapsible toggle) ---
  const legend = el('legend', {
    text: 'üçØ TOSNA Calculator',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '‚ñ∂ ' : '‚ñº ') + 'üçØ TOSNA Calculator';
    }
  });

  // --- Outer card ---
  const card = el('div', {
    id: 'tosnaCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  // Initialize collapsed
  collapsed = true;
  body.style.display = 'none';

  return card;
}

/**
 * üçØ Create the Backsweetening Additions card dynamically using `el()`
 * Returns a collapsible fieldset with all inputs and calculation logic
 */
function backsweetCard() {
  let collapsed = true;

  // === Inputs ===
  const currentSG = el('input', {
    id: 'back_currentSG',
    type: 'number',
    step: '0.001',
    value: '1.000',
    style: 'width:100%;margin-bottom:6px;'
  });

  const desiredSG = el('input', {
    id: 'back_desiredSG',
    type: 'number',
    step: '0.001',
    value: '1.015',
    style: 'width:100%;margin-bottom:6px;'
  });

  const volume = el('input', {
    id: 'back_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const typeSel = el('select', {
    id: 'back_type',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', { value: 'sugar', text: 'White Sugar (100%)', selected: true }),
    el('option', { value: 'honey', text: 'Honey (‚âà82%)' }),
    el('option', { value: 'custom', text: 'Custom Sweetener (%)' })
  ]);

  const customWrap = el('div', {
    id: 'customPercentWrap',
    style: 'display:none;margin-bottom:6px;'
  }, [
    el('label', { text: 'Custom Sugar Content (%):' }),
    el('input', {
      id: 'back_customPercent',
      type: 'number',
      step: '1',
      min: '1',
      max: '100',
      value: '75',
      style: 'width:100%;'
    })
  ]);

  const resultField = el('input', {
    id: 'back_resultKg',
    type: 'text',
    readonly: true,
    style: 'width:100%;margin-bottom:6px;'
  });

  const resultDiv = el('div', {
    id: 'backResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  // === Core Logic ===
  const calcBacksweet = () => {
    const sg1 = parseFloat(currentSG.value);
    const sg2 = parseFloat(desiredSG.value);
    const vol = parseFloat(volume.value);
    const type = typeSel.value;
    const customPct = parseFloat(document.getElementById('back_customPercent')?.value || '75');

    if (isNaN(sg1) || isNaN(sg2) || isNaN(vol) || sg2 <= sg1)
      return (resultDiv.textContent = '‚ö†Ô∏è Please enter valid SG and volume values.');

    const delta = (sg2 - sg1) * 1000; // "points" difference
    let sugarGrams = delta * vol * 1.53; // ~1.53g/L/point empirical factor

    // Adjust by sugar content
    let label = '';
    if (type === 'honey') {
      sugarGrams /= 0.82;
      label = 'honey';
    } else if (type === 'custom') {
      sugarGrams /= (customPct / 100);
      label = 'custom sweetener';
    } else {
      label = 'sugar';
    }

    const kg = sugarGrams / 1000;
    resultField.value = kg.toFixed(3);
    resultDiv.innerHTML = `Add approximately <b>${kg.toFixed(3)} kg</b> of ${label}.`;
  };

  // === Button ===
  const calcBtn = el('button', {
    id: 'calcBacksweetBtn',
    class: 'btn-accent',
    text: 'Calculate Backsweetening',
    style: 'width:100%;',
    onclick: calcBacksweet
  });

  // === Body ===
  const body = el('div', {
    id: 'backContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Estimate how much sugar, honey, or custom sweetener to add after fermentation to reach your desired sweetness. (Ensure your mead is stabilized first!)'
    }),
    el('label', { text: 'Current SG (after fermentation):' }),
    currentSG,
    el('label', { text: 'Desired Final SG:' }),
    desiredSG,
    el('label', { text: 'Volume (L):' }),
    volume,
    el('label', { text: 'Addition Type:' }),
    typeSel,
    customWrap,
    el('label', { text: 'Amount to Add (kg):' }),
    resultField,
    calcBtn,
    el('hr', {
      style: 'margin:10px 0;border:none;border-top:1px solid var(--border);'
    }),
    resultDiv
  ]);

  // === Legend / Collapsible ===
  const legend = el('legend', {
    text: 'üçØ Backsweetening Additions',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '‚ñ∂ ' : '‚ñº ') + 'üçØ Backsweetening Additions';
    }
  });

  // === Wrapper ===
  const card = el('div', {
    id: 'backsweetCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  // Initialize collapsed
  collapsed = true;
  body.style.display = 'none';

  // === Behavior for custom percent toggle ===
  typeSel.addEventListener('change', () => {
    customWrap.style.display = typeSel.value === 'custom' ? 'block' : 'none';
  });

  return card;
  updateFGOG();
  
}

/**
 * üíß Create the Dilution Calculator card dynamically using `el()`
 * Returns a collapsible fieldset with inputs and logic
 */
function dilutionCard() {
  let collapsed = true;

  // === Inputs ===
  const sg1Input = el('input', {
    id: 'dil_sg1',
    type: 'number',
    step: '0.001',
    value: '1.120',
    style: 'width:100%;margin-bottom:6px;'
  });

  const sg2Input = el('input', {
    id: 'dil_sg2',
    type: 'number',
    step: '0.001',
    value: '1.070',
    style: 'width:100%;margin-bottom:6px;'
  });

  const volumeInput = el('input', {
    id: 'dil_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const resultDiv = el('div', {
    id: 'dilResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  // === Logic ===
  const calcDilution = () => {
    const sg1 = parseFloat(sg1Input.value);
    const sg2 = parseFloat(sg2Input.value);
    const vol = parseFloat(volumeInput.value);

    if (isNaN(sg1) || isNaN(sg2) || isNaN(vol) || sg2 >= sg1) {
      resultDiv.textContent = '‚ö†Ô∏è Please enter valid values (target SG must be lower).';
      return;
    }

    // ‚Äúpoints‚Äù difference per SG
    const points1 = (sg1 - 1) * 1000;
    const points2 = (sg2 - 1) * 1000;

    // V1 * P1 = (V1 + Vx) * P2 ‚Üí solve for Vx
    const addWater = (vol * (points1 - points2)) / points2;

    resultDiv.innerHTML =
      `To dilute <b>${vol.toFixed(2)} L</b> of ${sg1.toFixed(3)} SG must ` +
      `to ${sg2.toFixed(3)} SG, add approximately <b>${addWater.toFixed(2)} L</b> of water.`;
  };

  // === Button ===
  const calcBtn = el('button', {
    id: 'calcDilution',
    class: 'btn-accent',
    text: 'Calculate Dilution',
    style: 'width:100%;',
    onclick: calcDilution
  });

  // === Body ===
  const body = el('div', {
    id: 'dilContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Determine how much water to add to reach your target specific gravity.'
    }),
    el('label', { text: 'Current SG:' }),
    sg1Input,
    el('label', { text: 'Target SG:' }),
    sg2Input,
    el('label', { text: 'Current Volume (L):' }),
    volumeInput,
    calcBtn,
    el('hr', {
      style: 'margin:10px 0;border:none;border-top:1px solid var(--border);'
    }),
    resultDiv
  ]);

  // === Legend / Collapsible ===
  const legend = el('legend', {
    text: 'üíß Dilution Calculator',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '‚ñ∂ ' : '‚ñº ') + 'üíß Dilution Calculator';
    }
  });

  // === Wrapper ===
  const card = el('div', {
    id: 'dilutionCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  collapsed = true;
  body.style.display = 'none';

  return card;
}

/**
 * üß™ Create the Priming Calculator card dynamically using `el()`
 * Returns a collapsible fieldset that estimates sugar needed for carbonation.
 */
function primingCard() {
  let collapsed = true;

  // === Inputs ===
  const volInput = el('input', {
    id: 'prime_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const tempInput = el('input', {
    id: 'prime_temp',
    type: 'number',
    step: '0.1',
    value: '20',
    style: 'width:100%;margin-bottom:6px;'
  });

  const co2Input = el('input', {
    id: 'prime_co2',
    type: 'number',
    step: '0.1',
    value: '2.5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const sugarSel = el('select', {
    id: 'prime_sugar',
    style: 'width:100%;margin-bottom:6px;'
  }, [
    el('option', { value: 'dextrose', text: 'Corn Sugar (Dextrose)', selected: true }),
    el('option', { value: 'sucrose', text: 'Table Sugar (Sucrose)' }),
    el('option', { value: 'honey', text: 'Honey' })
  ]);

  const resultDiv = el('div', {
    id: 'primeResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  // === Core Logic ===
  const calcPriming = () => {
    const vol = parseFloat(volInput.value);
    const temp = parseFloat(tempInput.value);
    const co2 = parseFloat(co2Input.value);
    const sugarType = sugarSel.value;

    if (isNaN(vol) || isNaN(temp) || isNaN(co2)) {
      resultDiv.textContent = '‚ö†Ô∏è Please enter valid volume, temperature, and CO‚ÇÇ level.';
      return;
    }

    // CO‚ÇÇ already in solution based on temp (empirical)
    const residualCO2 = 3.0378 - 0.050062 * temp + 0.00026555 * temp ** 2;

    // Difference to reach target
    const neededCO2 = co2 - residualCO2;
    if (neededCO2 <= 0) {
      resultDiv.textContent = 'No priming sugar needed ‚Äî CO‚ÇÇ already at or above target.';
      return;
    }

    // grams/L CO‚ÇÇ factor depending on sugar type
    let factor = 4.01; // g/L per CO‚ÇÇ volume for dextrose
    if (sugarType === 'sucrose') factor = 3.83;
    if (sugarType === 'honey') factor = 4.52;

    const grams = neededCO2 * vol * factor;
    const tsp = grams / 4.2; // rough tsp conversion

    resultDiv.innerHTML =
      `To reach <b>${co2.toFixed(2)} volumes CO‚ÇÇ</b> at ${temp.toFixed(1)}¬∞C ` +
      `for <b>${vol.toFixed(1)} L</b>, add approximately:<br>` +
      `<b>${grams.toFixed(1)} g</b> (${tsp.toFixed(1)} tsp) of ${sugarType}.`;
  };

  // === Button ===
  const calcBtn = el('button', {
    id: 'calcPriming',
    class: 'btn-accent',
    text: 'Calculate Priming Sugar',
    style: 'width:100%;',
    onclick: calcPriming
  });

  // === Body ===
  const body = el('div', {
    id: 'primeContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Estimate how much sugar to add for bottle carbonation. Experimental values only; verify before bottling!'
    }),
    el('label', { text: 'Batch Volume (L):' }),
    volInput,
    el('label', { text: 'Beer/Mead Temperature (¬∞C):' }),
    tempInput,
    el('label', { text: 'Target CO‚ÇÇ Volumes:' }),
    co2Input,
    el('label', { text: 'Sugar Type:' }),
    sugarSel,
    calcBtn,
    el('hr', { style: 'margin:10px 0;border:none;border-top:1px solid var(--border);' }),
    resultDiv
  ]);

  // === Collapsible Legend ===
  const legend = el('legend', {
    text: 'üß™ Priming Calculator (Experimental)',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent = (collapsed ? '‚ñ∂ ' : '‚ñº ') + 'üß™ Priming Calculator (Experimental)';
    }
  });

  // === Wrapper ===
  const card = el('div', {
    id: 'primingCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  collapsed = true;
  body.style.display = 'none';

  return card;
}

/**
 * ‚öóÔ∏è Create the Stabilisation Calculator card dynamically using `el()`
 * Helps estimate sorbate/sulfite additions to stabilize mead before backsweetening.
 */
function stabilCard() {
  let collapsed = true;

  // === Inputs ===
  const volInput = el('input', {
    id: 'stab_volume',
    type: 'number',
    step: '0.1',
    value: '5',
    style: 'width:100%;margin-bottom:6px;'
  });

  const campdenInput = el('input', {
    id: 'stab_campden',
    type: 'number',
    step: '0.1',
    value: '0.44',
    style: 'width:100%;margin-bottom:6px;'
  });

  const sorbateInput = el('input', {
    id: 'stab_sorbate',
    type: 'number',
    step: '0.1',
    value: '0.75',
    style: 'width:100%;margin-bottom:6px;'
  });

  const resultDiv = el('div', {
    id: 'stabResult',
    style: 'font-size:13px;color:var(--muted);'
  });

  // === Logic ===
  const calcStabil = () => {
    const vol = parseFloat(volInput.value);
    const campden = parseFloat(campdenInput.value);
    const sorbate = parseFloat(sorbateInput.value);

    if (isNaN(vol) || isNaN(campden) || isNaN(sorbate)) {
      resultDiv.textContent = '‚ö†Ô∏è Please enter valid numbers.';
      return;
    }

    // Campden tablets: each ‚âà 0.44g K-meta ‚Üí 50 mg SO‚ÇÇ per L for 5 L per tablet
    const campdenTotal = (vol * campden) / 5;
    const sorbateTotal = (vol * sorbate) / 5;

    resultDiv.innerHTML =
      `For <b>${vol.toFixed(1)} L</b> batch:<br>` +
      `Add approximately <b>${campdenTotal.toFixed(2)} g</b> potassium metabisulfite (‚âà ${(
        campdenTotal / 0.44
      ).toFixed(1)} tablets)<br>` +
      `and <b>${sorbateTotal.toFixed(2)} g</b> potassium sorbate.<br><br>` +
      `<i>Ensure fermentation has completely stopped before stabilising.</i>`;
  };

  // === Button ===
  const calcBtn = el('button', {
    id: 'calcStabil',
    class: 'btn-accent',
    text: 'Calculate Additions',
    style: 'width:100%;',
    onclick: calcStabil
  });

  // === Body ===
  const body = el('div', {
    id: 'stabContent',
    style: 'margin-top:8px;'
  }, [
    el('p', {
      style: 'font-size:13px;color:var(--muted);',
      text: 'Estimate stabilising agent additions before backsweetening. Typical use: 0.44 g K-meta and 0.75 g sorbate per 5 L.'
    }),
    el('label', { text: 'Batch Volume (L):' }),
    volInput,
    el('label', { text: 'K-meta (g per 5 L):' }),
    campdenInput,
    el('label', { text: 'K-sorbate (g per 5 L):' }),
    sorbateInput,
    calcBtn,
    el('hr', { style: 'margin:10px 0;border:none;border-top:1px solid var(--border);' }),
    resultDiv
  ]);

  // === Collapsible Legend ===
  const legend = el('legend', {
    text: '‚öóÔ∏è Stabilisation Calculator',
    style: 'cursor:pointer;',
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? 'none' : 'block';
      legend.textContent =
        (collapsed ? '‚ñ∂ ' : '‚ñº ') + '‚öóÔ∏è Stabilisation Calculator';
    }
  });

  // === Wrapper ===
  const card = el('div', {
    id: 'stabilCard',
    class: 'fieldset collapsible',
    style: 'margin-top:16px;'
  }, [legend, body]);

  collapsed = true;
  body.style.display = 'none';

  return card;
}

/**
 * üßÆ Create the Brix ‚Üî SG Converter card dynamically using `el()`
 * Converts between Brix (¬∞Bx) and Specific Gravity (SG)
 */
function brixCard() {
  let collapsed = true;

  // --- Conversion formulas ---
  const brixToSG = (brix) =>
    1 + (brix / (258.6 - ((brix / 258.2) * 227.1)));
  const sgToBrix = (sg) =>
    (((182.4601 * sg - 775.6821) * sg + 1262.7794) * sg - 669.5622);

  // --- Inputs ---
  const brixInput = el("input", {
    id: "brixInput",
    type: "number",
    step: "0.01",
    placeholder: "e.g. 20.5",
    style: "width:100%;margin-bottom:6px;"
  });

  const sgInput = el("input", {
    id: "sgInput",
    type: "number",
    step: "0.0001",
    placeholder: "e.g. 1.083",
    style: "width:100%;margin-bottom:6px;"
  });

  const resultDiv = el("div", {
    id: "brixResult",
    style: "font-size:13px;color:var(--muted);"
  });

  // --- Conversion logic ---
  const convertBrixToSG = () => {
    const brix = parseFloat(brixInput.value);
    if (isNaN(brix)) return (resultDiv.textContent = "‚ö†Ô∏è Enter a valid Brix value.");
    const sg = brixToSG(brix);
    sgInput.value = sg.toFixed(4);
    resultDiv.innerHTML = `<b>${brix.toFixed(2)} ¬∞Bx</b> = SG <b>${sg.toFixed(4)}</b>`;
  };

  const convertSGToBrix = () => {
    const sg = parseFloat(sgInput.value);
    if (isNaN(sg)) return (resultDiv.textContent = "‚ö†Ô∏è Enter a valid SG value.");
    const brix = sgToBrix(sg);
    brixInput.value = brix.toFixed(2);
    resultDiv.innerHTML = `SG <b>${sg.toFixed(4)}</b> = <b>${brix.toFixed(2)} ¬∞Bx</b>`;
  };

  const clearFields = () => {
    brixInput.value = "";
    sgInput.value = "";
    resultDiv.textContent = "";
  };

  // --- Buttons ---
  const btnBrixToSG = el("button", {
    class: "btn-accent",
    text: "Brix ‚Üí SG",
    style: "flex:1;",
    onclick: convertBrixToSG
  });
  const btnSGToBrix = el("button", {
    class: "btn-accent",
    text: "SG ‚Üí Brix",
    style: "flex:1;",
    onclick: convertSGToBrix
  });
  const btnClear = el("button", {
    class: "btn-danger",
    text: "Clear",
    style: "flex:1;",
    onclick: clearFields
  });

  const buttonRow = el("div", {
    class: "row",
    style: "margin-top:8px;gap:8px;"
  }, [btnBrixToSG, btnSGToBrix, btnClear]);

  // --- Body ---
  const body = el("div", {
    id: "brixContent",
    style: "margin-top:8px;"
  }, [
    el("p", {
      style: "font-size:13px;color:var(--muted);",
      text: "Convert between Brix and Specific Gravity using BrewersFriend formulas."
    }),
    el("label", { text: "Brix (¬∞Bx):" }),
    brixInput,
    el("label", { text: "Specific Gravity (SG):" }),
    sgInput,
    buttonRow,
    el("hr", { style: "margin:10px 0;border:none;border-top:1px solid var(--border);" }),
    resultDiv
  ]);

  // --- Collapsible Legend ---
  const legend = el("legend", {
    text: "üßÆ Brix ‚Üî SG Converter",
    style: "cursor:pointer;",
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? "none" : "block";
      legend.textContent = (collapsed ? "‚ñ∂ " : "‚ñº ") + "üßÆ Brix ‚Üî SG Converter";
    }
  });

  // --- Wrapper ---
  const card = el("div", {
    id: "brixConverterCard",
    class: "fieldset collapsible",
    style: "margin-top:16px;"
  }, [legend, body]);

  collapsed = true;
  body.style.display = "none";

  return card;
}

/**
 * üíæ Create the Backup & Restore header dynamically using `el()`
 * Provides a consistent styled header above cloud sync / backup section.
 */
function backupHeaderCard() {
  return el("div", {
    class: "fieldset",
    id: "backupHeader",
    style: `
      margin-top:16px;
      text-align:center;
      padding:10px 0;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    `
  }, [
    el("legend", {
      text: "üíæ Backup & Restore",
      style: `
        color: var(--accent);
        font-weight: 700;
        font-size: 15px;
        letter-spacing: 0.5px;
      `
    })
  ]);
}

/**
 * ‚òÅÔ∏è Create the Cloud Sync card dynamically using `el()`
 * Handles ExtendsClass JSON Storage cloud backup configuration.
 */
function syncCard() {
  let collapsed = true;

  // --- Info text ---
  const infoPara = el("p", {
    style: "font-size:13px;color:var(--muted);"
  }, [
    el("b", { text: "ExtendsClass JSON Storage" }),
    document.createTextNode(" (optional cloud backup)"),
    el("br"),
    document.createTextNode("‚Ä¢ Make a free account at "),
    el("a", {
      href: "https://extendsclass.com/json-storage.html",
      target: "_blank",
      text: "extendsclass.com/json-storage"
    }),
    el("br"),
    document.createTextNode("‚Ä¢ Copy your "),
    el("b", { text: "API key" }),
    document.createTextNode(" from your account."),
    el("br"),
    document.createTextNode("‚Ä¢ Paste it below to enable cloud sync.")
  ]);

  // --- API key input ---
  const apiInput = el("input", {
    id: "apiKeyInput",
    type: "text",
    placeholder: "Paste your ExtendsClass API key here",
    value: localStorage.getItem("EXTENDS_API_KEY") || "",
    style: `
      width:100%;margin:6px 0;padding:6px;
      border-radius:8px;border:1px solid var(--border);
      background:#0f141b;color:var(--text);
    `
  });

  // --- Save button ---
  const saveBtn = el("button", {
    id: "saveApiKeyBtn",
    class: "btn-accent",
    text: "Save API Key",
    style: "width:100%;",
    onclick: () => {
      const key = apiInput.value.trim();
      if (!key) {
        syncStatus.textContent = "‚ö†Ô∏è Please enter a valid API key.";
        return;
      }
      localStorage.setItem("EXTENDS_API_KEY", key);
      syncStatus.textContent = "‚òÅÔ∏è Cloud API key saved.";
      console.log("‚òÅÔ∏è Cloud API key saved:", key);
      updateViewBinButton();
    }
  });

  // --- View Bin button ---
// --- View Bin button ---
const viewBtn = el("button", {
  id: "viewBinBtn",
  class: "btn-accent",
  text: "üîó View Bin",
  style: "display:none;width:100%;margin-top:6px;",
  onclick: async (e) => {
    e.stopPropagation(); // prevent any parent event handlers
    const bin = localStorage.getItem("EXTENDS_BIN_ID");
    if (!bin) return alert("‚ö†Ô∏è No bin ID found yet.");

    try {
      const data = await cloudLoad(); // secure fetch with Security-key
      if (!data) return alert("‚ö†Ô∏è Could not load bin data.");

      // Open a single stylized popup window
      const popup = window.open("", "binPopup", "width=700,height=600,resizable,scrollbars=yes");
      if (!popup) return alert("‚ö†Ô∏è Popup blocked. Please allow popups for this site.");

      // Write the stylized HTML shell
      popup.document.write(`
        <html>
          <head>
            <title>MeadTrics Cloud Bin ‚Äì ${bin}</title>
            <style>
              body {
                background-color: #0f141b;
                color: #e4e9f0;
                font-family: monospace;
                padding: 16px;
                white-space: pre-wrap;
                overflow-wrap: anywhere;
              }
              h2 {
                font-family: system-ui, sans-serif;
                font-size: 16px;
                margin-top: 0;
                color: #ffd86b;
              }
              code {
                background: #1a2028;
                padding: 8px;
                display: block;
                border-radius: 8px;
                border: 1px solid #2a3340;
              }
            </style>
          </head>
          <body>
            <h2>Cloud Bin: ${bin}</h2>
            <code id="jsonArea">Loading...</code>
          </body>
        </html>
      `);
      popup.document.close();

      // Inject JSON safely after the popup document exists
      const jsonString = JSON.stringify(data, null, 2);
      popup.document.getElementById("jsonArea").textContent = jsonString;

      console.log("‚úÖ Cloud bin opened in popup");
    } catch (err) {
      console.error("Failed to load bin:", err);
      alert("‚ö†Ô∏è Failed to open bin.\n" + err.message);
    }
  }
});


  // --- Status + info ---
  const syncStatus = el("div", {
    id: "syncStatus",
    style: "margin-top:6px;color:var(--muted);font-size:13px;",
    text: "üíæ Local-only mode"
  });

  const syncUrl = el("span", { id: "syncUrl", text: "Local only" });
  const syncKey = el("span", { id: "syncKey", text: "meadtracker" }); // fixed key label

  const syncInfo = el("div", {
    id: "syncInfo",
    class: "tag",
    style: "display:block;word-break:break-all;"
  }, [
    el("b", { text: "Bin:" }), document.createTextNode(" "), syncUrl
  ]);

  const keyInfo = el("div", {
    class: "tag",
    style: "margin-top:4px;"
  }, [
    el("b", { text: "Security Key:" }), document.createTextNode(" "), syncKey
  ]);

  // --- Body ---
  const body = el("div", {
    id: "syncContent",
    style: "margin-top:8px;"
  }, [
    infoPara,
    apiInput,
    saveBtn,
    viewBtn,
    syncStatus,
    el("hr", { style: "margin:10px 0;border:none;border-top:1px solid var(--border);" }),
    syncInfo,
    keyInfo
  ]);

  // --- Legend (collapsible header) ---
  const legend = el("legend", {
    text: "‚òÅÔ∏è Cloud Sync",
    style: "cursor:pointer;",
    onclick: () => {
      collapsed = !collapsed;
      body.style.display = collapsed ? "none" : "block";
      legend.textContent = (collapsed ? "‚ñ∂ " : "‚ñº ") + "‚òÅÔ∏è Cloud Sync";
    }
  });

  // --- Wrapper ---
  const card = el("div", {
    id: "syncCard",
    class: "fieldset collapsible",
    style: "margin-top:16px;"
  }, [legend, body]);

  // --- Initial open/closed state ---
  const hasAPI = localStorage.getItem("EXTENDS_API_KEY");
  const hasBIN = localStorage.getItem("EXTENDS_BIN_ID");
  if (hasAPI && hasBIN) {
    collapsed = false;
    body.style.display = "block";
    legend.textContent = "‚ñº ‚òÅÔ∏è Cloud Sync";
  } else {
    collapsed = true;
    body.style.display = "none";
    legend.textContent = "‚ñ∂ ‚òÅÔ∏è Cloud Sync";
  }

  // --- Update View Bin visibility ---
  setTimeout(updateViewBinButton, 0);

  return card;
}




// === Feedback button + popup (dynamic) ===
function initFeedbackPopup() {
  // Remove any existing elements
  document.getElementById('feedbackBtn')?.remove();
  document.getElementById('feedbackPopup')?.remove();

  // Create floating feedback button
  const btn = el('button', {
    id: 'feedbackBtn',
    title: 'Send Feedback',
    class: 'icon-btn',
    text: 'üìù',
    onclick: () => popup.classList.remove('hidden')
  });

  // Create popup
  const popup = el('div', { id: 'feedbackPopup', class: 'popup hidden' }, [
    el('div', { class: 'popup-content' }, [
      el('h3', { text: 'Send Feedback' }),
      el('textarea', {
        id: 'feedbackText',
        placeholder: 'Describe your idea, bug, or suggestion...',
        rows: '5'
      }),
      el('div', { class: 'popup-actions' }, [
        el('button', {
          id: 'feedbackSubmit',
          class: 'primary',
          text: 'Submit',
          onclick: async () => {
            const text = document.getElementById('feedbackText').value.trim();
            if (!text) return alert('Please enter your feedback first!');
            console.log('üìù Feedback submitted:', text);
            alert('Thanks for your feedback!');
            popup.classList.add('hidden');
            document.getElementById('feedbackText').value = '';
          }
        }),
        el('button', {
          id: 'feedbackCancel',
          class: 'secondary',
          text: 'Cancel',
          onclick: () => popup.classList.add('hidden')
        })
      ])
    ])
  ]);

  // Append to body
  document.body.append(btn, popup);
}

// Initialize after render
initFeedbackPopup();


/**
 * Render the entire UI
 * Calls both the sidebar (batch list) and the detail panel
 */
function render() {
  renderBatchList();
  renderDetail();
}

/**
 * Render the sidebar batch list
 * Divides batches into Active and Archived sections,
 * supports search filtering, inline renaming, and deletion.
 */
function renderBatchList() {
  const list = document.getElementById('batchList');
  if (!list) return;

  // --- Clear old content ---
  list.innerHTML = '';

  // --- Filter + sort batches ---
  const q = document.getElementById('searchInput').value.trim().toLowerCase();

  const sorted = [...state.batches]
    .sort((a, b) => new Date(b.startDate) - new Date(a.startDate))
    .filter(b =>
      !q ||
      b.name.toLowerCase().includes(q) ||
      (b.description || '').toLowerCase().includes(q)
    );

  const active = sorted.filter(b => !b.events.some(e => e.type === 'bottled'));
  const archived = sorted.filter(b => b.events.some(e => e.type === 'bottled'));

  /**
   * Helper: collapsible batch section
   */
  const makeSection = (key, title, batches, emptyText) => {
    const isCollapsed = sidebarCollapse[key];
    const section = el('div', { class: 'fieldset', style: 'margin-bottom:12px;' });

    // --- Section header ---
    const header = el(
      'div',
      {
        class: 'row',
        style: `
          display:flex;
          align-items:center;
          justify-content:flex-start;
          gap:6px;
          cursor:pointer;
          user-select:none;
        `,
        onclick: () => {
          sidebarCollapse[key] = !sidebarCollapse[key];
          renderBatchList(); // re-render sidebar only
        }
      },
      [
        el('legend', { text: title }),
        el('span', {
          text: isCollapsed ? '‚ñ∂' : '‚ñº',
          style: 'font-size:14px;margin-left:4px;'
        })
      ]
    );

    section.append(header);

    if (isCollapsed) return section;

    // --- Empty message ---
    if (!batches.length) {
      section.append(el('div', { class: 'empty', text: emptyText }));
      return section;
    }

    // --- Each batch item ---
    batches.forEach(b => {
      const item = el('div', { class: 'batch' });

      // --- Inline rename ---
      const nameEl = (() => {
        const nameDiv = el('div', {
          class: 'name',
          text: b.name,
          title: 'Click to rename batch'
        });
        nameDiv.style.cursor = 'pointer';
        nameDiv.addEventListener('click', e => {
          e.stopPropagation();
          const input = el('input', {
            type: 'text',
            value: b.name,
            class: 'wide',
            style: `
              font-size:13px;
              font-weight:600;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              border-radius:6px;
              padding:4px 6px;
            `
          });
          const commit = () => {
            const newName = input.value.trim();
            if (newName) b.name = newName;
            saveAll(state, b, ['name']);
            render();
          };
          input.addEventListener('blur', commit);
          input.addEventListener('keydown', ev => {
            if (ev.key === 'Enter') input.blur();
            if (ev.key === 'Escape') render();
          });
          nameDiv.replaceWith(input);
          input.focus();
          input.select();
        });
        return nameDiv;
      })();

      // --- Delete button ---
      const delBtn = el('button', {
        text: '‚úï',
        class: 'btn-danger',
        title: 'Delete batch',
        onclick: e => {
          e.stopPropagation();
          if (!confirm(`Delete batch ‚Äú${b.name}‚Äù? This cannot be undone.`)) return;
          const i = state.batches.indexOf(b);
          if (i >= 0) {
            state.batches.splice(i, 1);
            if (selectedId === b.id) selectedId = state.batches[0]?.id || null;
            saveAll(state);
            render();
          }
        }
      });

      const headerRow = el('div', {
        class: 'row',
        style: 'justify-content:space-between;align-items:center;'
      }, [nameEl, delBtn]);

      // --- Metadata ---
      const latestSG = b.sgReadings?.length
        ? b.sgReadings[b.sgReadings.length - 1].sg
        : null;
      const abv = calcABV(b.og, latestSG);

      const bottledEvent = b.events.find(e => e.type === 'bottled');
      const maturityText = bottledEvent
        ? `üß≠ Mature: ${formatMaturityDays(bottledEvent.date)}`
        : '';
      const fermentText =
        !bottledEvent && b.startDate
          ? `üß™ ${formatFermentationDays(b.startDate)}`
          : '';

      let sugarBreakText = '';
      if (!bottledEvent && b.og) {
        const target = calcSugarBreak(b.og);
        if (target) sugarBreakText = `üçØ 1/3 Sugar Break: ${target}`;
      }

      const metaText =
        `${fmt(b.startDate)} ¬∑ OG ${b.og}` +
        (latestSG ? ` ¬∑ FG ${latestSG}` : '') +
        (abv ? ` ¬∑ ~${abv.toFixed(1)}% ABV` : '') +
        (fermentText ? `\n${fermentText}` : '') +
        (sugarBreakText ? `\n${sugarBreakText}` : '') +
        (maturityText ? `\n${maturityText}` : '');

      item.append(headerRow, el('div', { class: 'meta', text: metaText }));
      item.classList.toggle('active', b.id === selectedId);

      item.addEventListener('click', () => {
        selectedId = b.id;
        render();
      });

      section.append(item);
    });

    return section;
  };

  // --- Sidebar Build Order ---
  list.append(batchHeaderCard());
  list.append(makeSection('active', 'üß™ Active Batches', active, 'No active batches.'));
  list.append(makeSection('archived', 'üçæ Archived (Bottled)', archived, 'No bottled batches.'));
  list.append(utilitiesHeaderCard());
  list.append(tosnaCard());
  list.append(backsweetCard());
  list.append(dilutionCard());
  list.append(primingCard());
  list.append(stabilCard());
  list.append(brixCard());
  list.append(backupHeaderCard());
  list.append(syncCard());

  // --- Re-attach listeners after render ---
  initTosnaBindings();
}


/**
 * Render the main batch detail view.
 * Displays selected batch info, metadata, chart, and related forms.
 * If no batch is selected, shows the "New Batch" creation form instead.
 */
function renderDetail() {
  const root = document.getElementById('detail'); // main detail panel
  const batch = state.batches.find(b => b.id === selectedId); // selected batch

  // --- Empty state ---
  if (!batch) {
    root.innerHTML = '';
    root.append(newBatchForm());
    return;
  }

  // --- Clear previous content ---
  root.innerHTML = '';

  // === TITLE ROW ===
  const titleRow = (() => {
    const row = el('div', {
      class: 'row',
      style: 'justify-content: space-between; align-items: center;'
    });

    // --- Click-to-rename batch title ---
    const title = el('h2', {
      text: batch.name,
      title: 'Click to rename batch'
    });
    title.style.cursor = 'pointer';
    title.addEventListener('click', () => {
      const input = el('input', {
        type: 'text',
        value: batch.name,
        class: 'wide',
        style: `
          font-size:20px;
          font-weight:700;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
          border-radius:8px;
          padding:6px 10px;
        `
      });
      const commit = () => {
        const newName = input.value.trim();
        if (newName) batch.name = newName;
        saveAll(state, batch, ['name']);
        render();
      };
      input.addEventListener('blur', commit);
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') input.blur();
        if (e.key === 'Escape') render();
      });
      title.replaceWith(input);
      input.focus();
      input.select();
    });

    // --- Duplicate batch button ---
    const dupBtn = el('button', {
      text: 'üîÅ Duplicate',
      class: 'btn-accent',
      title: 'Duplicate this batch',
      style: 'padding:4px 10px;font-size:13px;',
      onclick: () => {
        if (!confirm(`Duplicate batch ‚Äú${batch.name}‚Äù?`)) return;
        const today = new Date().toISOString().slice(0, 10);
        const id = crypto.randomUUID();
        const clone = {
          id,
          name: batch.name + ' (Copy)',
          startDate: today,
          og: batch.og,
          honey: batch.honey,
          yeast: batch.yeast,
          volume: batch.volume,
          description: batch.description,
          sgReadings: [],
          events: [{ date: today, type: 'primary fermentation' }],
          ingredients: JSON.parse(JSON.stringify(batch.ingredients || []))
        };
        state.batches.push(clone);
        selectedId = id;
        saveAll(state);
        render();
        alert(`Batch ‚Äú${batch.name}‚Äù duplicated as ‚Äú${clone.name}‚Äù.`);
      }
    });

    // --- Label Maker button ---
    const labelBtn = el('button', {
      text: 'üñ®Ô∏è Label Maker',
      class: 'btn-accent',
      title: 'Generate a printable bottle label',
      style: 'padding:4px 10px;font-size:13px;',
      onclick: () => openLabelMaker(batch)
    });

    row.append(title, dupBtn, labelBtn);
    return row;
  })();

  // === METADATA & SUMMARY ===
  const summarySection = (() => {
    const sugarBreak = calcSugarBreak(batch.og);

    let currentSG = null;
    if (Array.isArray(batch.sgReadings) && batch.sgReadings.length > 0) {
      const last = batch.sgReadings[batch.sgReadings.length - 1];
      currentSG = typeof last === 'object' ? last.sg : last;
    }

    const abv = calcABV(batch.og, currentSG);
    console.log('Current SG reading for', batch.name, ':', currentSG, batch.sgReadings);

    const text =
      `Started ${fmt(batch.startDate)} ¬∑ OG ${batch.og}` +
      (currentSG ? ` ¬∑ SG ${currentSG}` : '') +
      (abv ? ` ¬∑ ABV ${abv.toFixed(1)}%` : '') +
      (sugarBreak ? ` ¬∑ 1/3 Break: ${sugarBreak}` : '');

    const metaLine = el('div', { text });
    const honeyLine = el('div', {
      class: 'meta',
      text:
        `${batch.honey ? 'Honey: ' + batch.honey + ' ¬∑ ' : ''}` +
        `${batch.yeast ? 'Yeast: ' + batch.yeast + ' ¬∑ ' : ''}` +
        `${batch.volume ? 'Volume: ' + batch.volume + 'L' : ''}`
    });

    return el('div', {}, [metaLine, honeyLine]);
  })();

  // === MAIN INTERACTIVE COMPONENTS ===
  const components = [
    chartCard(batch),
    sgFormCard(batch),
    eventFormCard(batch),
    ingredientsTable(batch),
    eventsTable(batch)
  ];

  // === Build and render full detail view ===
  const container = el('div', {}, [titleRow, summarySection, ...components]);
  root.append(container);

  // === Render chart ===
  drawChart(batch);
}


/**
 * Create the chart fieldset for displaying fermentation data.
 * Shows a graph of Specific Gravity (SG) or ABV (%) over time,
 * with a toggle button to switch between the two views.
 *
 * @param {Object} batch - The current batch object being displayed
 * @returns {HTMLElement} - A <fieldset> element containing the chart UI
 */
function chartCard(batch) {
  return el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    // --- Collapsible legend / title ---
    el('legend', {
      text: 'üìà Gravity & ABV Over Time',
      style: 'font-weight:600;'
    }),

    // --- Header row with chart mode + toggle ---
    el('div', {
      class: 'row',
      style: `
        justify-content: space-between;
        align-items: center;
        margin-bottom:8px;
      `
    }, [
      el('span', {
        id: 'chartModeLabel',
        text: chartMode === 'sg'
          ? 'Showing Specific Gravity'
          : 'Showing ABV (%)',
        style: 'font-size:13px;color:var(--muted);'
      }),
      el('button', {
        id: 'chartModeToggle',
        class: 'btn-accent',
        text: chartMode === 'sg' ? 'Switch to ABV' : 'Switch to SG',
        style: 'padding:3px 10px;font-size:12px;',
        onclick: () => {
          chartMode = chartMode === 'sg' ? 'abv' : 'sg';
          render(); // re-render full detail view to refresh chart
        }
      })
    ]),

    // --- Canvas container ---
    el('canvas', {
      id: 'sgChart',
      width: 800,
      height: 260,
      style: `
        width:100%;
        max-width:800px;
        border-radius:8px;
        background:#0f141b;
        box-shadow:var(--shadow);
      `
    })
  ]);
}

/**
 * Create a fieldset form for adding new Specific Gravity (SG) readings.
 * Each reading updates both the batch‚Äôs sgReadings array and event log.
 *
 * @param {Object} batch - The batch object to which the reading belongs
 * @returns {HTMLElement} - A <fieldset> element containing the SG input form
 */
function sgFormCard(batch) {
  // === Outer container ===
  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: 'üìè Add Specific Gravity Reading',
      style: 'font-weight:600;'
    })
  ]);

  // === Form layout ===
  const form = el('div', {
    class: 'grid',
    style: 'gap:8px;'
  }, [
    // --- Date column ---
    el('div', { class: 'col-6' }, [
      el('label', { text: 'Date' }),
      el('input', {
        id: 'sgDate',
        type: 'date',
        value: new Date().toISOString().slice(0, 10),
        style: `
          width:100%;
          border-radius:6px;
          padding:6px;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
        `
      })
    ]),

    // --- SG column ---
    el('div', { class: 'col-6' }, [
      el('label', { text: 'Specific Gravity (SG)' }),
      el('input', {
        id: 'sgValue',
        type: 'number',
        step: '0.001',
        min: '0.800',
        max: '1.500',
        placeholder: 'e.g. 1.045',
        style: `
          width:100%;
          border-radius:6px;
          padding:6px;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
        `
      })
    ])
  ]);

  // === Button ===
  const addBtn = el('button', {
    class: 'btn-accent',
    text: 'Add Reading',
    style: 'margin-top:10px;width:100%;',
    onclick: () => {
      const date = form.querySelector('#sgDate').value;
      const sgNum = parseFloat(form.querySelector('#sgValue').value);

      if (!date || !isFinite(sgNum)) {
        alert('Please enter a valid date and SG value.');
        return;
      }

      const sgStr = sgNum.toFixed(3);
      const sgId = crypto.randomUUID();

      // --- Add reading ---
      batch.sgReadings.push({ id: sgId, date, sg: sgStr });
      batch.sgReadings.sort((a, b) => new Date(a.date) - new Date(b.date));

      // --- Add event for reading ---
      batch.events.push({
        date,
        type: 'added sg reading',
        sg: sgStr,
        sgId,
        note: `SG: ${sgStr}`
      });

      // --- Save and re-render ---
      saveAll(state, batch, ['sgReadings', 'events']);
      render();
    }
  });

  // === Assemble card ===
  card.append(form, addBtn);
  return card;
}


/**
 * Create a fieldset form for adding general events or notes to a batch.
 * Supports predefined event types (fermentation stages, racking, etc.)
 * and a custom "note" type with free-text input.
 *
 * @param {Object} batch - The current batch to which the event will be added
 * @returns {HTMLElement} - A <fieldset> element containing the event form
 */
function eventFormCard(batch) {
  const today = new Date().toISOString().slice(0, 10);

  // === Outer container ===
  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: 'üóìÔ∏è Add Event',
      style: 'font-weight:600;'
    })
  ]);

  // === Main grid layout ===
  const grid = el('div', {
    class: 'grid',
    style: 'gap:8px;'
  });

  // --- Date input ---
  const dateInput = el('input', {
    id: 'evDate',
    type: 'date',
    value: today,
    style: `
      width:100%;
      border-radius:6px;
      padding:6px;
      border:1px solid var(--border);
      background:#0f141b;
      color:var(--text);
    `
  });
  const dateCol = el('div', { class: 'col-6' }, [
    el('label', { for: 'evDate', text: 'Date' }),
    dateInput
  ]);

  // --- Event type selector ---
  const typeSelect = (() => {
    const sel = el('select', {
      id: 'evType',
      style: `
        width:100%;
        border-radius:6px;
        padding:6px;
        border:1px solid var(--border);
        background:#0f141b;
        color:var(--text);
      `
    });
    [...EVENTS, 'note'].forEach(e =>
      sel.append(el('option', { value: e, text: e }))
    );
    return sel;
  })();

  const typeCol = el('div', { class: 'col-6' }, [
    el('label', { for: 'evType', text: 'Event Type' }),
    typeSelect
  ]);

  // --- Note textarea (hidden unless type === 'note') ---
  const noteWrap = el('div', {
    class: 'col-12',
    id: 'noteWrap',
    style: 'display:none;'
  }, [
    el('label', { for: 'evNote', text: 'Note Text' }),
    el('textarea', {
      id: 'evNote',
      placeholder: 'Write a note about this batch...',
      style: `
        width:100%;
        min-height:60px;
        border-radius:6px;
        padding:6px;
        border:1px solid var(--border);
        background:#0f141b;
        color:var(--text);
        resize:vertical;
      `
    })
  ]);

  // --- Add Event button ---
  const addBtn = el('button', {
    class: 'btn-accent',
    text: 'Add Event',
    style: 'width:100%;margin-top:8px;',
    onclick: () => {
      const date = dateInput.value;
      const type = typeSelect.value;
      const note = card.querySelector('#evNote')?.value.trim() || '';

      if (!date || !type) {
        alert('Please choose a date and event.');
        return;
      }

      const ev = { date, type };
      if (type === 'note' && note) ev.note = note;

      batch.events.push(ev);
      saveAll(state, batch, ['events']);
      render();

      // Optional: notify when bottled
      if (ev.type === 'bottled') {
        // alert(`Batch ‚Äú${batch.name}‚Äù marked as bottled and moved to Archived.`);
      }
    }
  });

  const btnRow = el('div', { class: 'col-12' }, [addBtn]);

  // --- Assemble grid ---
  grid.append(dateCol, typeCol, noteWrap, btnRow);
  card.append(grid);

  // --- Dynamic note visibility ---
  typeSelect.addEventListener('change', () => {
    noteWrap.style.display = typeSelect.value === 'note' ? 'block' : 'none';
  });

  return card;
}


/**
 * Create a table displaying all events and notes for a batch.
 * Includes editable note fields, event deletion, and logic to
 * remove linked SG readings when their associated event is deleted.
 *
 * @param {Object} batch - The batch whose events should be displayed
 * @returns {HTMLElement} - A <fieldset> element containing the events table
 */
function eventsTable(batch) {
  // === Outer container ===
  const card = el("div", {
    class: "fieldset",
    style: "margin-top:16px;"
  }, [
    el("legend", {
      text: "üìú Events & Notes",
      style: "font-weight:600;"
    })
  ]);

  // === Table ===
  const table = el("table", {
    class: "table",
    style: `
      width:100%;
      border-collapse:collapse;
      border:1px solid var(--border);
      border-radius:8px;
      overflow:hidden;
      font-size:13px;
    `
  });

  // === Table header ===
  const thead = el("thead", {}, [
    el("tr", {}, [
      el("th", { text: "Date" }),
      el("th", { text: "Event Type" }),
      el("th", { text: "Note / SG" }),
      el("th", { text: "" }) // delete button column
    ])
  ]);

  const tbody = el("tbody");

  // === Populate table ===
  batch.events
    .slice()
    .sort((a, b) => new Date(a.date) - new Date(b.date))
    .forEach(ev => {
      const tr = el("tr", {}, []);
      tr.dataset.type = ev.type;

      // --- Date ---
      const dateCell = el("td", { text: fmt(ev.date) });

      // --- Type ---
      const typeCell = el("td", { text: ev.type });

      // --- Note / SG cell ---
      const noteCell = (() => {
        const td = el("td");
        if (ev.type === "note") {
          const textarea = el("textarea", {
            style: `
              width:100%;
              min-height:28px;
              border-radius:6px;
              padding:4px;
              border:1px solid var(--border);
              background:#0f141b;
              color:var(--text);
              resize:vertical;
            `,
            value: ev.note || "",
            oninput: e => {
              ev.note = e.target.value;
              saveAll(state, batch, ["events"]);
            }
          });
          td.append(textarea);
        } else if (ev.type === "added sg reading") {
          const sgSpan = el("span", {
            text: `SG: ${ev.sg}`,
            title: "Double-click to edit SG reading",
            style: "cursor:pointer;"
          });

          sgSpan.addEventListener("dblclick", () => {
            const input = el("input", {
              type: "number",
              step: "0.001",
              min: "0.800",
              max: "1.500",
              value: ev.sg,
              style: `
                width:80px;
                border-radius:6px;
                padding:4px;
                border:1px solid var(--border);
                background:#0f141b;
                color:var(--text);
              `
            });

            const commit = () => {
              const newVal = parseFloat(input.value);
              if (!isFinite(newVal)) return render();
              const sgStr = newVal.toFixed(3);
              ev.sg = sgStr;
              ev.note = `SG: ${sgStr}`;

              // Update linked SG reading if present
              if (ev.sgId) {
                const r = batch.sgReadings.find(x => x.id === ev.sgId);
                if (r) r.sg = sgStr;
              } else {
                const r = batch.sgReadings.find(x => x.date === ev.date);
                if (r) r.sg = sgStr;
              }

              saveAll(state, batch, ["sgReadings", "events"]);
              render();
            };

            input.addEventListener("blur", commit);
            input.addEventListener("keydown", e => {
              if (e.key === "Enter") input.blur();
              if (e.key === "Escape") render();
            });

            sgSpan.replaceWith(input);
            input.focus();
            input.select();
          });

          td.append(sgSpan);
        } else {
          td.textContent =
            ev.note ||
            (ev.sg ? `SG: ${ev.sg}` : "") ||
            ev.type;
        }
        return td;
      })();

      // --- Delete Button ---
      const delCell = el("td", {}, [
        el("button", {
          text: "‚úï",
          class: "btn-danger",
          title: "Delete event",
          style: "padding:2px 6px;font-size:12px;",
          onclick: () => {
            const i = batch.events.indexOf(ev);
            if (i >= 0) {
              batch.events.splice(i, 1);

              // Remove linked SG reading if applicable
              if (ev.type === "added sg reading") {
                if (ev.sgId) {
                  const idx = batch.sgReadings.findIndex(r => r.id === ev.sgId);
                  if (idx >= 0) batch.sgReadings.splice(idx, 1);
                } else {
                  const evSg = ev.sg || (ev.note && ev.note.match(/([\d.]+)/)?.[1]);
                  const idx = batch.sgReadings.findIndex(r =>
                    r.date === ev.date &&
                    Math.abs(parseFloat(r.sg) - parseFloat(evSg)) < 0.00051
                  );
                  if (idx >= 0) batch.sgReadings.splice(idx, 1);
                }
              }

              saveAll(state, batch, ["sgReadings", "events"]);
              render();
            }
          }
        })
      ]);

      tr.append(dateCell, typeCell, noteCell, delCell);
      tbody.append(tr);
    });

  table.append(thead, tbody);
  card.append(table);

  return card;
}


/**
 * Create an editable table for managing the batch's ingredient list.
 * Allows live editing of honey, sugar, water, and additives,
 * as well as adding or removing ingredient rows dynamically.
 *
 * @param {Object} batch - The batch object whose ingredients are displayed
 * @returns {HTMLElement} - A <fieldset> element containing the editable table
 */
function ingredientsTable(batch) {
  // --- Ensure ingredients array exists ---
  if (!batch.ingredients) batch.ingredients = [];

  // === Outer container ===
  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: 'üçØ Ingredients',
      style: 'font-weight:600;'
    })
  ]);

  // === Build table ===
  const table = el('table', {
    class: 'table',
    style: `
      width:100%;
      border-collapse:collapse;
      border:1px solid var(--border);
      border-radius:8px;
      overflow:hidden;
      font-size:13px;
    `
  });

  // --- Table header ---
  const thead = el('thead', {}, [
    el('tr', {}, [
      el('th', { text: 'Honey (kg)' }),
      el('th', { text: 'Sugar (kg)' }),
      el('th', { text: 'Water (L)' }),
      el('th', { text: 'Additives' }),
      el('th', { text: '' })
    ])
  ]);

  const tbody = el('tbody');

  // === Render rows ===
  batch.ingredients.forEach(ing => {
    const tr = el('tr', {}, []);

    ['honey', 'sugar', 'water', 'additives'].forEach(key => {
      const td = el('td');
      const input = el('input', {
        type: key === 'additives' ? 'text' : 'number',
        step: '0.1',
        value: ing[key] ?? '',
        style: `
          width:100%;
          border-radius:6px;
          padding:4px;
          border:1px solid var(--border);
          background:#0f141b;
          color:var(--text);
        `,
        oninput: e => {
          ing[key] = key === 'additives'
            ? e.target.value
            : parseFloat(e.target.value) || '';
          saveAll(state, batch, ['ingredients']);
        }
      });
      td.append(input);
      tr.append(td);
    });

    // --- Delete row button ---
    const delBtn = el('button', {
      text: '‚úï',
      class: 'btn-danger',
      title: 'Delete ingredient row',
      style: 'padding:2px 6px;font-size:12px;',
      onclick: () => {
        const i = batch.ingredients.indexOf(ing);
        if (i >= 0) batch.ingredients.splice(i, 1);
        saveAll(state, batch, ['ingredients']);
        render();
      }
    });

    tr.append(el('td', {}, [delBtn]));
    tbody.append(tr);
  });

  table.append(thead, tbody);

  // === Add Ingredient button ===
  const addRowBtn = el('button', {
    text: '+ Add Ingredient',
    class: 'btn-accent',
    style: 'margin-top:10px;width:100%;',
    onclick: () => {
      batch.ingredients.push({
        honey: '',
        sugar: '',
        water: '',
        additives: ''
      });
      saveAll(state, batch, ['ingredients']);
      render();
    }
  });

  card.append(table, addRowBtn);
  return card;
}


/**
 * Create a form for adding a new mead batch.
 * Captures basic batch info (name, OG, yeast, volume, etc.),
 * optional ingredients, and creates an initialized batch record
 * with a default "primary fermentation" event.
 *
 * @returns {HTMLElement} - A <fieldset> element containing the new batch form
 */
function newBatchForm() {
  const today = new Date().toISOString().slice(0, 10);

  // === Outer container ===
  const card = el('div', {
    class: 'fieldset',
    style: 'margin-top:16px;'
  }, [
    el('legend', {
      text: '‚ú® Create New Batch',
      style: 'font-weight:600;'
    })
  ]);

  // === Helper for consistent input styling ===
  const inputStyle = `
    width:100%;
    border-radius:6px;
    padding:6px;
    border:1px solid var(--border);
    background:#0f141b;
    color:var(--text);
    margin-bottom:8px;
  `;

  // === Basic Info ===
  const basicInfo = el('div', {}, [
    el('label', { text: 'Name' }),
    el('input', { id: 'bName', type: 'text', placeholder: 'e.g. Bochet #3', style: inputStyle }),

    el('label', { text: 'Start Date' }),
    el('input', { id: 'bDate', type: 'date', value: today, style: inputStyle }),

    el('label', { text: 'Original Gravity (OG)' }),
    el('input', {
      id: 'bOG',
      type: 'number',
      step: '0.001',
      min: '0.900',
      max: '1.500',
      placeholder: 'e.g. 1.100',
      style: inputStyle
    }),

    el('label', { text: 'Honey Type' }),
    el('input', { id: 'bHoney', type: 'text', placeholder: 'e.g. Wildflower, Clover, Orange Blossom', style: inputStyle }),

    el('label', { text: 'Yeast Strain' }),
    el('input', { id: 'bYeast', type: 'text', placeholder: 'e.g. Lalvin D47, EC-1118', style: inputStyle }),

    el('label', { text: 'Volume (L)' }),
    el('input', { id: 'bVolume', type: 'number', step: '0.1', min: '0.1', placeholder: 'e.g. 5.0', style: inputStyle })
  ]);

  // === Optional Ingredients Subsection ===
  const ingSet = el('div', {
    class: 'fieldset',
    style: 'margin-top:10px;'
  }, [
    el('legend', { text: 'üçØ Ingredients (optional)', style: 'font-weight:600;' }),
    el('div', { class: 'grid', style: 'gap:8px;' }, [
      el('div', { class: 'col-4' }, [
        el('label', { text: 'Honey (kg)' }),
        el('input', { id: 'bHoneyWeight', type: 'number', step: '0.1', placeholder: 'e.g. 2.5', style: inputStyle })
      ]),
      el('div', { class: 'col-4' }, [
        el('label', { text: 'Sugar (kg)' }),
        el('input', { id: 'bSugar', type: 'number', step: '0.1', placeholder: 'optional', style: inputStyle })
      ]),
      el('div', { class: 'col-4' }, [
        el('label', { text: 'Water (L)' }),
        el('input', { id: 'bWater', type: 'number', step: '0.1', placeholder: 'e.g. 4.5', style: inputStyle })
      ]),
      el('div', { class: 'col-12' }, [
        el('label', { text: 'Additives (fruit, spices)' }),
        el('input', { id: 'bAdditives', type: 'text', placeholder: 'e.g. orange peel, cinnamon, vanilla bean', style: inputStyle })
      ])
    ])
  ]);

  // === Description ===
  const desc = el('div', { style: 'margin-top:10px;' }, [
    el('label', { text: 'Description / Notes' }),
    el('textarea', {
      id: 'bDesc',
      placeholder: 'Optional notes about this batch...',
      style: `
        ${inputStyle}
        min-height:80px;
        resize:vertical;
      `
    })
  ]);

  // === Create Batch Button ===
  const createBtn = el('button', {
    class: 'btn-accent',
    text: 'Create Batch',
    style: 'margin-top:10px;width:100%;',
    onclick: () => {
      const name = card.querySelector('#bName').value.trim();
      const startDate = card.querySelector('#bDate').value;
      const og = parseFloat(card.querySelector('#bOG').value);
      const honey = card.querySelector('#bHoney').value.trim();
      const yeast = card.querySelector('#bYeast').value.trim();
      const volume = parseFloat(card.querySelector('#bVolume').value);
      const description = card.querySelector('#bDesc').value.trim();

      const honeyWeight = parseFloat(card.querySelector('#bHoneyWeight').value);
      const sugar = parseFloat(card.querySelector('#bSugar').value);
      const water = parseFloat(card.querySelector('#bWater').value);
      const additives = card.querySelector('#bAdditives').value.trim();

      if (!name || !startDate || !isFinite(og)) {
        alert('Please fill in name, date, and OG.');
        return;
      }

      const id = crypto.randomUUID();
      const batch = {
        id,
        name,
        startDate,
        og: og.toFixed(3),
        honey,
        yeast,
        volume: isFinite(volume) ? volume.toFixed(1) : null,
        description,
        sgReadings: [],
        events: [{ date: startDate, type: 'primary fermentation' }],
        ingredients: []
      };

      // Optional ingredients
      if (isFinite(honeyWeight) || isFinite(sugar) || isFinite(water) || additives) {
        batch.ingredients.push({
          honey: isFinite(honeyWeight) ? honeyWeight.toFixed(1) : '',
          sugar: isFinite(sugar) ? sugar.toFixed(1) : '',
          water: isFinite(water) ? water.toFixed(1) : '',
          additives
        });
      }

      state.batches.push(batch);
      selectedId = id;
      saveAll(state);
      render();
    }
  });

  // === Assemble final form ===
  card.append(basicInfo, ingSet, desc, createBtn);
  return card;
}


/* === Utility Functions === */

/**
 * Calculate the 1/3 sugar break gravity.
 * Formula: 1 + (OG - 1) / 3
 * Returns a 3-decimal formatted string.
 */
function calcSugarBreak(og) {
  const ogNum = parseFloat(og);
  if (!isFinite(ogNum) || ogNum < 0.9 || ogNum > 1.5) return null;
  const sgBreak = 1 + (ogNum - 1) / 3;
  return sgBreak.toFixed(3);
}

/**
 * Calculate Alcohol by Volume (ABV) based on original and final gravity.
 * Formula: (OG ‚àí FG) √ó 131.25
 * Returns null if either value is missing or invalid.
 */
function calcABV(og, fg) {
  if (!og || !fg) return null;
  const OG = parseFloat(og), FG = parseFloat(fg);
  if (!isFinite(OG) || !isFinite(FG)) return null;
  return (OG - FG) * 131.25;
}

/**
 * Format how long ago a batch was bottled, expressed as
 * days, weeks, or months (e.g., ‚Äú3 weeks old‚Äù, ‚Äú2 months 1 wk old‚Äù).
 */
function formatMaturityDays(bottledDate) {
  const diffMs = Date.now() - new Date(bottledDate).getTime();
  const days = Math.floor(diffMs / 86400000);

  if (isNaN(days)) return 'Unknown age';
  if (days < 0) return 'Future date';
  if (days === 0) return 'Bottled today';
  if (days === 1) return '1 day old';
  if (days < 7) return `${days} days old`;

  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `${weeks} week${weeks !== 1 ? 's' : ''} old`;

  const months = Math.floor(days / 30.44);
  const remainingDays = Math.round(days - months * 30.44);
  const extraWeeks = Math.floor(remainingDays / 7);

  let result = `${months} month${months !== 1 ? 's' : ''}`;
  if (extraWeeks >= 1) result += ` ${extraWeeks} wk`;
  return result + ' old';
}


/**
 * Format fermentation duration since start date,
 * returning readable strings like ‚ÄúFermenting for 3 days‚Äù
 * or ‚ÄúFermenting for 2 months 1 wk‚Äù.
 */
function formatFermentationDays(startDate) {
  const diffMs = Date.now() - new Date(startDate).getTime();
  const days = Math.floor(diffMs / 86400000);

  if (isNaN(days)) return 'Unknown start date';
  if (days < 0) return 'Future start date';
  if (days === 0) return 'Started today';
  if (days === 1) return 'Fermenting for 1 day';
  if (days < 7) return `Fermenting for ${days} days`;

  const weeks = Math.floor(days / 7);
  if (weeks < 8) return `Fermenting for ${weeks} week${weeks !== 1 ? 's' : ''}`;

  const months = Math.floor(days / 30.44);
  const remainingDays = Math.round(days - months * 30.44);
  const extraWeeks = Math.floor(remainingDays / 7);

  let result = `Fermenting for ${months} month${months !== 1 ? 's' : ''}`;
  if (extraWeeks >= 1) result += ` ${extraWeeks} wk`;
  return result;
}


/* === Chart Rendering === */

/**
 * Draw a line chart showing either Specific Gravity (SG)
 * or ABV (%) progression over time for the selected batch.
 */

function drawChart(batch) {
  const c = document.getElementById('sgChart');
  if (!c) return;

  const ctx = c.getContext('2d');
  const pad = { l: 45, r: 10, t: 10, b: 28 };

  // Retina scaling
  const dpr = window.devicePixelRatio || 1;
  const logicalW = 800;
  const logicalH = 260;
  c.width = logicalW * dpr;
  c.height = logicalH * dpr;
  c.style.width = logicalW + 'px';
  c.style.height = logicalH + 'px';
  ctx.scale(dpr, dpr);

  // Prepare data
  const readings = (batch.sgReadings || [])
    .slice()
    .sort((a, b) => new Date(a.date) - new Date(b.date));

  if (!readings.length || readings[0].date !== batch.startDate)
    readings.unshift({ date: batch.startDate, sg: batch.og });
  if (!readings.length) return;

  const points = readings.map(r => ({
    x: new Date(r.date).getTime(),
    y: chartMode === 'sg' ? parseFloat(r.sg) : calcABV(batch.og, r.sg),
    date: r.date,
    sg: parseFloat(r.sg)
  }));

  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  let minY = Math.min(...ys);
  let maxY = Math.max(...ys);

  const sugarBreak = calcSugarBreak(batch.og);
  if (sugarBreak) {
    const sb = parseFloat(sugarBreak);
    const val = chartMode === 'sg' ? sb : calcABV(batch.og, sugarBreak);
    minY = Math.min(minY, val - 0.002);
    maxY = Math.max(maxY, val + 0.002);
  }

  if (chartMode === 'sg') {
    minY = Math.max(0.98, minY - 0.005);
    maxY = Math.min(1.15, maxY + 0.005);
  } else {
    minY = Math.max(0, minY - 0.5);
    maxY += 0.5;
  }

  const W = logicalW - pad.l - pad.r;
  const H = logicalH - pad.t - pad.b;
  const xScale = v => pad.l + (W * (v - minX)) / Math.max(1, maxX - minX);
  const yScale = v => pad.t + H - (H * (v - minY)) / Math.max(0.0001, maxY - minY);

  points.forEach(p => {
    p.xx = xScale(p.x);
    p.yy = yScale(p.y);
  });

  // Tooltip setup
  let tooltip = document.getElementById('chart-tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'chart-tooltip';
    tooltip.className = 'chart-tooltip';
    tooltip.style.display = 'none';
    c.parentElement.style.position = 'relative';
    c.parentElement.appendChild(tooltip);
  }

  const renderBase = (highlight = null) => {
    ctx.clearRect(0, 0, logicalW, logicalH);
    ctx.save();

    // Axes
    ctx.strokeStyle = '#2a3340';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + H);
    ctx.lineTo(pad.l + W, pad.t + H);
    ctx.stroke();

    // Y grid
    ctx.fillStyle = '#8fa3bd';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'right';
    const step = chartMode === 'sg' ? 0.005 : Math.max(0.5, (maxY - minY) / 8);
    for (let y = minY; y <= maxY; y += step) {
      const yy = yScale(y);
      ctx.fillText(chartMode === 'sg' ? y.toFixed(3) : y.toFixed(1), pad.l - 6, yy + 3);
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.beginPath();
      ctx.moveTo(pad.l, yy);
      ctx.lineTo(pad.l + W, yy);
      ctx.stroke();
    }

    // X ticks
    ctx.textAlign = 'center';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const x = minX + (i * (maxX - minX)) / ticks;
      const xx = xScale(x);
      ctx.fillText(new Date(x).toLocaleDateString(), xx, pad.t + H + 20);
    }

    // Data line
    ctx.strokeStyle = chartMode === 'sg' ? '#82cfff' : '#b5e08a';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    points.forEach((p, i) => (i ? ctx.lineTo(p.xx, p.yy) : ctx.moveTo(p.xx, p.yy)));
    ctx.stroke();

    // Sugar break line
    if (sugarBreak) {
      const breakValue =
        chartMode === 'sg'
          ? parseFloat(sugarBreak)
          : calcABV(batch.og, sugarBreak);
      if (breakValue >= minY && breakValue <= maxY) {
        const yBreak = yScale(breakValue);
        const latestSG =
          batch.sgReadings?.length &&
          parseFloat(batch.sgReadings[batch.sgReadings.length - 1].sg);
        const reached = latestSG && latestSG <= parseFloat(sugarBreak);

        ctx.save();
        ctx.beginPath();
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.lineWidth = 1.2;
        ctx.moveTo(pad.l, yBreak);
        ctx.lineTo(pad.l + W, yBreak);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = reached ? '#00cc66' : '#ffaa33';
        ctx.beginPath();
        ctx.arc(pad.l + W - 8, yBreak, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('1/3 Break', pad.l + 8, yBreak - 6);
        ctx.restore();
      }
    }

    // Data points
    points.forEach((p, i) => {
      ctx.beginPath();
      if (i === 0) {
        ctx.fillStyle = '#ffd966';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui';
        ctx.fillStyle = '#ccc';
        ctx.fillText('OG', p.xx + 12, p.yy + 4);
      } else {
        ctx.fillStyle = chartMode === 'sg' ? '#b5e08a' : '#82cfff';
        ctx.arc(p.xx, p.yy, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    if (highlight) {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.arc(highlight.xx, highlight.yy, 7, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  };

  renderBase();

  // Hover handling
  const radius = 14;
  c.onmousemove = evt => {
    const rect = c.getBoundingClientRect();
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    const mx = (evt.clientX - rect.left) * scaleX / dpr;
    const my = (evt.clientY - rect.top) * scaleY / dpr;

    let nearest = null;
    let minDist = radius;
    for (const p of points) {
      const dx = p.xx - mx;
      const dy = p.yy - my;
      const dist = Math.sqrt(dx * dx + dy * dy * 0.6);
      if (dist < minDist) {
        nearest = p;
        minDist = dist;
      }
    }

    if (nearest) {
      renderBase(nearest);
      tooltip.style.display = 'block';

      // DPI-safe tooltip positioning
      const left = nearest.xx / dpr + 12;
      const top = nearest.yy / dpr - 28;
      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;

      const dateLabel = new Date(nearest.x).toLocaleDateString();
      const valueLabel =
        chartMode === 'sg'
          ? `SG: ${nearest.sg?.toFixed(3) ?? '‚Äî'}`
          : `ABV: ${nearest.y?.toFixed(1) ?? '‚Äî'}%`;
      const sugarLabel = sugarBreak
        ? `<div style="color:#ffaa33;">1/3 Break: ${sugarBreak}</div>`
        : '';

      tooltip.innerHTML = `
        <div><b>${dateLabel}</b></div>
        <div>${valueLabel}</div>
        ${sugarLabel}
      `;
    } else {
      tooltip.style.display = 'none';
      renderBase();
    }
  }; // ‚úÖ closes onmousemove

  c.onmouseleave = () => {
    tooltip.style.display = 'none';
    renderBase();
  };
} // ‚úÖ closes drawChart()


/* === UI Event Listeners === */

// === New Batch button ===
$('#newBatchBtn')?.addEventListener('click', () => {
  selectedId = null;
  render();
});

// === Sidebar live search ===
$('#searchInput')?.addEventListener('input', () => renderBatchList());

// === Clear all data ===
$('#clearBtn')?.addEventListener('click', () => {
  if (!confirm('‚ö†Ô∏è Delete ALL MeadTrics data? This cannot be undone.')) return;
  state = { batches: [] };
  selectedId = null;
  saveAll(state);
  render();
});

// === Export data as JSON ===
$('#exportBtn')?.addEventListener('click', () => {
  try {
    const blob = new Blob([JSON.stringify(state, null, 2)], {
      type: 'application/json'
    });
    const url = URL.createObjectURL(blob);
    const a = el('a', { href: url, download: 'meadtrics-data.json' });
    document.body.append(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error('Export failed:', err);
    alert('Export failed. Check console for details.');
  }
});


// Import data from JSON file
$('#importBtn').addEventListener('click', () => $('#importFile').click());
$('#importFile').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  const data = JSON.parse(text);
  state = data;
  selectedId = state.batches[0]?.id || null;
   saveAll(state);
  render();
});

function openLabelMaker(batch) {
  const existing = document.getElementById('labelModal');
  if (existing) existing.remove(); // remove old modal if open

  // Helper: escape plain text
  const escapeHTML = s => String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

  const date = batch.startDate ? new Date(batch.startDate).toLocaleDateString() : '‚Äî';
  const lastReading = (batch.sgReadings && batch.sgReadings.length)
    ? batch.sgReadings[batch.sgReadings.length - 1]
    : null;

  const OG = parseFloat(batch.og);
  const FG = lastReading ? parseFloat(lastReading.sg) : NaN;
  const abv = (isFinite(OG) && isFinite(FG))
    ? ((OG - FG) * 131.25).toFixed(1) + '%'
    : '‚Äì';
  const honey = batch.honey || 'Mixed Blossom';

  // === Build modal structure ===
  const modal = el('div', { id: 'labelModal', class: 'modal-overlay' }, [
    el('div', { class: 'modal-content card' }, [
      el('div', { class: 'label-preview', id: 'labelPreview' }, [
        el('h1', {
          text: batch.name,
          style: 'text-align:center;font-size:20pt;margin:0;'
        }),
        el('p', {
          text: `${honey} Mead`,
          style: 'text-align:center;margin:2mm 0;'
        }),
        el('hr', {
          style: 'border:none;border-top:1px solid #8b6b2c;margin:2mm 0;'
        }),
        el('p', { text: `Batch: ${batch.name}` }),
        el('p', { text: `Start: ${date}` }),
        el('p', { text: `ABV: ${abv}` }),
      ]),
      el('div', { class: 'row', style: 'justify-content:center;gap:8px;margin-top:10px;' }, [
        el('button', {
          id: 'printLabel',
          text: 'üñ®Ô∏è Print Label',
          class: 'btn-accent',
          onclick: () => window.print()
        }),
        el('button', {
          id: 'closeLabel',
          text: '‚úï Close',
          class: 'btn-danger',
          onclick: () => modal.remove()
        })
      ])
    ])
  ]);

  // === Add to document ===
  document.body.append(modal);

  // Close on overlay click
  modal.addEventListener('click', e => {
    if (e.target === modal) modal.remove();
  });

  // Close on Escape key
  document.addEventListener('keydown', function escHandler(ev) {
    if (ev.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', escHandler);
    }
  });
}


// === ExtendsClass JSON Storage Hybrid ===
let EXTENDS_BIN_ID = localStorage.getItem("EXTENDS_BIN_ID") || null;
let EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY") || "";
const EXTENDS_API = "https://json.extendsclass.com/bin";
const EXTENDS_KEY = "meadtracker";

function updateSyncCard() {
  const urlEl = document.getElementById("syncUrl");
  const keyEl = document.getElementById("syncKey");
  const keyInput = document.getElementById("apiKeyInput");
  const statusEl = document.getElementById("syncStatus");
  if (urlEl) {
    urlEl.textContent = EXTENDS_BIN_ID
      ? `${EXTENDS_API}/${EXTENDS_BIN_ID}`
      : "Local only (no cloud bin)";
  }
  if (keyEl) keyEl.textContent = EXTENDS_KEY;
  if (keyInput) keyInput.value = EXTENDS_API_KEY;
  if (statusEl)
    statusEl.textContent = EXTENDS_API_KEY
      ? "‚òÅÔ∏è Cloud Sync Active"
      : "üíæ Local-only mode";
}

// === Dynamic YAN estimator) ===
function updateYAN() {
  const yeastABV = parseFloat(document.getElementById('tosnaYeastABV').value) || 14;
  const sweetness = document.getElementById('tosnaSweetness').value;
  const req = document.getElementById('tosnaReq').value;
  let effYAN = 150;

  if (yeastABV <= 12) {
    if (sweetness === 'dry') effYAN = req === 'low' ? 100 : req === 'medium' ? 125 : 150;
    else if (sweetness === 'semi') effYAN = req === 'low' ? 120 : req === 'medium' ? 140 : 160;
    else effYAN = req === 'low' ? 130 : req === 'medium' ? 150 : 180;
  } else if (yeastABV <= 14) {
    if (sweetness === 'dry') effYAN = req === 'low' ? 120 : req === 'medium' ? 140 : 160;
    else if (sweetness === 'semi') effYAN = req === 'low' ? 130 : req === 'medium' ? 150 : 180;
    else effYAN = req === 'low' ? 150 : req === 'medium' ? 180 : 200;
  } else if (yeastABV <= 16) {
    if (sweetness === 'dry') effYAN = req === 'low' ? 140 : req === 'medium' ? 170 : 190;
    else if (sweetness === 'semi') effYAN = req === 'low' ? 160 : req === 'medium' ? 190 : 220;
    else effYAN = req === 'low' ? 170 : req === 'medium' ? 200 : 250;
  } else {
    effYAN = req === 'low' ? 180 : req === 'medium' ? 210 : 260;
  }

  document.getElementById('tosnaYan').value = Math.round(effYAN);
}

function initTosnaBindings() {
  const ids = ['tosnaYeastABV','tosnaSweetness','tosnaReq'];
  let found = false;
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (el) {
      found = true;
      el.addEventListener('input', updateYAN);
    }
  });
  if (found) updateYAN();
  
}

// === Auto FG / OG Estimator ===
function updateFGOG() {
  const yeastABV = parseFloat(document.getElementById('tosnaYeastABV').value) || 14;
  const sweetness = document.getElementById('tosnaSweetness').value;
  let fg = 1.000;

  if (sweetness === 'dry') fg = 1.000;
  else if (sweetness === 'semi') fg = 1.015;
  else if (sweetness === 'sweet') fg = 1.030;

  // Estimate OG needed to reach ABV goal
  const og = (fg + (yeastABV / 131.25)).toFixed(3);

  const display = document.getElementById('tosnaFGOG');
  display.innerHTML = `Estimated FG: <b>${fg.toFixed(3)}</b> ‚Üí Suggested OG: <b>${og}</b>`;
}

// === Backsweetening Calculator ===
function calcBacksweetening() {
  const sg1 = parseFloat(document.getElementById('back_currentSG').value);
  const sg2 = parseFloat(document.getElementById('back_desiredSG').value);
  const vol = parseFloat(document.getElementById('back_volume').value);
  const type = document.getElementById('back_type').value;
  const customPercent = parseFloat(document.getElementById('back_customPercent').value);

  if (isNaN(sg1) || isNaN(sg2) || isNaN(vol)) {
    alert("Please enter valid SG values and volume.");
    return;
  }

  // Convert SG to sugar g/L
  const sgToGpl = sg => (182.4601 * sg ** 3) - (775.6821 * sg ** 2) + (1262.7794 * sg) - 669.5622;
  const sugarCurrent = sgToGpl(sg1);
  const sugarDesired = sgToGpl(sg2);
  const sugarDiff = sugarDesired - sugarCurrent;

  const sugarKg = (sugarDiff * vol) / 1000; // g/L √ó L ‚Üí g ‚Üí kg

  // Convert to equivalent total weight based on type
  let factor = 1; // default 100% sugar
  let label = "sugar";

  if (type === "honey") {
    factor = 0.82;
    label = "honey";
  } else if (type === "custom") {
    if (isNaN(customPercent) || customPercent <= 0 || customPercent > 100) {
      alert("Please enter a valid custom sugar % between 1‚Äì100.");
      return;
    }
    factor = customPercent / 100;
    label = `${customPercent}% custom sweetener`;
  }

  const requiredKg = sugarKg / factor;

  document.getElementById('back_resultKg').value = requiredKg.toFixed(3);
  document.getElementById('backResult').innerHTML = `
    <b>Result:</b><br>
    ‚Ä¢ Add <b>${requiredKg.toFixed(3)} kg</b> of ${label}<br>
    (to raise SG from ${sg1.toFixed(3)} ‚Üí ${sg2.toFixed(3)})
  `;
}

// === Dilution Calculator ===
function calcDilution() {
  const sg1 = parseFloat(document.getElementById('dil_current').value);
  const sg2 = parseFloat(document.getElementById('dil_target').value);
  const vol = parseFloat(document.getElementById('dil_volume').value);

  if (isNaN(sg1) || isNaN(sg2) || isNaN(vol) || sg2 >= sg1) {
    alert("Enter valid numbers (target SG must be lower than current).");
    return;
  }

  const waterToAdd = vol * ((sg1 - sg2) / sg2);
  document.getElementById('dilResult').innerHTML =
    `Add approximately <b>${waterToAdd.toFixed(2)} L</b> of water to reduce from ${sg1.toFixed(3)} ‚Üí ${sg2.toFixed(3)} SG.`;
}

// === Priming Calculator ===
function calcPriming() {
  const vol = parseFloat(document.getElementById('prime_volume').value);
  const co2 = parseFloat(document.getElementById('prime_co2').value);

  if (isNaN(vol) || vol <= 0) {
    alert("Enter a valid batch volume in litres.");
    return;
  }

  if (co2 === 0) {
    document.getElementById('primeResult').innerHTML = `
      For <b>${vol.toFixed(1)} L</b> batch:<br>
      ‚Ä¢ No sugar needed ‚Äî for still mead.
    `;
    return;
  }

  // Simple rule: 1 CO‚ÇÇ volume ‚âà 4 g sugar per litre
  const sugarPerL = co2 * 4;
  const totalSugarG = vol * sugarPerL;
  const totalSugarKg = totalSugarG / 1000;

  document.getElementById('primeResult').innerHTML = `
    For <b>${vol.toFixed(1)} L</b> batch:<br>
    ‚Ä¢ Add <b>${totalSugarG.toFixed(0)} g</b> sugar 
      (<b>${totalSugarKg.toFixed(2)} kg</b>)<br>
    ‚Ä¢ Target carbonation: <b>${co2.toFixed(1)} vols CO‚ÇÇ</b><br>
    (Use table sugar or dextrose. Mix thoroughly before bottling.)
  `;
}

// === Stabilisation Calculator ===
function calcStabilisation() {
  const vol = parseFloat(document.getElementById('stab_volume').value);
  if (isNaN(vol) || vol <= 0) {
    alert("Enter a valid batch volume in litres.");
    return;
  }

  // Standard ‚Äúrule of thumb‚Äù stabilisation:
  // 0.2 g/L Potassium Sorbate
  // 0.15 g/L Potassium Metabisulfite
  const sorbate = vol * 0.2;
  const meta = vol * 0.15;

  document.getElementById('stabResult').innerHTML = `
    For <b>${vol.toFixed(1)} L</b> batch:<br>
    ‚Ä¢ Add <b>${sorbate.toFixed(2)} g</b> Potassium Sorbate<br>
    ‚Ä¢ Add <b>${meta.toFixed(2)} g</b> Potassium Metabisulfite<br>
  `;
}

// --- Brix <-> SG Converter ---
function brixToSG(brix) {
  return 1 + (brix / (258.6 - ((brix / 258.2) * 227.1)));
}

function sgToBrix(sg) {
  return (((182.4601 * sg - 775.6821) * sg + 1262.7794) * sg - 669.5622);
}

/**
 * Create a new ExtendsClass bin when the user has provided a key.
 */

async function createBin() {
  try {
    const EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY");
    const EXTENDS_KEY = localStorage.getItem("EXTENDS_KEY");
    if (!EXTENDS_API_KEY || !EXTENDS_KEY)
      throw new Error("Missing API or Security key");

    console.log("Api-key:", `"${EXTENDS_API_KEY}"`);
    console.log("Security-key:", `"${EXTENDS_KEY}"`);

    const res = await fetch(EXTENDS_API, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Api-key": EXTENDS_API_KEY,
        "Security-key": EXTENDS_KEY,
        "Private": "true"
      },
      body: JSON.stringify({ data: { batches: [] } })
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    EXTENDS_BIN_ID = data.id;
    localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
    updateViewBinButton();
    updateSyncCard();
    alert(`‚úÖ Created JSON bin:\n${EXTENDS_BIN_ID}`);
  } catch (err) {
    console.error("Failed to create bin:", err);
    alert("‚ö†Ô∏è Could not create JSON bin.\n" + err.message);
  }
}

/**
 * Load from ExtendsClass if API key present; otherwise from local storage.
 */
async function cloudLoad() {
  try {
    const EXTENDS_API_KEY = localStorage.getItem("EXTENDS_API_KEY");
    const EXTENDS_KEY = localStorage.getItem("EXTENDS_KEY");
    const EXTENDS_BIN_ID = localStorage.getItem("EXTENDS_BIN_ID");
    if (!EXTENDS_API_KEY || !EXTENDS_KEY || !EXTENDS_BIN_ID)
      throw new Error("Missing API key, Security key, or bin ID");

    const url = `${EXTENDS_API}/${EXTENDS_BIN_ID}`;
    const res = await fetch(url, {
      method: "GET",
      headers: {
        "Api-key": EXTENDS_API_KEY,
        "Security-key": EXTENDS_KEY
      }
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    console.log("‚òÅÔ∏è Cloud data loaded:", data);
    return data;
  } catch (err) {
    console.error("Failed to load bin:", err);
    alert("‚ö†Ô∏è Failed to load cloud data.\n" + err.message);
  }
}

/**
 * Save to ExtendsClass if API key provided, always save local.
 */
/**
 * Save to ExtendsClass if API key provided, always save local.
 * Uses PATCH (merge) when possible instead of full PUT overwrite.
 */
/**
 * Save to ExtendsClass if API key provided, always save local.
 * Uses PATCH (merge) when possible instead of full PUT overwrite.
 * Also auto-migrates legacy (non-wrapped) bins into { data: ... } format.
 */
async function cloudSave(payload, patchOnly = true) {
  try {
    // Always begin with a full clone of current app state
    let merged = structuredClone(state);

    // If a partial payload was provided, merge it into the clone
    if (payload && payload.batches) {
      for (const patchBatch of payload.batches) {
        const idx = merged.batches.findIndex(b => b.id === patchBatch.id);
        if (idx !== -1) {
          Object.assign(merged.batches[idx], patchBatch);
        } else {
          merged.batches.push(patchBatch);
        }
      }
    }

    // Before saving, check the current bin structure ‚Äî migrate if needed
    let shouldMigrate = false;
    try {
      const checkRes = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
        headers: { "Security-key": EXTENDS_KEY }
      });
      if (checkRes.ok) {
        const checkJson = await checkRes.json();
        if (Array.isArray(checkJson.batches) && !checkJson.data) {
          console.log("üß© Legacy bin detected (root-level batches) ‚Äî will migrate to {data:...} format.");
          shouldMigrate = true;
        }
      }
    } catch (e) {
      console.warn("‚ö†Ô∏è Could not inspect bin before save:", e);
    }

    const method = patchOnly ? "PATCH" : "PUT";
    const headers = {
      "Content-Type": patchOnly
        ? "application/merge-patch+json"
        : "application/json",
      "Security-key": EXTENDS_KEY
    };

    // Always store in wrapped form { data: merged }
	if (merged.data && merged.batches) delete merged.batches; // üßπ clean
    const body = JSON.stringify({ data: merged });

    const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
      method,
      headers,
      body
    });

    if (!res.ok) {
      if (patchOnly && (res.status === 400 || res.status === 404)) {
        console.warn(`‚ö†Ô∏è PATCH failed (${res.status}), retrying full PUT`);
        return cloudSave(state, false);
      }
      throw new Error(`HTTP ${res.status}`);
    }

    console.log(`‚òÅÔ∏è ${method} sync successful${shouldMigrate ? " ‚Äî bin migrated to new format" : ""}`);
    updateViewBinButton();
  } catch (err) {
    console.warn("‚ö†Ô∏è ExtendsClass sync failed", err);
    updateViewBinButton();
  }
}
window.addEventListener("beforeunload", () => cloudSave(state));

/**
 * Handle API-key input in the side panel.
 */
const saveApiKeyBtn = document.getElementById("saveApiKeyBtn");
if (saveApiKeyBtn) {
  saveApiKeyBtn.addEventListener("click", async () => {
    const keyInput = document.getElementById("apiKeyInput");
    const newKey = keyInput.value.trim();

    // üßπ If the field is blank, clear all ExtendsClass info
    if (!newKey) {
      clearExtendsCredentials();
      EXTENDS_API_KEY = "";
      EXTENDS_BIN_ID = "";
      updateSyncCard();
      updateViewBinButton();
      console.log("üíæ Cloud sync disabled ‚Äî reverted to local-only mode.");
      alert("üíæ Cloud sync disabled ‚Äî now saving locally only.");
      return;
    }

    // Otherwise, save normally
    EXTENDS_API_KEY = newKey;
    localStorage.setItem("EXTENDS_API_KEY", EXTENDS_API_KEY);
    localStorage.setItem("EXTENDS_KEY", EXTENDS_KEY);

    console.log("üîë ExtendsClass API key saved:", EXTENDS_API_KEY);

    // Create a new bin if one doesn‚Äôt exist yet
    if (!EXTENDS_BIN_ID) {
      // üß© Check if a bin already exists for this API key
      const existingBin = await getExistingBin();
      if (existingBin) {
        EXTENDS_BIN_ID = existingBin;
        localStorage.setItem("EXTENDS_BIN_ID", EXTENDS_BIN_ID);
        console.log(`‚òÅÔ∏è Using existing bin: ${EXTENDS_BIN_ID}`);
      } else {
        await createBin();
      }
    }

    async ()();
    updateViewBinButton();

    // üü¢ NEW: Immediately fetch or push cloud data
    try {
      const cloudData = await cloudLoad();
      if (cloudData && cloudData.batches && cloudData.batches.length > 0) {
        console.log("‚òÅÔ∏è Loaded cloud data after key entry:", cloudData);
        state = cloudData;
        save(state);
        render();
        alert("‚úÖ API key saved ‚Äî cloud data loaded successfully.");
      } else {
        console.log("‚òÅÔ∏è No cloud data found ‚Äî uploading local state.");
        await cloudSave(state);
        alert("‚úÖ API key saved ‚Äî local data uploaded to cloud.");
      }
    } catch (err) {
      console.warn("‚ö†Ô∏è Failed to load cloud data after key entry:", err);
      alert("‚ö†Ô∏è API key saved, but failed to fetch cloud data. Using local data for now.");
    }
  });
}

/**
 * Try to find an existing ExtendsClass bin for this API key.
 * Uses GET https://json.extendsclass.com/bins with header "Api-key".
 * Returns the first bin ID if found, or null if none.
 */
async function getExistingBin() {
  if (!EXTENDS_API_KEY) {
    console.log("‚ö†Ô∏è No ExtendsClass API key ‚Äî skipping bin lookup.");
    return null;
  }

  try {
    const res = await fetch(`https://json.extendsclass.com/bins?nocache=${Date.now()}`, {
      headers: { "Api-key": EXTENDS_API_KEY },
      cache: "no-store"
    });

    console.log("Fetched /bins at", new Date().toISOString(), "status", res.status);

    if (res.status === 401) {
      console.warn("‚ö†Ô∏è Wrong API key ‚Äî cannot fetch bins.");
      return null;
    }
    if (res.status === 429) {
      console.warn("‚ö†Ô∏è ExtendsClass rate limit exceeded ‚Äî try again later.");
      return null;
    }
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const bins = await res.json();
    if (Array.isArray(bins) && bins.length > 0) {
      console.log(`‚òÅÔ∏è Found existing bins: ${bins.join(", ")}`);
      // reuse the first bin
      return bins[0];
    }

    console.log("‚òÅÔ∏è No existing bins found for this API key.");
    return null;
  } catch (err) {
    console.warn("‚ö†Ô∏è Could not fetch existing bins:", err);
    return null;
  }
}

function updateViewBinButton() {
  const btn = document.getElementById("viewBinBtn");
  if (!btn) return;

  if (EXTENDS_BIN_ID && EXTENDS_API_KEY) {
    btn.style.display = "inline-block";
    btn.onclick = async (e) => {
      e.stopPropagation();
      try {
        const res = await fetch(`${EXTENDS_API}/${EXTENDS_BIN_ID}`, {
          headers: {
            "Api-key": EXTENDS_API_KEY,
            "Security-key": EXTENDS_KEY
          }
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        // ‚úÖ open popup safely (prevent Chrome cross-origin issue)
        const popup = window.open("about:blank", "binPopup", "width=700,height=600,resizable,scrollbars=yes");
        if (!popup) return alert("‚ö†Ô∏è Popup blocked. Please allow popups for this site.");

        // build the shell first
        popup.document.write(`
          <html>
            <head>
              <title>MeadTrics Cloud Bin ‚Äì ${EXTENDS_BIN_ID}</title>
              <style>
                body {
                  background-color: #0f141b;
                  color: #e4e9f0;
                  font-family: monospace;
                  padding: 16px;
                  white-space: pre-wrap;
                  overflow-wrap: anywhere;
                }
                h2 {
                  font-family: system-ui, sans-serif;
                  font-size: 16px;
                  margin-top: 0;
                  color: #ffd86b;
                }
                code {
                  background: #1a2028;
                  padding: 8px;
                  display: block;
                  border-radius: 8px;
                  border: 1px solid #2a3340;
                }
              </style>
            </head>
            <body>
              <h2>Cloud Bin: ${EXTENDS_BIN_ID}</h2>
              <code id="jsonArea">Loading...</code>
            </body>
          </html>
        `);
        popup.document.close();

        // ‚úÖ delay JSON injection to avoid race condition
        popup.onload = () => {
          const area = popup.document.getElementById("jsonArea");
          if (area) area.textContent = JSON.stringify(data, null, 2);
        };

      } catch (err) {
        console.error("Failed to load bin:", err);
        alert("‚ö†Ô∏è Failed to load bin:\n" + err.message);
      }
    };
  } else {
    btn.style.display = "none";
  }
}


async function saveAll(state, changedBatch = null, changedFields = null) {
  save(state); // always save local first

  // No cloud connection configured
  if (!EXTENDS_BIN_ID || !EXTENDS_KEY) {
    console.log("üíæ Local-only save (no ExtendsClass key).");
    return;
  }
async ()
  // Build minimal patch payload if we know what changed
  let payload;
  if (changedBatch && Array.isArray(changedFields) && changedFields.length) {
    const partial = { batches: [] };
    const patch = { id: changedBatch.id };
    for (const f of changedFields) {
      // Copy only requested properties
      if (changedBatch[f] !== undefined)
        patch[f] = structuredClone(changedBatch[f]);
    }
    partial.batches.push(patch);
    payload = partial;
    console.log("‚òÅÔ∏è Sending minimal PATCH:", partial);
  } else {
    payload = state;
    console.log("‚òÅÔ∏è Sending full PATCH (no diff info).");
  }

  // Send to cloud
  await cloudSave(state, true);
}

function clearExtendsCredentials() {
  const keys = [
    "EXTENDS_BIN_ID",
    "EXTENDS_KEY",
    "EXTENDS_API_KEY"
  ];
  for (const k of keys) localStorage.removeItem(k);

  // üß† Mark that user intentionally disabled cloud sync
  localStorage.setItem("EXTENDS_MANUAL_DISABLE", "1");

  console.log("üßπ Cleared ExtendsClass credentials from localStorage.");
}

// === Migration: old MeadTrics ‚Üí new system ===
function migrateOldLocalData() {
  try {
    const oldKeyNames = [
      "mead-tracker:v1",
      "meadTrackerState",
      "batches",
      "meadTracker" // catch older keys
    ];

    // find first matching old key
    const foundKey = oldKeyNames.find((k) => localStorage.getItem(k));
    if (!foundKey) return false; // nothing to migrate

    const oldData = JSON.parse(localStorage.getItem(foundKey));
    if (!oldData || localStorage.getItem("MIGRATION_DONE")) return false;

    console.log(`üß© Found old MeadTrics data in '${foundKey}' ‚Üí migrating...`);

    // Build new state format
    const newState = oldData.batches
      ? oldData
      : { batches: Array.isArray(oldData) ? oldData : [oldData] };

    // Save under new format
    save(newState);
    localStorage.setItem("MIGRATION_DONE", "true");

    // If user already has cloud enabled, push immediately
    if (EXTENDS_API_KEY && EXTENDS_BIN_ID) {
      cloudSave(newState).then(() =>
        console.log("‚òÅÔ∏è Migrated data uploaded to cloud.")
      );
    }

    alert(
      "‚úÖ Your old MeadTrics data has been automatically migrated to the new version.\nAll batches are safe and backed up locally."
    );

    return true;
  } catch (err) {
    console.warn("Migration check failed:", err);
    return false;
  }
}

// === Startup ===
(async () => {
  // === detect if we have a valid ExtendsClass bin ===
  const hasValidBin =
    typeof EXTENDS_BIN_ID !== "undefined" &&
    EXTENDS_BIN_ID &&
    EXTENDS_BIN_ID.trim() !== "";

  // If no bin, politely remind the user once
  // Only show the local-only alert if the user hasn‚Äôt manually disabled cloud sync
  const manuallyDisabled = localStorage.getItem("EXTENDS_MANUAL_DISABLE") === "1";
  
  if (!hasValidBin && !manuallyDisabled && !localStorage.getItem("EXTENDS_NOTICE_SHOWN")) {
    alert(
      "üíæ MeadTrics is saving locally for now.\n\n" +
      "To enable free cloud backup, create an account at:\n" +
      "https://extendsclass.com/json-storage.html\n" +
      "and paste your API key into the Cloud Sync panel."
    );
    localStorage.setItem("EXTENDS_NOTICE_SHOWN", "true");
  }

  // --- normal startup ---
  migrateOldLocalData();

  // Step 1: local render
  state = load();
  render();
  updateSyncCard();
  updateViewBinButton();

  // üü¢ NEW: If we have a valid bin but no local batches, pull cloud data first
  if (hasValidBin && (!state.batches || !state.batches.length)) {
    const cloud = await cloudLoad();
    if (cloud && cloud.batches?.length) {
      console.log("‚òÅÔ∏è Loaded cloud data on startup (local was empty).");
      state = cloud;
      save(state);
      render();
    }
  }

  // Step 2: cloud logic only if bin exists
  if (hasValidBin) {
    try {
      const cloud = await cloudLoad();

      if (cloud && cloud.batches && cloud.batches.length > 0) {
        console.log("‚òÅÔ∏è Loaded cloud data successfully.");
        console.log("‚òÅÔ∏è Replacing local with cloud data.");
        state = cloud;
        save(state);
        render();
      } else if (state && state.batches && state.batches.length > 0) {
        console.log("‚òÅÔ∏è Cloud empty ‚Äî pushing local data up for the first time.");
        await cloudSave(state);
      } else {
        console.log("‚òÅÔ∏è Cloud and local both empty ‚Äî starting fresh.");
      }
    } catch (err) {
      console.warn("‚ö†Ô∏è Cloud load failed ‚Äî using local copy:", err);
    }
  } else {
    console.log("üíæ Loaded local data (no ExtendsClass bin configured).");
  }

  updateSyncCard();
})();

</script>
</body>
</html>